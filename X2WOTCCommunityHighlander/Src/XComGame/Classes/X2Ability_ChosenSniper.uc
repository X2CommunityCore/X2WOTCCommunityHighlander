
//  Copyright (c) 2016 Firaxis Games, Inc. All rights reserved.
//---------------------------------------------------------------------------------------
class X2Ability_ChosenSniper extends X2Ability
	config(GameData_SoldierSkills)
	native(Core);           //  This is only native to expose it for the TrackingShot effect name to be checked for the pathing cursor check.

var localized string TrackingShotMark_Added, TrackingShotMark_Cleansed;

var config int HUNTERGRAPPLE_COOLDOWN_NUM_TURNS;
var config int LETHALDOSE_COOLDOWN_NUM_TURNS;
var config int LETHALDOSE_UNCONCIOUS_BASECHANCE;
var config int LETHALDOSE_STUN2_BASECHANCE;
var config int LETHALDOSE_STUN1_BASECHANCE;
var config int LETHALDOSE_DAZE1_TURNS;
var config int LETHALDOSE_DAZE2_TURNS;
var config int TRACKINGSHOT_LENGTH_TILES;
var config int TRACKINGSHOT_END_DIAMETER_TILES;

var name TrackingShotMarkSourceEffectName, TrackingShotMarkTargetEffectName;

static function array<X2DataTemplate> CreateTemplates()
{
	local array<X2DataTemplate> Templates;
	
	Templates.AddItem(CreateHunterKillzone());
	Templates.AddItem(CreateHunterRifleShot());
	Templates.AddItem(CreateHunterGrapple());
	Templates.AddItem(CreateTrackingShotMark());
	Templates.AddItem(CreateTrackingShot());
	Templates.AddItem(PurePassive('Farsight', "img:///UILibrary_DLC3Images.UIPerk_Farsight", false, 'eAbilitySource_Perk', true));
	Templates.AddItem(CreateLethalDose());
	
	return Templates;
}

static function X2AbilityTemplate CreateHunterKillZone()
{
	local X2AbilityTemplate             Template;
	local int AbilityCostIndex;
	local X2Effect_Persistent KillZoneEffect;

	Template = class'X2Ability_SharpshooterAbilitySet'.static.KillZone('HunterKillzone', true);
	Template.BuildAppliedVisualizationSyncFn = KillZone_BuildVisualizationSync;

	KillZoneEffect = new class'X2Effect_Persistent';
	KillZoneEffect.EffectName = 'KillZoneVisualEffect';
	KillZoneEffect.BuildPersistentEffect(1, false, true, false, eGameRule_PlayerTurnBegin);
	KillZoneEffect.VisualizationFn = KillZoneEffect_Visualization;
	KillZoneEffect.EffectRemovedVisualizationFn = KillZoneEffect_RemovedVisualizationFn;
	KillZoneEffect.EffectSyncVisualizationFn = KillZoneEffect_Visualization;
	Template.AddShooterEffect(KillZoneEffect);

	for (AbilityCostIndex = 0; AbilityCostIndex < Template.AbilityCosts.Length; ++AbilityCostIndex)
	{
		if (Template.AbilityCosts[AbilityCostIndex].IsA('X2AbilityCost_ActionPoints'))
		{
			X2AbilityCost_ActionPoints(Template.AbilityCosts[AbilityCostIndex]).iNumPoints = 1;
			break;
		}
	}

//BEGIN AUTOGENERATED CODE: Template Overrides 'HunterKillzone'
	Template.bFrameEvenWhenUnitIsHidden = true;
//END AUTOGENERATED CODE: Template Overrides 'HunterKillzone'

	RemoveChosenShooterConditions(Template);

	return Template;
}

static function KillZoneEffect_Visualization(XComGameState VisualizeGameState, out VisualizationActionMetadata ActionMetadata, const name EffectApplyResult)
{
	local X2Action_PlayEffect PlayEffectAction;
	local XComGameState_Unit ShooterState;
	local vector SourceLoc, TargetLoc, TurnVector;
	local XComWorldData XWorld;
	local XComGameStateContext_Ability Context;

	XWorld = `XWORLD;
	ShooterState = XComGameState_Unit(VisualizeGameState.GetGameStateForObjectID(ActionMetadata.StateObject_NewState.ObjectID));
	SourceLoc = XWorld.GetPositionFromTileCoordinates(ShooterState.TileLocation);
	Context = XComGameStateContext_Ability(VisualizeGameState.GetContext());
	if (Context.InputContext.TargetLocations.Length > 0)
	{
		TargetLoc = Context.InputContext.TargetLocations[0];
		TurnVector = TargetLoc - SourceLoc;
		TurnVector = Normal(TurnVector);

		PlayEffectAction = X2Action_PlayEffect(class'X2Action_PlayEffect'.static.AddToVisualizationTree(ActionMetadata, VisualizeGameState.GetContext(), false, ActionMetadata.LastActionAdded));
		PlayEffectAction.AttachToUnit = false;
		PlayEffectAction.EffectName = "FX_Killzone.P_Killzone";
		PlayEffectAction.EffectLocation = SourceLoc;
		PlayEffectAction.EffectRotation = Rotator(TurnVector);
	}
}

simulated function KillZoneEffect_RemovedVisualizationFn(XComGameState VisualizeGameState, out VisualizationActionMetadata ActionMetadata, const name EffectApplyResult)
{
	local X2Action_PlayEffect PlayEffectAction;
	local XComGameState_Unit ShooterState;

	PlayEffectAction = X2Action_PlayEffect(class'X2Action_PlayEffect'.static.AddToVisualizationTree(ActionMetadata, VisualizeGameState.GetContext(), false, ActionMetadata.LastActionAdded));
	PlayEffectAction.AttachToUnit = false;
	PlayEffectAction.EffectName = "FX_Killzone.P_Killzone";
	ShooterState = XComGameState_Unit(VisualizeGameState.GetGameStateForObjectID(ActionMetadata.StateObject_NewState.ObjectID));
	PlayEffectAction.EffectLocation = `XWORLD.GetPositionFromTileCoordinates(ShooterState.TileLocation);;
	PlayEffectAction.bStopEffect = true;
}

simulated function KillZone_BuildVisualizationSync(name EffectName, XComGameState VisualizeGameState, out VisualizationActionMetadata ActionMetadata)
{
	local XComGameStateContext_Ability  Context;
	local XComGameState_Unit UnitState;
	local XComGameState_Ability AbilityState;
	local StateObjectReference AbilityRef;

	if (EffectName == 'KillZoneSource')
	{
		Context = XComGameStateContext_Ability(VisualizeGameState.GetContext());
		UnitState = XComGameState_Unit(`XCOMHISTORY.GetGameStateForObjectID(Context.InputContext.SourceObject.ObjectID));
		`assert(UnitState != none);
		AbilityRef = UnitState.FindAbility('KillZoneShot');
		if (AbilityRef.ObjectID >= 0)
		{
			AbilityState = XComGameState_Ability(`XCOMHISTORY.GetGameStateForObjectID(AbilityRef.ObjectID));
			if (AbilityState != None && AbilityState.ValidActivationTiles.Length > 0)
			{
				XComTacticalController(`LOCALPLAYERCONTROLLER).m_kPathingPawn.ActiveKillzoneAbilityID = AbilityState.ObjectID;
			}
		}
	}
}

static function X2AbilityTemplate CreateHunterRifleShot()
{
	local X2AbilityTemplate Template;
	local X2AbilityCost_ActionPoints ActionPointCost;
	local X2AbilityCooldown Cooldown;

	Template = class'X2Ability_WeaponCommon'.static.Add_SniperStandardFire('HunterRifleShot');

	Template.AbilityCosts.Length = 0;

	// Action Point
	ActionPointCost = new class'X2AbilityCost_ActionPoints';
	ActionPointCost.iNumPoints = 1;
	ActionPointCost.bConsumeAllPoints = true;
	Template.AbilityCosts.AddItem(ActionPointCost);

	// Cooldown
	Cooldown = new class'X2AbilityCooldown';
	Cooldown.iNumTurns = 1;
	Template.AbilityCooldown = Cooldown;
//BEGIN AUTOGENERATED CODE: Template Overrides 'HunterRifleShot'
	Template.bShowActivation = true;
	Template.bFrameEvenWhenUnitIsHidden = true;
//END AUTOGENERATED CODE: Template Overrides 'HunterRifleShot'

	RemoveChosenShooterConditions(Template);

	return Template;
}

static function X2AbilityTemplate CreateHunterGrapple()
{
	local X2AbilityTemplate Template;
	local X2AbilityCooldown Cooldown;

	Template = class'X2Ability_DefaultAbilitySet'.static.AddGrapple('HunterGrapple');

	Template.AbilityCosts.Length = 0;

	// Action Point
	Template.AbilityCosts.AddItem(default.FreeActionCost);

	// Cooldown
	Cooldown = new class'X2AbilityCooldown';
	Cooldown.iNumTurns = default.HUNTERGRAPPLE_COOLDOWN_NUM_TURNS;
	Template.AbilityCooldown = Cooldown;
//BEGIN AUTOGENERATED CODE: Template Overrides 'HunterGrapple'
	Template.bShowActivation = true;
	Template.bFrameEvenWhenUnitIsHidden = true;
//END AUTOGENERATED CODE: Template Overrides 'HunterGrapple'

	RemoveChosenShooterConditions(Template);

	return Template;
}

static function X2DataTemplate CreateTrackingShotMark()
{
	local X2AbilityTemplate Template;
	local X2AbilityCost_ActionPoints ActionPointCost;
	//local X2Condition_Visibility TargetVisibilityCondition;
	local X2Condition_UnitProperty TargetCondition;
	local X2Condition_UnitEffects UnitEffectsCondition;
	local X2Effect_Persistent TrackingShotMarkSource;
	local X2Effect_TrackingShotMarkTarget TrackingShotMarkTarget;
	local X2Condition_BattleState EngagedCondition;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'TrackingShotMark');

//BEGIN AUTOGENERATED CODE: Template Overrides 'TrackingShotMark'
	Template.bShowActivation = true;
	Template.bFrameEvenWhenUnitIsHidden = true;
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_trackingshot";
//END AUTOGENERATED CODE: Template Overrides 'TrackingShotMark'
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_AlwaysShow;
	Template.AbilitySourceName = 'eAbilitySource_Standard';
	Template.Hostility = eHostility_Neutral;

	ActionPointCost = new class'X2AbilityCost_ActionPoints';
	ActionPointCost.iNumPoints = 1;
	ActionPointCost.bFreeCost = false;
	Template.AbilityCosts.AddItem(ActionPointCost);

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SimpleSingleTarget;
	Template.AbilityTriggers.AddItem(default.PlayerInputTrigger);

	// Shooter Conditions
	Template.AbilityShooterConditions.AddItem(default.LivingShooterProperty);

	// Source cannot already be targeting
	UnitEffectsCondition = new class'X2Condition_UnitEffects';
	UnitEffectsCondition.AddExcludeEffect(default.TrackingShotMarkSourceEffectName, 'AA_DuplicateEffectIgnored');
	Template.AbilityShooterConditions.AddItem(UnitEffectsCondition);

	// Source Effect
	TrackingShotMarkSource = new class 'X2Effect_Persistent';
	TrackingShotMarkSource.EffectName = default.TrackingShotMarkSourceEffectName;
	TrackingShotMarkSource.DuplicateResponse = eDupe_Ignore;
	TrackingShotMarkSource.BuildPersistentEffect(1, true, true, false, eGameRule_PlayerTurnBegin);
	TrackingShotMarkSource.bRemoveWhenTargetDies = true;
	TrackingShotMarkSource.EffectTickedFn = TrackingShotMark_EffectTicked;
	Template.AddShooterEffect(TrackingShotMarkSource);

	// Source condition - Only use Tracking Shot when enemy is engaged in combat.
	EngagedCondition = new class'X2Condition_BattleState';
	EngagedCondition.bIncludeTheLostInEngagedCount = true;
	EngagedCondition.MinEngagedEnemies = 2; // Don't forget +1 for the chosen unit itself.
	Template.AbilityShooterConditions.AddItem(EngagedCondition);

	// Target Conditions
	Template.AbilityTargetConditions.AddItem(default.LivingHostileUnitOnlyProperty);

	// Target cannot already be targeted
	UnitEffectsCondition = new class'X2Condition_UnitEffects';
	UnitEffectsCondition.AddExcludeEffect(default.TrackingShotMarkTargetEffectName, 'AA_DuplicateEffectIgnored');
	Template.AbilityTargetConditions.AddItem(UnitEffectsCondition);

	// Target must be visible
	//TargetVisibilityCondition = new class'X2Condition_Visibility';
	//TargetVisibilityCondition.bRequireLOS = true;
	//Template.AbilityTargetConditions.AddItem(TargetVisibilityCondition);

	// And not concealed
	TargetCondition = new class'X2Condition_UnitProperty';
	TargetCondition.ExcludeConcealed = true;
	Template.AbilityTargetConditions.AddItem(TargetCondition);

	// Target Effect
	TrackingShotMarkTarget = new class 'X2Effect_TrackingShotMarkTarget';
	TrackingShotMarkTarget.EffectName = default.TrackingShotMarkTargetEffectName;
	TrackingShotMarkTarget.ConeEndDiameter = default.TRACKINGSHOT_END_DIAMETER_TILES * class'XComWorldData'.const.WORLD_StepSize;
	TrackingShotMarkTarget.ConeLength = default.TRACKINGSHOT_LENGTH_TILES * class'XComWorldData'.const.WORLD_StepSize;
	TrackingShotMarkTarget.DuplicateResponse = eDupe_Ignore;
	TrackingShotMarkTarget.BuildPersistentEffect(1, true, true, false, eGameRule_PlayerTurnEnd);
	TrackingShotMarkTarget.SetDisplayInfo(ePerkBuff_Penalty, Template.LocFriendlyName, Template.GetMyLongDescription(), Template.IconImage, , , Template.AbilitySourceName);
	TrackingShotMarkTarget.bRemoveWhenTargetDies = true;
	TrackingShotMarkTarget.EffectTickedFn = TrackingShotMark_EffectTicked;
	TrackingShotMarkTarget.VisualizationFn = TrackingShotMarkTarget_VisualizationFn;
	TrackingShotMarkTarget.EffectRemovedVisualizationFn = TrackingShotMarkTarget_RemovedVisualizationFn;
	Template.AddTargetEffect(TrackingShotMarkTarget);

	Template.bSkipFireAction = true;

	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = TrackingShotMark_BuildVisualization;

	Template.CinescriptCameraType = "ChosenSniper_TrackingShotMark";

	return Template;
}

simulated function TrackingShotMark_BuildVisualization(XComGameState VisualizeGameState)
{
	local XComGameStateHistory History;
	local XComGameStateContext_Ability Context;
	local StateObjectReference InteractingUnitRef;

	local VisualizationActionMetadata EmptyTrack;
	local VisualizationActionMetadata SourceTrack, BuildTrack;
	local X2Action_CameraLookAt LookAtAction;
	local X2Action_ExitCover ExitCoverAction;
	local X2Action_PlaySoundAndFlyover FlyoverAction;

	History = `XCOMHISTORY;

	Context = XComGameStateContext_Ability(VisualizeGameState.GetContext());
	InteractingUnitRef = Context.InputContext.SourceObject;

	//Configure the visualization track for the shooter
	//****************************************************************************************
	SourceTrack = EmptyTrack;
	SourceTrack.StateObject_OldState = History.GetGameStateForObjectID(InteractingUnitRef.ObjectID, eReturnType_Reference, VisualizeGameState.HistoryIndex - 1);
	SourceTrack.StateObject_NewState = VisualizeGameState.GetGameStateForObjectID(InteractingUnitRef.ObjectID);
	SourceTrack.VisualizeActor = History.GetVisualizer(InteractingUnitRef.ObjectID);

	ExitCoverAction = X2Action_ExitCover(class'X2Action_ExitCover'.static.AddToVisualizationTree(SourceTrack, Context));
	ExitCoverAction.bDoNotAddFramingCamera = true;
	//If we were interrupted, insert a marker node for the interrupting visualization code to use. In the move path version above, it is expected for interrupts to be 
	//done during the move.
	if (Context.InterruptionStatus != eInterruptionStatus_None)
	{
		//Insert markers for the subsequent interrupt to insert into
		class'X2Action'.static.AddInterruptMarkerPair(SourceTrack, Context, ExitCoverAction);
	}

	// Update - removed the Fire action that was actually shooting at the target.  Camera zooms to target after stepping out here.
	class'X2Action_EnterCover'.static.AddToVisualizationTree(SourceTrack, Context, false, ExitCoverAction);
	
	// Trigger the Chosen's narrative line for marking his shot
	class'XComGameState_NarrativeManager'.static.BuildVisualizationForDynamicNarrative(VisualizeGameState, false, 'AttackBegin', ExitCoverAction);

	// Configure the visualization track for the target
	//******************************************************************************************
	InteractingUnitRef = Context.InputContext.PrimaryTarget;
	BuildTrack = EmptyTrack;
	BuildTrack.StateObject_OldState = History.GetGameStateForObjectID(InteractingUnitRef.ObjectID, eReturnType_Reference, VisualizeGameState.HistoryIndex - 1);
	BuildTrack.StateObject_NewState = VisualizeGameState.GetGameStateForObjectID(InteractingUnitRef.ObjectID);
	BuildTrack.VisualizeActor = History.GetVisualizer(InteractingUnitRef.ObjectID);

	LookAtAction = X2Action_CameraLookAt(class'X2Action_CameraLookAt'.static.AddToVisualizationTree(BuildTrack, Context, false, ExitCoverAction));
	LookAtAction.LookAtActor = BuildTrack.VisualizeActor;
	LookAtAction.BlockUntilActorOnScreen = true;
	LookAtAction.LookAtDuration = 2.5f;
	LookAtAction.TargetZoomAfterArrival = -0.1f;
	
	FlyoverAction = X2Action_PlaySoundAndFlyover(class'X2Action_PlaySoundAndFlyover'.static.AddToVisualizationTree(BuildTrack, Context, false, LookAtAction));
	FlyoverAction.SetSoundAndFlyOverParameters(none, default.TrackingShotMark_Added, '', eColor_Bad);
}

static function TrackingShotMarkTarget_VisualizationFn(XComGameState VisualizeGameState, out VisualizationActionMetadata ActionMetadata, const name EffectApplyResult)
{
	local XComGameState_Unit TargetState;

	if (EffectApplyResult == 'AA_Success')
	{
		TargetState = XComGameState_Unit(VisualizeGameState.GetGameStateForObjectID(ActionMetadata.StateObject_NewState.ObjectID));
		if (TargetState != none)
		{
			class'X2StatusEffects'.static.AddEffectSoundAndFlyOverToTrack(ActionMetadata, VisualizeGameState.GetContext(), default.TrackingShotMark_Added, '', eColor_Bad, class'UIUtilities_Image'.const.UnitStatus_Marked);
		}
	}
}

simulated function TrackingShotMarkTarget_RemovedVisualizationFn(XComGameState VisualizeGameState, out VisualizationActionMetadata ActionMetadata, const name EffectApplyResult)
{
	local XComGameState_Unit TargetState;

	TargetState = XComGameState_Unit(VisualizeGameState.GetGameStateForObjectID(ActionMetadata.StateObject_NewState.ObjectID));
	if (TargetState != none)  // TODO: consider add condition to check that this unit did not receive damage, causing this mark to go away
	{
		class'X2StatusEffects'.static.AddEffectSoundAndFlyOverToTrack(ActionMetadata, VisualizeGameState.GetContext(), default.TrackingShotMark_Cleansed, '', eColor_Good, class'UIUtilities_Image'.const.UnitStatus_Marked);
	}
}

function bool TrackingShotMark_EffectTicked(X2Effect_Persistent PersistentEffect, const out EffectAppliedData ApplyEffectParameters, XComGameState_Effect kNewEffectState, XComGameState NewGameState, bool FirstApplication)
{
	local XComGameState_Unit TargetState;
	local XComGameStateHistory History;
	local TTile TargetTileLocation, TestTileLocation;

	History = `XCOMHISTORY;
	TargetState = XComGameState_Unit(History.GetGameStateForObjectID(ApplyEffectParameters.TargetStateObjectRef.ObjectID));

	TargetState.GetKeystoneVisibilityLocation(TargetTileLocation);

	foreach kNewEffectState.AffectedTiles(TestTileLocation)
	{
		if( TestTileLocation == TargetTileLocation )
		{
			return false;	// the target is still in the effect area
		}
	}

	return true;  // end the effect once the target moves out of the affected area
}

static function X2DataTemplate CreateTrackingShot()
{
	local X2AbilityTemplate Template;
	local X2AbilityCost_ActionPoints ActionPointCost;
	local X2Condition_UnitEffectsWithAbilitySource UnitEffectsCondition;
	//local X2Condition_Visibility TargetVisibilityCondition;
	local X2Effect_RemoveEffects RemoveEffects;

	Template = class'X2Ability_WeaponCommon'.static.Add_SniperStandardFire('TrackingShot');

	Template.AdditionalAbilities.AddItem('TrackingShotMark');

	Template.AbilityCosts.Length = 0;
	Template.AbilityToHitCalc = default.DeadEye;

	// Action Point
	ActionPointCost = new class'X2AbilityCost_ActionPoints';
	ActionPointCost.iNumPoints = 1;
	ActionPointCost.bConsumeAllPoints = false;
	Template.AbilityCosts.AddItem(ActionPointCost);

	// Source must be targeting
	UnitEffectsCondition = new class'X2Condition_UnitEffectsWithAbilitySource';
	UnitEffectsCondition.AddRequireEffect(default.TrackingShotMarkSourceEffectName, 'AA_MissingRequiredEffect');
	Template.AbilityShooterConditions.AddItem(UnitEffectsCondition);

	RemoveEffects = new class'X2Effect_RemoveEffects';
	RemoveEffects.EffectNamesToRemove.AddItem(default.TrackingShotMarkSourceEffectName);
	RemoveEffects.bApplyOnMiss = true;
	Template.AddShooterEffect(RemoveEffects);

	// Target Conditions
	Template.AbilityTargetConditions.Length = 0;

	//TargetVisibilityCondition = new class'X2Condition_Visibility';
	//TargetVisibilityCondition.bRequireLOS = true;
	//Template.AbilityTargetConditions.AddItem(TargetVisibilityCondition);

	Template.AbilityTargetConditions.AddItem(default.LivingHostileUnitOnlyProperty);
	
	// Target must be targeted
	UnitEffectsCondition = new class'X2Condition_UnitEffectsWithAbilitySource';
	UnitEffectsCondition.AddRequireEffect(default.TrackingShotMarkTargetEffectName, 'AA_MissingRequiredEffect');
	Template.AbilityTargetConditions.AddItem(UnitEffectsCondition);

	RemoveEffects = new class'X2Effect_RemoveEffects';
	RemoveEffects.EffectNamesToRemove.AddItem(default.TrackingShotMarkTargetEffectName);
	RemoveEffects.bApplyOnMiss = true;
	Template.AddTargetEffect(RemoveEffects);

	Template.CinescriptCameraType = "ChosenSniper_TrackingShot";
//BEGIN AUTOGENERATED CODE: Template Overrides 'TrackingShot'
	Template.bShowActivation = true;
	Template.bFrameEvenWhenUnitIsHidden = true;
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_trackingshot";
//END AUTOGENERATED CODE: Template Overrides 'TrackingShot'

	return Template;
}

static function X2DataTemplate CreateLethalDose()
{
	local X2AbilityTemplate Template;
	local X2AbilityCooldown Cooldown;
	local X2AbilityCost_ActionPoints ActionPointCost;
	local X2AbilityToHitCalc_RollStatTiers StatContestTiers;
	local X2Effect_Dazed DazedEffect;
	local X2Condition_UnitProperty UnitPropertyCondition;
	local array<name> SkipExclusions;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'LethalDose');

	Template.AbilitySourceName = 'eAbilitySource_Standard';
//BEGIN AUTOGENERATED CODE: Template Overrides 'LethalDose'
	Template.bShowActivation = true;
	Template.bFrameEvenWhenUnitIsHidden = true;
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_lethaldosage";
	Template.CustomFireAnim = 'FF_FireLethalDose';
//END AUTOGENERATED CODE: Template Overrides 'LethalDose'
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_AlwaysShow;
	Template.Hostility = eHostility_Offensive;

	// Cooldown
	Cooldown = new class'X2AbilityCooldown';
	Cooldown.iNumTurns = default.LETHALDOSE_COOLDOWN_NUM_TURNS;
	Template.AbilityCooldown = Cooldown;
	
	ActionPointCost = new class'X2AbilityCost_ActionPoints';
	ActionPointCost.iNumPoints = 1;
	ActionPointCost.bFreeCost = false;
	ActionPointCost.bConsumeAllPoints = true;
	Template.AbilityCosts.AddItem(ActionPointCost);

	Template.AbilityTargetStyle = default.SimpleSingleTarget;
	Template.AbilityTriggers.AddItem(default.PlayerInputTrigger);

	// This will be a stat contest
	StatContestTiers = new class'X2AbilityToHitCalc_RollStatTiers';
	StatContestTiers.StatToRoll = eStat_Will;
	StatContestTiers.AddNextStatContestTier(default.LETHALDOSE_STUN1_BASECHANCE);
	StatContestTiers.AddNextStatContestTier(default.LETHALDOSE_STUN2_BASECHANCE, false);
	Template.AbilityToHitCalc = StatContestTiers;

	// Shooter Conditions
	Template.AbilityShooterConditions.AddItem(default.LivingShooterProperty);

	SkipExclusions.AddItem(class'X2StatusEffects'.default.BurningName);
	SkipExclusions.AddItem(class'X2AbilityTemplateManager'.default.DisorientedName);
	Template.AddShooterEffectExclusions(SkipExclusions);

	// Target Conditions
	Template.AbilityTargetConditions.AddItem(default.LivingHostileUnitOnlyProperty);
	Template.AbilityTargetConditions.AddItem(default.GameplayVisibilityCondition);

	// Exclude Turrets. Also only consider targets that are eligible for Extract/Kidnap.
	UnitPropertyCondition = new class'X2Condition_UnitProperty';
	UnitPropertyCondition.ExcludeTurret = true;
	UnitPropertyCondition.ExcludeRobotic = true;
	UnitPropertyCondition.ExcludeAlien = true;
	UnitPropertyCondition.ExcludeFriendlyToSource = true;
	UnitPropertyCondition.FailOnNonUnits = true;
	UnitPropertyCondition.RequireUnitSelectedFromHQ = true;
	Template.AbilityTargetConditions.AddItem(UnitPropertyCondition);

	DazedEffect = class'X2StatusEffects_XPack'.static.CreateDazedStatusEffect(default.LETHALDOSE_DAZE1_TURNS, 100);
	DazedEffect.MinStatContestResult = 1;
	DazedEffect.MaxStatContestResult = 2;
	DazedEffect.bRemoveWhenSourceDies = true;
	Template.AddTargetEffect(DazedEffect);

	DazedEffect = class'X2StatusEffects_XPack'.static.CreateDazedStatusEffect(default.LETHALDOSE_DAZE2_TURNS, 100);
	DazedEffect.MinStatContestResult = 3;
	DazedEffect.MaxStatContestResult = 0;
	DazedEffect.bRemoveWhenSourceDies = true;
	Template.AddTargetEffect(DazedEffect);

	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = TypicalAbility_BuildVisualization;

	return Template;
}

static function RemoveChosenShooterConditions(out X2AbilityTemplate Template)
{
	local int i;
	local X2Condition_UnitEffects UnitEffects;

	for (i = 0; i < Template.AbilityShooterConditions.Length; ++i)
	{
		UnitEffects = X2Condition_UnitEffects(Template.AbilityShooterConditions[i]);

		if (UnitEffects != none)
		{
			UnitEffects.RemoveExcludeEffect(class'X2AbilityTemplateManager'.default.DisorientedName);
			UnitEffects.RemoveExcludeEffect(class'X2StatusEffects'.default.BurningName);
		}
	}
}

defaultproperties
{
	TrackingShotMarkSourceEffectName="TrackingShotMarkSourceEffect"
	TrackingShotMarkTargetEffectName ="TrackingShotMarkTargetEffect"
}
