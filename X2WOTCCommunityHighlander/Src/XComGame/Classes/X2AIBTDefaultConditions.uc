// Leaf node definitions for default conditions.
class X2AIBTDefaultConditions extends X2AIBTLeafNode
	native(AI);

enum eConditionValueType
{
	eBTCV_None,
	eBTCV_Stat,
	eBTCV_HitChance,
	eBTCV_PotentialHitChance,
	eBTCV_PopularSupport,
	eBTCV_AlertDataAge,
	eBTCV_AlertDataRadius,
	eBTCV_AlertDistance,
	eBTCV_AlertCount,
	eBTCV_AbilityTargetUnitCount,
	eBTCV_OverwatcherCount,
	eBTCV_SuppressorCount,
	eBTCV_TargetSetCount,
	eBTCV_Difficulty,
	eBTCV_CombatCount,
	eBTCV_TopHitChance, // Check against highest standard shot hit chance against all XCom targets.
	eBTCV_VisibleEnemies, // Checks visible living XCom units only.  Skips Turrets, cosmetic units, and incapacitated units.
	eBTCV_VisibleAllies, // Checks visible living allies only.  Skips Turrets, cosmetic units, and incapacitated units.
	eBTCV_BTVar, // local transient variable generated by behavior tree.
	eBTCV_UnitValue, // Persistent variable saved with the unit state.
	eBTCV_GroupSize,
	eBTCV_ObjectiveDistance, // Distance from objective along axis of play, in meters.
	eBTCV_TargetDistance,    // Distance from 'potential' Target, in meters.
	eBTCV_PriorityObjectAttackCount, // Number of times a priority object has been attacked.
	eBTCV_CiviliansKilled,	 // Number of civilians killed in this mission.  (Intended for Retaliation maps)
	eBTCV_TurnsEngaged,
	eBTCV_ActionPoints,
	eBTCV_PlayerTurnCount,
};

var delegate<BTConditionDelegate> m_dConditionFn;
var ECharStatType m_eStat;
var int m_iVal;
var bool m_bPercent;
var eConditionValueType m_eValType;
var delegate<StatCompareDelegate> m_dStatCompareFn;
var bool m_bApplyToTarget;

delegate bt_status BTConditionDelegate();       
delegate bool StatCompareDelegate(int A, int B);

const PSIOVERLOAD_ACTIVATION_RANGE = 28; // 28 tiles, ~= dash range + explode range.

native function SetApplyToTarget( );
protected function OnInit( int iObjectID, int iFrame )
{
	local int bIsPercent;
	super.OnInit(iObjectID, iFrame);

	// Fill out parameters based on ParamList strings
	if( FindBTStatConditionDelegate(m_ParamList, m_dConditionFn, m_dStatCompareFn, m_eStat, m_iVal, bIsPercent, m_eValType, SplitNameParam) )
	{
		if (bIsPercent != 0)
		{
			m_bPercent = true;
		}
	}
	else if (!FindBTConditionDelegate(m_strName, m_dConditionFn, SplitNameParam))
	{
		`WARN("X2AIBTDefaultConditions- No delegate condition defined for node"@m_strName);
	}
	// For nodes with ability names, check unit if ability exists and replace with an equivalent ability if needed.
	if( SplitNameParam != '' )
	{
		ResolveAbilityNameWithUnit(SplitNameParam, m_kBehavior);
	}
}

protected function bt_status Update()
{
	local bt_status eStatus;
	// Early exit if this has already been evaluated.
	if (m_eStatus == BTS_SUCCESS || m_eStatus == BTS_FAILURE)
		return m_eStatus;

	X2AIBTBehaviorTree(Outer).ActiveNode = self;

	if( m_dConditionFn != None )
	{
		eStatus = m_dConditionFn();
			return eStatus;
	}
	return BTS_FAILURE;
}

static function int GetIntFromParam( array<Name> ParamList, int iNum )
{
	local string strVal;
	local int nValue;
	if (iNum < ParamList.Length)
	{
		strVal = string(ParamList[iNum]);
		nValue = int(strVal);
	}
	return nValue;
}

static event bool FindBTStatConditionDelegate( array<Name> ParamList, optional out delegate<BTConditionDelegate> dOutFn, optional out delegate<StatCompareDelegate> dCmpFn, optional out ECharStatType eStat, optional out int nValue, optional out int bPercent, optional out eConditionValueType ValueType_out, optional out name NameParam)
{
	local string StatName, Operation, strVal;
	local int iPercentIdx;
	ValueType_out = eBTCV_None;
	if( ParamList.Length >= 3 )
	{
		StatName = string(ParamList[0]);
		Operation = string(ParamList[1]);
		strVal = string(ParamList[2]);
		if( StatName == "HitChance" )
		{
			ValueType_out = eBTCV_HitChance;
		}
		else if( ParseNameForNameAbilitySplit(Name(StatName), "PotentialHitChance-", NameParam) )
		{
			ValueType_out = eBTCV_PotentialHitChance;
		}
		else if( StatName == "TopHitChance" )
		{
			ValueType_out = eBTCV_TopHitChance;
		}
		else if( StatName == "BTVar" )
		{
			ValueType_out = eBTCV_BTVar;
		}
		else if( StatName == "VisibleEnemyCount" )
		{
			ValueType_out = eBTCV_VisibleEnemies;
		}
		else if( StatName == "VisibleAllyCount" )
		{
			ValueType_out = eBTCV_VisibleAllies;
		}
		else if( StatName == "PopularSupport" )
		{
			ValueType_out = eBTCV_PopularSupport;
		}
		else if (StatName == "AlertDataAge")
		{
			ValueType_out = eBTCV_AlertDataAge;
		}
		else if (StatName == "AlertDataRadius")
		{
			ValueType_out = eBTCV_AlertDataRadius;
		}
		// dkaplan: removed 3/23/15
		//else if (StatName == "AlertDataDistanceAtTimeOfAlert")
		//{
		//	ValueType_out = eBTCV_AlertDataDistanceAtTimeOfAlert;
		//}
		else if( StatName == "AlertDataDistance" )
		{
			ValueType_out = eBTCV_AlertDistance;
		}
		else if( StatName == "AlertDataCount" )
		{
			ValueType_out = eBTCV_AlertCount;
		}
		else if( StatName == "OverwatcherCount" )
		{
			ValueType_out = eBTCV_OverwatcherCount;
		}
		else if( StatName == "SuppressorCount" )
		{
			ValueType_out = eBTCV_SuppressorCount;
		}
		else if( StatName == "TargetSelectedThisTurnCount" )
		{
			ValueType_out = eBTCV_TargetSetCount;
		}
		else if( ParseNameForNameAbilitySplit(Name(StatName), "AbilityTargetUnitCount-", NameParam) )
		{
			ValueType_out = eBTCV_AbilityTargetUnitCount;
		}
		else if( StatName == "Difficulty" )
		{
			ValueType_out = eBTCV_Difficulty;
		}
		else if( StatName == "CombatCount" )
		{
			ValueType_out = eBTCV_CombatCount;
		}
		else if( StatName == "GroupSize" )
		{
			ValueType_out = eBTCV_GroupSize;
		}
		else if( StatName == "ObjectiveDistance" )
		{
			ValueType_out = eBTCV_ObjectiveDistance;
		}
		else if( StatName == "PotentialTargetDistance" )
		{
			ValueType_out = eBTCV_TargetDistance;
		}
		else if( StatName == "PriorityObjectAttackCount" )
		{
			ValueType_out = eBTCV_PriorityObjectAttackCount;
		}
		else if (StatName == "TurnsEngaged")
		{
			ValueType_out = eBTCV_TurnsEngaged;
		}
		else if (StatName == "ActionPoints")
		{
			ValueType_out = eBTCV_ActionPoints;
		}
		else if (StatName == "PlayerTurnCount")
		{
			ValueType_out = eBTCV_PlayerTurnCount;
		}
		else if( ParseNameForNameAbilitySplit(Name(StatName), "UnitValue-", NameParam) )
		{
			ValueType_out = eBTCV_UnitValue;
		}
		else
		{
			eStat = FindStatByName(StatName);

			if (eStat <= eStat_Invalid || eStat >= eStat_MAX)
			{
				`RedScreen("Invalid eStat:"$StatName);
				return false;
			}
			else
			{
				ValueType_out = eBTCV_Stat;
			}
		}

		switch (Operation)
		{
			case "=":
			case "==":
				dCmpFn=CheckStatEqual;
			break;
			case "!=":
				dCmpFn=CheckStatNotEqual;
			break;
			case ">":
				dCmpFn=CheckStatGreater;
			break;
			case ">=":
				dCmpFn=CheckStatGreaterOrEqual;
			break;
			case "<":
				dCmpFn=CheckStatLessThan;
			break;
			case "<=":
				dCmpFn=CheckStatLessThanOrEqual;
			break;
			default:
				`RedScreen("Invalid Operator:"$Operation);
				return false;
			break;
		}
		dOutFn = CheckStatCompare;
		iPercentIdx = InStr(strVal, "%");
		if( iPercentIdx != -1 )
		{
			bPercent = 1;
			strVal -= "%";
			nValue = int(strVal);
			if( nValue > 100 || nValue < 0 )
			{
				`RedScreen("Invalid percent value:"$strVal);
				return false;
			}
		}
		else
		{
			nValue = int(strVal);
			// sanity check
			if( nValue > 9999 || nValue < -9999 )
			{
				`RedScreen("Invalid value:"$strVal);
				return false;
			}
		}
		return true;
	}
	return false;
}

function int GetPlayerTurnCount()
{
	local XComGameState_Player ControllingPlayer;
	ControllingPlayer = XComGameState_Player(`XCOMHISTORY.GetGameStateForObjectID(m_kUnitState.ControllingPlayer.ObjectID));
	return ControllingPlayer.PlayerTurnCount;
}

static event bool FindBTConditionDelegate(name strName, optional out delegate<BTConditionDelegate> dOutFn, optional out Name NameParam)
{
	local Name PreHyphenString, PostHyphenString;

	dOutFn = None;

	if (FindBTDelegateByName(strName, dOutFn))
	{
		return true;
	}

	if (SplitNameAtHyphen(strName, PreHyphenString, PostHyphenString))
	{
		if (FindBTDelegateByName(PreHyphenString, dOutFn))
		{
			NameParam = PostHyphenString;
			return true;
		}
	}

	`WARN("Unresolved behavior tree condition name with no delegate definition:"@strName);
	return false;
}

function bt_status ShouldPrioritizeTheLostTarget()
{
	local XComGameState_Unit TargetState;
	// Prioritize the lost if we have no knowledge of any other enemy
	if (!m_kBehavior.HasKnowledgeOfXCom())
	{
		return BTS_SUCCESS;
	}
	if (m_kBehavior.BT_GetTarget(TargetState))
	{
		if (TargetState.GetTeam() == eTeam_TheLost)
		{
			if (class'XGAIPlayer_TheLost'.static.GetTargetTeamForLostUnit(TargetState) == m_kUnitState.GetTeam())
			{
				return BTS_SUCCESS;
			}
		}
	}
	return BTS_FAILURE;
}

function bt_status IsTargetTeam()
{
	local String TeamName;
	local XComGameState_Unit TargetState;
	if (m_kBehavior.BT_GetTarget(TargetState))
	{
		TeamName = String(XGUnit(TargetState.GetVisualizer()).GetTeam()); 
		if (TeamName ~= String(SplitNameParam))
		{
			return BTS_SUCCESS;
		}
		`LogAIBT("Failed.  Team="$TeamName@", != "@SplitNameParam);
	}
	else
	{
		`LogAIBT("Target failed due to no target state found.");
	}
	return BTS_FAILURE;
}
function bt_status NotVisibleToTeamXCom()
{
	if (!class'X2TacticalVisibilityHelpers'.static.CanXComSquadSeeTarget(m_kUnitState.ObjectID))
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status HasLostGroupScampered()
{
	if( m_kBehavior.bLostScampered )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status BBHasKey()
{
	local XComGameState_AIBlackboard Blackboard;
	local int Value;
	Blackboard = XComGameState_AIBlackboard(`XCOMHISTORY.GetSingleGameStateObjectForClass(class'XComGameState_AIBlackboard'));
	if( Blackboard != None )
	{
		Value = Blackboard.GetKeyValue(String(SplitNameParam));
		if( Value != INDEX_NONE )
		{
			return BTS_SUCCESS;
		}
	}
	return BTS_FAILURE;
}

function bt_status BBDataMatchesTargetID()
{
	local XComGameState_AIBlackboard Blackboard;
	local int Value;
	Blackboard = XComGameState_AIBlackboard(`XCOMHISTORY.GetSingleGameStateObjectForClass(class'XComGameState_AIBlackboard'));
	if( Blackboard != None && m_kBehavior.m_kBTCurrTarget.TargetID > 0 )
	{
		Value = Blackboard.GetKeyValue(String(SplitNameParam));
		if( Value == m_kBehavior.m_kBTCurrTarget.TargetID )
		{
			return BTS_SUCCESS;
		}
	}
	return BTS_FAILURE;
}

function bt_status IsObjectiveActive()
{
	local array<XComGameState_ObjectiveInfo> Objectives;
	local XComGameState_ObjectiveInfo Objective;
	local X2AutoPlayManager AutoPlayMgr;
	AutoPlayMgr = `AUTOPLAYMGR;
	AutoPlayMgr.GetObjectivesList(Objectives);
	foreach Objectives(Objective)
	{
		`LogAIBT("Active Objective: "$Objective.MissionType);
		if( String(SplitNameParam) ~= Objective.MissionType )
		{
			`LogAIBT("Found objective! SUCCESS."$Objective.MissionType);
			return BTS_SUCCESS;
		}
	}
	return BTS_FAILURE;
}

function bt_status NoVisibleEnemiesToTeam()
{
	local array<StateObjectReference> VisibleUnits;
	class'X2TacticalVisibilityHelpers'.static.GetAllVisibleEnemiesForPlayer(m_kUnitState.ControllingPlayer.ObjectID, VisibleUnits);
	if( VisibleUnits.Length > 0 )
	{
		return BTS_FAILURE;
	}
	return BTS_SUCCESS;

}

// Basically check the target conditions like the Ability Template does, fail if any of the conditions fail that aren't in our exceptions (Param) list.
function bt_status TargetValidForAbility()
{
	local XComGameState_Unit TargetState;
	local XComGameState_Ability AbilityState;
	local X2AbilityTemplate AbilityTemplate;
	local X2Condition Condition;
	local Name AvailableCode;
	if( m_kBehavior.BT_GetTarget(TargetState) )
	{
		m_kBehavior.FindAbilityByName(SplitNameParam, AbilityState);
		if( AbilityState != None )
		{
			AbilityTemplate = AbilityState.GetMyTemplate();
			foreach AbilityTemplate.AbilityTargetConditions(Condition)
			{
				AvailableCode = Condition.MeetsCondition(TargetState);
				if( AvailableCode != 'AA_Success' )
				{
					// Check exception list from BT node.  (ParamList)
					if( m_ParamList.Find(AvailableCode) == INDEX_NONE )
					{
						`LogAIBT("Target failed due to error code:"@AvailableCode);
						return BTS_FAILURE;
					}
				}
				AvailableCode = Condition.MeetsConditionWithSource(TargetState, m_kUnitState);
				if( AvailableCode != 'AA_Success' )
				{
					// Check exception list from BT node.  (ParamList)
					if( m_ParamList.Find(AvailableCode) == INDEX_NONE )
					{
						`LogAIBT("Target failed due to error code:"@AvailableCode);
						return BTS_FAILURE;
					}
				}

				AvailableCode = Condition.AbilityMeetsCondition(AbilityState, TargetState);
				if( AvailableCode != 'AA_Success' )
				{
					// Check exception list from BT node.  (ParamList)
					if( m_ParamList.Find(AvailableCode) == INDEX_NONE )
					{
						`LogAIBT("Target failed due to error code:"@AvailableCode);
						return BTS_FAILURE;
					}
				}
			}
			return BTS_SUCCESS;
		}
		`LogAIBT("Target failed due to no ability state found.");
	}
	`LogAIBT("Target failed due to no target state found.");
	return BTS_FAILURE;
}

function bt_status HasBindableNeighborTile()
{
	if( class'X2Effect_GetOverHere'.static.HasBindableNeighborTile(m_kUnitState) )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status IsTargetScamperInstigator()
{
	local XComGameState_AIGroup Group;
	Group = m_kUnitState.GetGroupMembership();
	if( Group != None
	   && m_kBehavior.m_kBTCurrTarget.TargetID > 0
	   && m_kBehavior.m_kBTCurrTarget.TargetID == Group.RevealInstigatorUnitObjectID )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status WasTargetPreviouslyConcealed()
{
	local XComGameState_AIGroup Group;
	Group = m_kUnitState.GetGroupMembership();
	if( Group != None
	   && m_kBehavior.m_kBTCurrTarget.TargetID > 0
	   && Group.PreviouslyConcealedUnitObjectIDs.Find(m_kBehavior.m_kBTCurrTarget.TargetID) != INDEX_NONE )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status HasHitAttackLimit()
{
	local int AttackLimit, NumAttackingUnits;
	local XComGameState_AIPlayerData AIData;
	local XGAIPlayer AIPlayer;
	AIData = m_kBehavior.GetAIPlayerData();
	if( AIData != None && AIData.m_iPlayerObjectID == m_kUnitState.ControllingPlayer.ObjectID)
	{
		AttackLimit = `ScaleTacticalArrayInt(AIData.MaxEngagedEnemies);
		if( AttackLimit > 0 )
		{
			AIPlayer = XGAIPlayer(`BATTLE.GetAIPlayer());
			if( AIPlayer != None)
			{
				NumAttackingUnits = AIPlayer.GetNumAggressiveUnitsThisTurn();
				`LogAIBT(`ShowVar(NumAttackingUnits)$", "@`ShowVar(AttackLimit));
				if( NumAttackingUnits >= AttackLimit )
				{
					return BTS_SUCCESS;
				}
			}
		}
		// Attack limit is negative.  Unlimited attacks!
		return BTS_FAILURE;
	}
	`LogAIBT("Error - No AIPlayerData game state found!");
	return BTS_FAILURE;
}

// Roll - Chance per visible Ally is in Param[0].
function bt_status RollForSuppressionPerVisibleAlly()
{
	local int ChancePerAlly;
	local String ChanceString;
	local int Roll, TotalChance, NumVisibleAllies;

	if( m_ParamList.Length == 1 )
	{
		ChanceString = String(m_ParamList[0]);
		ChancePerAlly = int(ChanceString);
		if( ChancePerAlly < 0 || ChancePerAlly > 100 )
		{
			`LogAIBT("RollForSuppressionPerVisibleAlly failure - Param[0] entered for chance value per visible ally is invalid!"@`ShowVar(ChancePerAlly));
			return BTS_FAILURE;
		}
		NumVisibleAllies = m_kBehavior.BT_GetVisibleAllyCount();
		TotalChance = ChancePerAlly * NumVisibleAllies;
		Roll = `SYNC_RAND(100);
		`LogAIBT("RollForSuppressionPerVisibleAlly rolled a "$Roll$".  TotalChance = ("@NumVisibleAllies@"x"@ChancePerAlly@") ="@TotalChance);
		if( Roll < TotalChance )
		{
			`LogAIBT(" Roll Result: SUCCESS! ");
			return BTS_SUCCESS;
		}
		`LogAIBT(" Roll Result: FAILURE! ");
	}
	else
	{
		`LogAIBT("RollForSuppressionPerVisibleAlly failure - No Param[0] entered for chance value per visible ally!");
	}
	return BTS_FAILURE;
}

function bt_status SecondWaveOptionEnabled()
{
	if (`SecondWaveEnabled(SplitNameParam))
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status NumKilledCiviliansIsLessThanTurnCount()
{
	local int NumKilledCivilians, TurnCount;
	NumKilledCivilians = class'Helpers'.static.GetNumCiviliansKilled();
	TurnCount = GetPlayerTurnCount();

	// Cut the kill rate in half if the Second Wave option BetaStrike is enabled.
	if (`SecondWaveEnabled('BetaStrike'))
	{
		TurnCount /= 2;
	}
	`LogAIBT(`ShowVar(NumKilledCivilians)@`ShowVar(TurnCount));
	if( NumKilledCivilians < TurnCount )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status HasNonLastResortEnemies()
{
	if( m_kBehavior.m_kPlayer != None )
	{
		if( m_kBehavior.m_kPlayer.HasNonLastResortEnemies() )
		{
			return BTS_SUCCESS;
		}
	}
	else
	{
		`LogAIBT("IsLastResortTarget failure - AIPlayer not found for unit: "$m_kUnitState.ObjectID);
	}
	return BTS_FAILURE;
}

function bt_status IsTargetValidBasedOnLastResortEffects()
{
	local XComGameState_Unit CurrTarget;
	if( m_kBehavior.m_kPlayer != None )
	{
		if (m_kBehavior.BT_GetTarget(CurrTarget)) // Get current target or curr alert target.
		{
			if( m_kBehavior.m_kPlayer.IsLastResortTarget(CurrTarget.ObjectID) )
			{
				return BTS_SUCCESS;
			}
		}
		else
		{
			`LogAIBT("IsTargetValidBasedOnLastResortEffects failure - No current target or curr alert data active!  Unit# "$m_kUnitState.ObjectID);
		}
	}
	else
	{
		`LogAIBT("IsTargetValidBasedOnLastResortEffects failure - AIPlayer not found for unit: "$m_kUnitState.ObjectID);
	}
	return BTS_FAILURE;
}

function bt_status IsLastResortTarget()
{
	local XComGameState_Unit CurrTarget;
	if( m_kBehavior.m_kPlayer != None )
	{
		if (m_kBehavior.BT_GetTarget(CurrTarget)) // Get current target or curr alert target.
		{
			if( m_kBehavior.m_kPlayer.IsLastResortTarget(CurrTarget.ObjectID) )
			{
				return BTS_SUCCESS;
			}
		}
		else
		{
			`LogAIBT("IsLastResortTarget failure - No current target or curr alert data active!  Unit# "$m_kUnitState.ObjectID);
		}
	}
	else
	{
		`LogAIBT("IsLastResortTarget failure - AIPlayer not found for unit: "$m_kUnitState.ObjectID);
	}
	return BTS_FAILURE;
}

function bt_status IsSelectedAbility()
{
	if( m_kBehavior.m_strBTAbilitySelection == SplitNameParam )
	{
		return BTS_SUCCESS;
	}
	`LogAIBT("Selected Ability = "$m_kBehavior.m_strBTAbilitySelection);
	return BTS_FAILURE;
}

// Visible to both players, in move range to unit.
function bt_status HasVisibleCivilianInMoveRange()
{
	local array<StateObjectReference> VisibleCivilians;
	local StateObjectReference CivRef;
	local int EnemyPlayerID;
	local X2GameRulesetVisibilityManager VisibilityMgr;
	local GameRulesCache_VisibilityInfo VisInfo;
	local float MaxDistSq;

	class'X2TacticalVisibilityHelpers'.static.GetAllVisibleUnitsOnTeamForSource(m_kUnitState.ObjectID, eTeam_Neutral, VisibleCivilians);
	if( VisibleCivilians.Length > 0 && m_kBehavior.m_kPlayer != None)
	{
		VisibilityMgr = `TACTICALRULES.VisibilityMgr;
		EnemyPlayerID = `BATTLE.GetEnemyPlayer(m_kBehavior.m_kPlayer).ObjectID;
		MaxDistSq = `METERSTOUNITS(m_kUnitState.GetCurrentStat(eStat_Mobility));
		MaxDistSq = Square(MaxDistSq);
		foreach VisibleCivilians(CivRef)
		{
			// Check visible to other team.
			if( class'X2TacticalVisibilityHelpers'.static.GetTargetIDVisibleForPlayer(CivRef.ObjectID, EnemyPlayerID) )
			{
				// Check if in movement range.
				if( VisibilityMgr.GetVisibilityInfo(m_kUnitState.ObjectID, CivRef.ObjectID, VisInfo) )
				{
					if( VisInfo.DefaultTargetDist <= MaxDistSq )
					{
						return BTS_SUCCESS;
					}
				}
			}
		}
	}
	return BTS_FAILURE;
}

function bt_status HasXComUnitsCloserToObjective()
{
	local float FuzzDist;
	local String FuzzDistString;
	if( m_ParamList.Length == 1 )
	{
		FuzzDistString = String(m_ParamList[0]);
		FuzzDist = float(FuzzDistString);
	}
	if( m_kBehavior.HasXComUnitsCloserToObjective(FuzzDist) )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}
function bt_status IsTargetInTwoTurnAttackArea()
{
	if( m_kBehavior.m_kPlayer != None && m_kBehavior.m_kPlayer.TwoTurnAttackTargets.Length > 0 )
	{
		if( m_kBehavior.m_kPlayer.TwoTurnAttackTargets.Find('ObjectID', m_kUnitState.ObjectID) != INDEX_NONE )
		{
			return BTS_SUCCESS;
		}
	}
	return BTS_FAILURE;
}

function bt_status HasTwoTurnAttackTargets()
{
	local StateObjectReference TargetRef;
	local X2GameRulesetVisibilityManager VisibilityMgr;
	local GameRulesCache_VisibilityInfo VisInfo;
	local float MaxDistSq;

	if( m_kBehavior.m_kPlayer != None && m_kBehavior.m_kPlayer.TwoTurnAttackTargets.Length > 0 )
	{
		VisibilityMgr = `TACTICALRULES.VisibilityMgr;
		MaxDistSq = `METERSTOUNITS(m_kUnitState.GetVisibilityRadius());
		MaxDistSq = Square(MaxDistSq);
		// Return success iff targets are within sight range distance. 
		foreach m_kBehavior.m_kPlayer.TwoTurnAttackTargets(TargetRef)
		{
			if( VisibilityMgr.GetVisibilityInfo( m_kUnitState.ObjectID, TargetRef.ObjectID, VisInfo ) )
			{
				if( VisInfo.DefaultTargetDist <= MaxDistSq )
				{
					return BTS_SUCCESS;
				}
			}
		}
	}
	return BTS_FAILURE;
}

function bt_status HasUnitValue()
{
	local UnitValue Val;
	if( m_kUnitState.GetUnitValue(SplitNameParam, Val) )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status IsTeam()
{
	local String TeamName;
	TeamName = String(XGUnit(m_kUnitState.GetVisualizer()).GetTeam()); // Using XGUnit since the UnitState version returns a byte instead of an eTeam.
	if( TeamName ~= String(SplitNameParam) )
	{
		return BTS_SUCCESS;
	}
	`LogAIBT("Failed.  Team="$TeamName@", !="@SplitNameParam);
	return BTS_FAILURE;
}

function bt_status IsActiveTeam()
{
	local String TeamName;
	local XComGameState_Player PlayerState;
	local X2TacticalGameRuleset RuleSet;
	local XComGameStateHistory History;

	RuleSet = `TACTICALRULES;
	History = `XCOMHISTORY;

	PlayerState = XComGameState_Player(History.GetGameStateForObjectID(RuleSet.GetCachedUnitActionPlayerRef().ObjectID));
	
	TeamName = String(PlayerState.GetTeam());
	if( TeamName ~= String(SplitNameParam) )
	{
		return BTS_SUCCESS;
	}
	`LogAIBT("Failed.  Team="$TeamName@", !="@SplitNameParam);
	return BTS_FAILURE;
}

function bt_status HasUnconcealedEnemies()
{
	local XComGameState_Unit Unit;
	local XGPlayer EnemyPlayer;
	local array<XComGameState_Unit> AllEnemies;

	EnemyPlayer = `BATTLE.GetEnemyPlayer(m_kBehavior.m_kPlayer);
	if( EnemyPlayer != None )
	{
		EnemyPlayer.GetUnits(AllEnemies);
		foreach AllEnemies(Unit)
		{
			if( !Unit.IsConcealed() && !Unit.bRemovedFromPlay )
			{
				return BTS_SUCCESS;
			}
		}
	}
	else
	{
		`LogAIBT("Failed to find enemy player!  m_kBehavior.m_kPlayer == None?");
	}
	return BTS_FAILURE;
}

function bt_status IsInMovementRangeOfAxisOfPlay()
{
	local vector ClosestPointOnAxis;
	local TTile ClosestTileToAxis;
	if( m_kBehavior.m_kPlayer != None && m_kBehavior.m_kPlayer.m_kNav != None )
	{
		ClosestPointOnAxis = m_kBehavior.m_kPlayer.m_kNav.GetNearestPointOnAxisOfPlay(m_kBehavior.GetGameStateLocation(), true);
		ClosestTileToAxis = `XWORLD.GetTileCoordinatesFromPosition(ClosestPointOnAxis);
		if( m_kBehavior.IsWithinMovementRange(ClosestTileToAxis) )
		{
			return BTS_SUCCESS;
		}
		else
		{
			`LogAIBT("Failed IsWithinMovementRange check.");
		}
	}
	else
	{
		`LogAIBT("Failed due to no player or nav object defined on unit.");
	}
	return BTS_FAILURE;
}

function bt_status HasEncounterBandBeenPassed()
{
	local XComGameState_AIGroup Group;
	Group = m_kUnitState.GetGroupMembership();
	if( Group != None )
	{
		if( Group.XComSquadMidpointPassedGroup() )
		{
			return BTS_SUCCESS;
		}
	}
	else
	{
		`LogAIBT("Failed check HasEncounterBandBeenPassed due to no group found!");
	}
	return BTS_FAILURE;
}

function bt_status AreAllRemainingAlliesUnderEffect()
{
	local XComGameState_Unit Ally;
	local array<XComGameState_Unit> Allies;
	if( m_kBehavior.m_kPlayer != None )
	{
		m_kBehavior.m_kPlayer.GetPlayableUnits(Allies, true);
		foreach Allies(Ally)
		{
			if( !Ally.IsUnitAffectedByEffectName(SplitNameParam) )
			{
				`LogAIBT("Failed due to Unit#"$Ally.ObjectID@" not under effect:"$SplitNameParam@"\n");
				return BTS_FAILURE;
			}
		}
		`LogAIBT("Passed: all "$Allies.Length@" Allies under effect:"$SplitNameParam@"\n");
		return BTS_SUCCESS;
	}
	else
	{
		`LogAIBT("Failed due to no valid m_kBehavior.m_kPlayer object.");
	}
	return BTS_FAILURE;
}

function bt_status IsLastRemainingGroup()
{
	local XComGameState_Unit Ally;
	local array<XComGameState_Unit> Allies;
	local XComGameState_AIGroup MyGroup;
	MyGroup = m_kUnitState.GetGroupMembership();
	if( MyGroup != None )
	{
		if( m_kBehavior.m_kPlayer != None )
		{
			m_kBehavior.m_kPlayer.GetPlayableUnits(Allies, true);
			foreach Allies(Ally)
			{
				if( Ally.GetGroupMembership().ObjectID != MyGroup.ObjectID )
				{
					`LogAIBT("Failed due to Unit#"$Ally.ObjectID@" not in group.\n");
					return BTS_FAILURE;
				}
			}
			`LogAIBT("Passed: all "$Allies.Length@" Allies are on group :"$MyGroup.ObjectID@"\n");
			return BTS_SUCCESS;
		}
		else
		{
			`LogAIBT("Failed due to no valid m_kBehavior.m_kPlayer object.");
		}
	}
	else
	{
		`LogAIBT("Failed due to no valid XGAIGroup object.");
	}
	return BTS_FAILURE;
}
function bt_status IsTargetClosestOfType()
{
	local array<XComGameState_Unit> VisibleTypeUnits;
	local XComWorldData World;
	local vector MyLocation;
	local XComGameState_Unit CurrTargetState, Enemy;
	local float DistSq, CurrTargetDistSq;
	World = `XWORLD;

	// Get all visible enemies of type.
	HasUnitsVisibleOfType(SplitNameParam, -1, VisibleTypeUnits);
	if( VisibleTypeUnits.Length > 1 )
	{
		MyLocation = m_kBehavior.GetGameStateLocation();
		if (m_kBehavior.BT_GetTarget(CurrTargetState))
		{

			CurrTargetDistSq = VSizeSq(World.GetPositionFromTileCoordinates(CurrTargetState.TileLocation) - MyLocation);
			foreach VisibleTypeUnits(Enemy)
			{
				if( Enemy.ObjectID == CurrTargetState.ObjectID )
				{
					continue;
				}
				DistSq = VSizeSq(World.GetPositionFromTileCoordinates(Enemy.TileLocation) - MyLocation);
				if( DistSq < CurrTargetDistSq )
				{
					`LogAIBT("Found Unit# "@Enemy.ObjectID@"closer to this unit than Unit#"@CurrTargetState.ObjectID@"\n");
					return BTS_FAILURE;
				}
			}
		}
		else
		{
			`LogAIBT("IsTargetClosestOfType failure - No current target or curr alert data active!  Unit# "$m_kUnitState.ObjectID);
		}
	}
	else
	{
		`LogAIBT("Returning SUCCESS only because there are not more than 1 visible enemy of type"@SplitNameParam@"\n");
	}
	return BTS_SUCCESS;
}
function bt_status MultipleUnitsVisibleOfType()
{
	return HasUnitsVisibleOfType(SplitNameParam, 2);
}

function bt_status IsUnitTypeVisible()
{
	return HasUnitsVisibleOfType(SplitNameParam, 1);
}

function bt_status HasUnitsVisibleOfType(Name CharacterType, int MinCount, optional out array<XComGameState_Unit> VisibleTypeUnits, optional array<X2Condition> RequiredConditions=class'X2TacticalVisibilityHelpers'.default.LivingLOSVisibleFilter)
{
	local array<StateObjectReference> VisibleUnits;
	local XComGameState_Unit VisibleUnitState;
	local StateObjectReference UnitRef;
	local XComGameStateHistory History;
	local int Count;
	History = `XCOMHISTORY;
	class'X2TacticalVisibilityHelpers'.static.GetAllVisibleEnemyUnitsForUnit(m_kUnitState.ObjectID, VisibleUnits, RequiredConditions);
	foreach VisibleUnits(UnitRef)
	{
		VisibleUnitState = XComGameState_Unit(History.GetGameStateForObjectID(UnitRef.ObjectID));
		if( VisibleUnitState.GetMyTemplateName() == CharacterType && !VisibleUnitState.bRemovedFromPlay )
		{
			Count++;
			VisibleTypeUnits.AddItem(VisibleUnitState);
			if( MinCount > 0 && Count >= MinCount )
			{
				return BTS_SUCCESS;
			}
		}
	}
	return BTS_FAILURE;
}

// Function used to check if grenade ability can cause damage- and prevent smoke grenade usage for mind-controlled.
function bt_status DoesGrenadeCauseDamage()
{
	local XComGameState_Ability AbilityState;
	local StateObjectReference TargetRef;
	local WeaponDamageValue MinDamage, MaxDamage;
	local int AllowsShields;

	m_kBehavior.FindAbilityByName('ThrowGrenade', AbilityState);
	if( AbilityState != None )
	{
		AbilityState.GetDamagePreview(TargetRef, MinDamage, MaxDamage, AllowsShields);
		if( MinDamage.Damage > 0 )
		{
			return BTS_SUCCESS;
		}
		else
		{
			`LogAIBT("DoesGrenadeCauseDamage MinDamage = "$MinDamage.Damage@" . MaxDamage = "$MaxDamage.Damage);
		}
	}
	else
	{
		`LogAIBT("DoesGrenadeCauseDamage failed due to no ThrowGrenade ability found.");
	}
	return BTS_FAILURE;
}


function bt_status TargetCanBecomeZombie()
{
	if( m_kBehavior.BT_TargetCanBecomeZombie() )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status HasLivingEnemiesWithoutEffects()
{
	if( m_kBehavior.BT_GetLivingEnemiesWithoutEffects(m_ParamList,,true) )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status IsGroupLeader()
{
	if( m_kUnitState.IsGroupLeader() )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status HasRevealed()
{
	if (m_kUnitState.IsUnrevealedAI()) // If true, this unit has not yet triggered its reveal.
	{
		return BTS_FAILURE;
	}
	return BTS_SUCCESS;
}

function bt_status TargetHasRevealed()
{
	local XComGameState_Unit TargetState;
	if (m_kBehavior.BT_GetTarget(TargetState))
	{ 
		if (!TargetState.IsUnrevealedAI()) // If true, this unit has not yet triggered its reveal.
		{
			return BTS_SUCCESS;
		}
	}
	return BTS_FAILURE;
}

function bt_status HasUnengagedJob()
{
	local XComGameState_AIUnitData AIUnitData;
	local Name JobName;
	local X2AIJobManager JobMgr;
	local int DataID;
	DataID = m_kBehavior.GetAIUnitDataID(m_kUnitState.ObjectID);
	if ( DataID > 0 )
	{
		AIUnitData = XComGameState_AIUnitData(`XCOMHISTORY.GetGameStateForObjectID(DataID));
		if (AIUnitData.JobIndex == INDEX_NONE)
		{
			return BTS_FAILURE;
		}
		JobMgr = `AIJOBMGR;
			JobName = JobMgr.GetJobName(AIUnitData.JobIndex);
		if (JobMgr.GetJobListing(JobName).bRequiresEngagement == false)
		{
			return BTS_SUCCESS;
		}
	}
	return BTS_FAILURE;
}

function bt_status HasJob()
{
	local XComGameState_AIUnitData AIUnitData;
	local int DataID;
	DataID = m_kBehavior.GetAIUnitDataID(m_kUnitState.ObjectID);
	if (DataID > 0)
	{
		AIUnitData = XComGameState_AIUnitData(`XCOMHISTORY.GetGameStateForObjectID(DataID));
		if (AIUnitData.JobIndex != INDEX_NONE)
		{
			return BTS_SUCCESS;
		}
	}
	return BTS_FAILURE;
}

function bt_status IsMyJob()
{
	local XComGameState_AIUnitData AIUnitData;
	local int DataID;
	DataID = m_kBehavior.GetAIUnitDataID(m_kUnitState.ObjectID);
	if (DataID > 0)
	{
		AIUnitData = XComGameState_AIUnitData(`XCOMHISTORY.GetGameStateForObjectID(DataID));
		if (AIUnitData.JobIndex != INDEX_NONE && `AIJOBMGR.GetJobIndex(SplitNameParam) == AIUnitData.JobIndex)
		{
			return BTS_SUCCESS;
		}
	}
	return BTS_FAILURE;
}


function bt_status HasPriorityTargetUnit()
{
	local XComGameState_AIPlayerData kAIData;
	kAIData = m_kBehavior.GetAIPlayerData();
	if (kAIData != None)
	{
		if (kAIData.HasPriorityTargetUnit())
		{
			return BTS_SUCCESS;
		}
	}
	return BTS_FAILURE;
}
function bt_status HasPriorityTargetObject()
{
	local XComGameState_AIPlayerData kAIData;
	kAIData = m_kBehavior.GetAIPlayerData();
	if (kAIData != None)
	{
		if (kAIData.HasPriorityTargetObject())
		{
			return BTS_SUCCESS;
		}
	}
	return BTS_FAILURE;
}
function bt_status TargetIsPriorityUnit()
{
	local XComGameState_AIPlayerData kAIData;
	local XComGameState_Unit kPriorityTarget;

	if( m_kBehavior.m_kBTCurrTarget.TargetID == m_kBehavior.PriorityTarget.ObjectID )
	{
		return BTS_SUCCESS;
	}

	kAIData = m_kBehavior.GetAIPlayerData();
	if( kAIData != None )
	{
		if( kAIData.HasPriorityTargetUnit(kPriorityTarget) )
		{
			if( kPriorityTarget.ObjectID > 0
			   && m_kBehavior.m_kBTCurrTarget.TargetID == kPriorityTarget.ObjectID )
			{
				return BTS_SUCCESS;
			}
		}
	}
	return BTS_FAILURE;
}

function bt_status TargetIsPriorityObject()
{
	local XComGameState_AIPlayerData kAIData;
	local XComGameState_InteractiveObject kPriorityTarget;

	if( m_kBehavior.m_kBTCurrTarget.TargetID == m_kBehavior.PriorityTarget.ObjectID )
	{
		return BTS_SUCCESS;
	}

	kAIData = m_kBehavior.GetAIPlayerData();
	if( kAIData != None )
	{
		if( kAIData.HasPriorityTargetObject(kPriorityTarget) )
		{
			if( kPriorityTarget.ObjectID > 0
			   && m_kBehavior.m_kBTCurrTarget.TargetID == kPriorityTarget.ObjectID )
			{
				return BTS_SUCCESS;
			}
		}
	}
	return BTS_FAILURE;
}

function bt_status EvacWithinVisRange()
{
	local XComGameState_EvacZone EvacZone;
	local float SightRadiusUnitsSq, DistToEvacSq;
	local vector EvacZoneCenter, UnitLoc;

	EvacZone = class'XComGameState_EvacZone'.static.GetEvacZone(eTeam_XCom);
	if( EvacZone != None )
	{
		EvacZoneCenter = `XWORLD.GetPositionFromTileCoordinates(EvacZone.CenterLocation);
		UnitLoc = `XWORLD.GetPositionFromTileCoordinates(m_kUnitState.TileLocation);
		DistToEvacSq = VSizeSq(UnitLoc - EvacZoneCenter);

		SightRadiusUnitsSq = `METERSTOUNITS(m_kUnitState.GetVisibilityRadius());
		SightRadiusUnitsSq = SightRadiusUnitsSq * SightRadiusUnitsSq;
		if( DistToEvacSq <= SightRadiusUnitsSq )
		{
			return BTS_SUCCESS;
		}
		`LogAIBT(GetFuncName()@"failed - Evac Zone found, but outside of sight radius.");
	}
	else
	{
		`LogAIBT(GetFuncName()@"failed - No Evac Zone found.");
	}
	return BTS_FAILURE;
}

function bt_status HasEnemyVIP()
{
	local XComGameState_AIPlayerData kAIData;
	kAIData = m_kBehavior.GetAIPlayerData();
	if( kAIData != None && kAIData.m_iPlayerObjectID == m_kUnitState.ControllingPlayer.ObjectID && kAIData.HasEnemyVIP() )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status TargetIsEnemyVIP()
{
	local XComGameState_AIPlayerData AIData;
	local XComGameState_Unit VIP;

	AIData = m_kBehavior.GetAIPlayerData();
	if( AIData != None && AIData.m_iPlayerObjectID == m_kUnitState.ControllingPlayer.ObjectID && AIData.HasEnemyVIP(VIP) && VIP.ObjectID == m_kBehavior.m_kBTCurrTarget.TargetID )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status CanSeeLivingVIPOrCarriedVIP()
{
	local XComGameState_AIPlayerData kAIData;
	local XComGameState_Unit VIP;
	local array<StateObjectReference> EnemyViewers;
	kAIData = m_kBehavior.GetAIPlayerData();
	if( kAIData != None && kAIData.m_iPlayerObjectID == m_kUnitState.ControllingPlayer.ObjectID)
	{
		if( kAIData.HasEnemyVIP(VIP) )
		{
			if( VIP.IsAlive() || VIP.IsUnitAffectedByEffectName(class'X2Ability_CarryUnit'.default.CarryUnitEffectName) )
			{
				class'X2TacticalVisibilityHelpers'.static.GetEnemyViewersOfTarget(VIP.ObjectID, EnemyViewers);
				if( (EnemyViewers.Find('ObjectID', m_kUnitState.ObjectID) != INDEX_NONE)
					|| class'X2TacticalVisibilityHelpers'.static.CanUnitSeeLocation(m_kUnitState.ObjectID, VIP.TileLocation) )
				{
					return BTS_SUCCESS;
				}
				`LogAIBT(GetFuncName()@"failure: VIP exists, and is alive or carried, but not visible to this unit.");
			}
			else
			{
				`LogAIBT(GetFuncName()@"failure: VIP exists, but is dead, and not being carried.");
			}
		}
		else
		{
			`LogAIBT(GetFuncName()@"failure: No priority target unit exists.");
		}
	}
	else
	{
		`LogAIBT(GetFuncName()@"failure: m_kBehavior.GetAIPlayerData() returned None.");
	}
	return BTS_FAILURE;
}

function bt_status TargetIsCivilian()
{
	if( m_kBehavior.BT_TargetIsCivilian() )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status TargetIsAlly()
{
	local XComGameState_Unit Target;
	if( m_kBehavior.BT_GetTarget(Target) && m_kUnitState.IsFriendlyUnit(Target) )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status TargetIsEnemy()
{
	local XComGameState_Unit Target;
	if( m_kBehavior.BT_GetTarget(Target) && m_kUnitState.IsEnemyUnit(Target) )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status TargetIsChosen()
{
	local XComGameState_Unit Target;
	if (m_kBehavior.BT_GetTarget(Target) && Target.IsChosen())
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status TargetIsEngagedChosen()
{
	local XComGameState_Unit Target;
	if (m_kBehavior.BT_GetTarget(Target) && Target.IsEngagedChosen())
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}


function bt_status TargetIsNotAttackable()
{
	local XComGameState_Unit Target;
	if( m_kBehavior.BT_GetTarget(Target) ) // This pulls the alert target if there is no current target stack .
	{
		if( Target != None )
		{
			if( !Target.IsAlive() || Target.IsIncapacitated() || Target.bRemovedFromPlay || Target.GetMyTemplate().bIsCosmetic )
			{
				return BTS_SUCCESS;
			}
		}
	}
	else
	{
		`LogAIBT("TargetIsNotAttackable failure - No current target or curr alert data active!  Unit# "$m_kUnitState.ObjectID);
	}
	return BTS_FAILURE;
}

function bt_status TargetIsClosestValidTarget()
{
	if( m_kBehavior.BT_TargetIsClosestValidTarget() )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status TargetHasHighestSoldierRank()
{
	if (m_kBehavior.BT_TargetHasHighestSoldierRank())
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}
function bt_status TargetHasHighestTeamVisibility()
{
	if (m_kBehavior.BT_TargetHasHighestTeamVisibility())
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}
function bt_status TargetHasHighestShotHitChance()
{
	if (m_kBehavior.BT_TargetHasHighestShotHitChance())
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status WasLastAbility()
{
	if (m_kBehavior.BT_GetLastAbilityName() ~= string(SplitNameParam))
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status IsCallReinforcementsTriggered()
{
	local XComGameState_AIReinforcementSpawner AISPawnerState;
	local XComGameStateHistory History;

	History = `XCOMHISTORY;

	foreach History.IterateByClassType(class'XComGameState_AIReinforcementSpawner', AISPawnerState)
	{
		break;
	}

	// true if there are any active reinforcement spawners
	if( AISPawnerState != None )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status LowPopSupport()
{
	if (XGBattle_SP(`BATTLE).IsLowPopularSupport())
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status IsVisibleToPlayer()
{
	if (m_kBehavior.BT_IsVisibleToPlayer(m_kUnitState.ObjectID))
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status TargetIsVisibleToPlayer()
{
	if( m_kBehavior.BT_IsVisibleToPlayer(m_kBehavior.m_kBTCurrTarget.TargetID) )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status IsFlanked()
{
	if (m_kBehavior.HasKnowledgeOfXCom() // Only flanked if there are known units who can flank.
		&& m_kBehavior.BT_IsFlanked())
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status DidNotMoveLastTurn()
{
	if (m_kBehavior.BT_DidNotMoveLastTurn())
		return BTS_SUCCESS;
	return BTS_FAILURE;
}

function bt_status IsInFirstCombatTurn()
{
	if (m_kBehavior.BT_IsFirstCombatTurn())
		return BTS_SUCCESS;
	return BTS_FAILURE;
}
function bt_status IsOrangeAlert()
{
	if (m_kBehavior.IsOrangeAlert())
		return BTS_SUCCESS;
	return BTS_FAILURE;
}

function bt_status HasAmmo()
{
	if (m_kBehavior.HasAmmo())
		return BTS_SUCCESS;
	return BTS_FAILURE;
}

function bt_status IsLastActionPoint()
{
	if (m_kUnitState.NumAllActionPoints() == 1 )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status HasGoodShotTarget()
{
	return BTS_FAILURE;
}
function bt_status IsInDangerousArea()
{
	local string DangerText;
	if( m_kBehavior.IsInDangerousArea(DangerText) )
	{
		`LogAIBT( DangerText );
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}
function bt_status HasKillShot()
{
	if (m_kBehavior.HasPotentialKillShot())
		return BTS_SUCCESS;
	return BTS_FAILURE;
}

function bt_status IsAbilityAvailable()
{
	local AvailableAction kAbility;
	local string strError;
	kAbility = m_kBehavior.GetAvailableAbility(string(SplitNameParam), , strError);
	if (kAbility.AbilityObjectRef.ObjectID > 0)
		return BTS_SUCCESS;
	`LogAIBT("IsAbilityAvailable failure code:"$strError);
	return BTS_FAILURE;
}

function bt_status IsAbilityAvailableGroupwide()
{
	local XComGameState_AIGroup GroupState;

	GroupState = m_kUnitState.GetGroupMembership();
	if (GroupState.AIBTFindAbility(string(SplitNameParam), true))
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status IsAbilityReady()
{
	if (m_kBehavior.IsAbilityReady(SplitNameParam, m_ParamList))
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status AffectedByEffect()
{
	if (m_kUnitState.IsUnitAffectedByEffectName(SplitNameParam))
		return BTS_SUCCESS;
	return BTS_FAILURE;
}

function bt_status ApplyingEffect()
{
	if (m_kUnitState.IsUnitApplyingEffectName(SplitNameParam))
		return BTS_SUCCESS;
	return BTS_FAILURE;
}

function bt_status IsMissionOfType()
{
	if (`BATTLE.m_kDesc.MapData.ActiveMission.sType == string(SplitNameParam))
		return BTS_SUCCESS;
	return BTS_FAILURE;
}

function bt_status IsXComInCivilianRadius()
{
	if( IsTeamInCivilianRadius(eTeam_XCom, m_kUnitState, true) )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}
function bt_status IsAIInCivilianRadius()
{
	if( IsTeamInCivilianRadius(eTeam_Alien, m_kUnitState, true) || IsTeamInCivilianRadius(eTeam_TheLost, m_kUnitState, true) )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}
static function bool IsTeamInCivilianRadius( ETeam Team, XComGameState_Unit Civilian, bool OriginalTeamOnly )
{
	local XComGameStateHistory History;
	local XComGameState_Unit CurrentUnitState;
	local ETeam CurrTeam;
	local float MaxDist;
	History = `XCOMHISTORY;
	MaxDist = `TILESTOUNITS(class'XGAIBehavior_Civilian'.default.CIVILIAN_NEAR_STANDARD_REACT_RADIUS);
	foreach History.IterateByClassType(class'XComGameState_Unit', CurrentUnitState)
	{
		if( !CurrentUnitState.IsAbleToAct() )
		{
			continue;
		}
		if( OriginalTeamOnly )
		{
			CurrTeam = CurrentUnitState.GetPreviousTeam(); // Defaults to GetTeam if not mind-controlled.
		}
		else
		{
			CurrTeam = CurrentUnitState.GetTeam();
		}
		if( CurrTeam == Team )
		{
			if( class'Helpers'.static.IsUnitInRange(Civilian, CurrentUnitState, 0, MaxDist) )
			{
				return true;
			}
		}
	}
	return false;
}

function bt_status HasValidTarget()
{
	if (m_kBehavior.BT_HasTargetOption(SplitNameParam))
		return BTS_SUCCESS;
	return BTS_FAILURE;
}
function bt_status CheckStatCompare()
{
	local XComGameState_Unit kUnit;
	local int iStatOperandA, iStatOperandB;
	local UnitValue UValue;
	local bool bCountAllies, bAreaSearch;
	switch (m_eValType)
	{
		case eBTCV_Stat:
			if (m_bApplyToTarget)
			{
				if ( m_kBehavior.m_kBTCurrTarget.TargetID > 0 )
				{
					kUnit = XComGameState_Unit(`XCOMHISTORY.GetGameStateForObjectID(m_kBehavior.m_kBTCurrTarget.TargetID));
				}
				else
				{
					`LogAIBT("Behavior Tree Error - target not set on node"@m_strName$". Returning FAILURE.");
					return BTS_FAILURE; 
				}

				if (kUnit == none)
				{
					`LogAIBT("Behavior Tree Error - target not set to unit type"@m_strName$". Returning FAILURE.");
					return BTS_FAILURE;
				}
			}
			else
			{
				kUnit = m_kUnitState;
			}

			iStatOperandA = kUnit.GetCurrentStat(m_eStat);
			if (m_bPercent)
			{
				iStatOperandB = (float(m_iVal)/100.f) * kUnit.GetMaxStat(m_eStat);
			}
			else 
			{
				iStatOperandB = m_iVal;
			}
		break;

		case eBTCV_HitChance:
			iStatOperandA = m_kBehavior.BT_GetHitChanceOnTarget();
			iStatOperandB = m_iVal;
			break;

		case eBTCV_PotentialHitChance:
			iStatOperandA = m_kBehavior.BT_GetHitChanceForPotentialTargetOnAbility(SplitNameParam);
			iStatOperandB = m_iVal;
			break;

		case eBTCV_TopHitChance:
			iStatOperandA = m_kBehavior.BT_GetHighestHitChanceAgainstXCom();
			if( iStatOperandA < 0 )
			{
				`LogAIBT("Error- No valid targets.  Highest hit chance returned -1.");
				return BTS_FAILURE;
			}
			iStatOperandB = m_iVal;
		break;

		case eBTCV_BTVar:
			if( !m_kBehavior.BT_HasBTVar(m_ParamList[3], iStatOperandA) )
			{
				`LogAIBT("Error- BTVar not found:"@m_ParamList[3]);
				return BTS_FAILURE;
			}
			iStatOperandB = m_iVal;
			if( m_bPercent )
			{
				`RedScreen("Error, percent value not supported for stat condition type: BTVar. \nBehaviorTree StatCondition: BTVar \n@acheng");
			}
			break;

		case eBTCV_VisibleEnemies:
			iStatOperandA = m_kBehavior.BT_GetVisibleEnemyCount();
			iStatOperandB = m_iVal;
			if( m_bPercent )
			{
				`RedScreen("Error, percent value not supported for calculating number of visible enemies. \nBehaviorTree StatCondition: VisibleEnemies \n@acheng");
			}
		break;
		case eBTCV_VisibleAllies:
			iStatOperandA = m_kBehavior.BT_GetVisibleAllyCount();
			iStatOperandB = m_iVal;
			if( m_bPercent )
			{
				`RedScreen("Error, percent value not supported for calculating number of visible Allies. \nBehaviorTree StatCondition: VisibleAllies \n@acheng");
			}
		break;

		case eBTCV_PopularSupport:
			if (XGBattle_SP(`BATTLE).ShouldOverrideCivilianHostility())
			{
				iStatOperandA = XGBattle_SP(`BATTLE).GetMaxPopularSupport();
			}
			else
			{
				iStatOperandA = XGBattle_SP(`BATTLE).GetPopularSupport();
			}
			if (m_bPercent)
			{
				// TODO - what is the max value?
				iStatOperandB = ((float(m_iVal) / 100.f) * XGBattle_SP(`BATTLE).GetMaxPopularSupport());
			}
			else
			{
				iStatOperandB = m_iVal;
			}
		break;

		case eBTCV_AlertDataAge:
			iStatOperandA = m_kBehavior.BT_GetAlertDataAge();
			iStatOperandB = m_iVal;
		break;

		case eBTCV_AlertDataRadius:
			iStatOperandA = m_kBehavior.BT_GetAlertDataRadius();
			iStatOperandB = m_iVal;
		break;

		// dkaplan: removed 3/23/15
		//case eBTCV_AlertDataDistanceAtTimeOfAlert:
		//	iStatOperandA = m_kBehavior.BT_GetAlertDataDistanceAtTimeOfAlert();
		//	iStatOperandB = m_iVal;
		//break;
		case eBTCV_AlertDistance:
			iStatOperandA = m_kBehavior.BT_GetAlertDataDistance();
			iStatOperandB = m_iVal;
		break;

		case eBTCV_AlertCount:
			iStatOperandA = m_kBehavior.BT_GetAlertCount();
			iStatOperandB = m_iVal;
		break;

		case eBTCV_AbilityTargetUnitCount:
			iStatOperandA = m_kBehavior.BT_GetAbilityTargetUnitCount(SplitNameParam);
			iStatOperandB = m_iVal;
		break;

		case eBTCV_OverwatcherCount:
			if( m_ParamList.Length > 3 && m_ParamList[3] == '1' )
			{
				bCountAllies = true;
			}
			if ( m_ParamList.Length > 4 && m_ParamList[4] == '1')
			{
				bAreaSearch = true;
			}
			iStatOperandA = m_kBehavior.BT_GetOverwatcherCount(bCountAllies, bAreaSearch);
			iStatOperandB = m_iVal;
			break;

		case eBTCV_SuppressorCount:
			iStatOperandA = m_kBehavior.BT_GetSuppressorCount();
			iStatOperandB = m_iVal;
			break;

		case eBTCV_TargetSetCount:
			iStatOperandA = m_kBehavior.BT_GetTargetSelectedThisTurnCount();
			iStatOperandB = m_iVal;
			break;

		case eBTCV_Difficulty:
			iStatOperandA = `TACTICALDIFFICULTYSETTING;
			iStatOperandB = m_iVal;
			break;

		case eBTCV_CombatCount:
			iStatOperandA = `XTACTICALSOUNDMGR.NumCombatEvents;
			iStatOperandB = m_iVal;
			break;

		case eBTCV_GroupSize:
			iStatOperandA = m_kBehavior.BT_GetGroupSize();
			iStatOperandB = m_iVal;
			break;

		case eBTCV_ObjectiveDistance:
			iStatOperandA = int(CalcMetersFromObjectiveOnAxis());
			iStatOperandB = m_iVal;
			break;
		
		case eBTCV_TargetDistance:
			iStatOperandA = int(m_kBehavior.BT_GetTargetDistMeters('Potential'));
			iStatOperandB = m_iVal;
			break;

		case eBTCV_PriorityObjectAttackCount:
			if( m_kBehavior.m_kPlayer != None )
			{
				iStatOperandA = PriorityObjectTargetedCount();
				iStatOperandB = m_iVal;
				break;
			}

		case eBTCV_UnitValue:
			if( m_kUnitState.GetUnitValue(SplitNameParam, UValue) )
			{
				iStatOperandA = int(UValue.fValue);
				iStatOperandB = m_iVal;
			}
			else
			{
				`LogAIBT("StatCompare- UnitValue not found:"$SplitNameParam);
				return BTS_FAILURE;
			}
			break;

		case eBTCV_CiviliansKilled:
			iStatOperandA = class'Helpers'.static.GetNumCiviliansKilled();
			iStatOperandB = m_iVal;
			break;

		case eBTCV_TurnsEngaged:
			iStatOperandA = GetNumTurnsEngaged();
			iStatOperandB = m_iVal;
			break;

		case eBTCV_ActionPoints:
			iStatOperandA = m_kUnitState.NumActionPoints();
			iStatOperandB = m_iVal;
			break;

		case eBTCV_PlayerTurnCount:
			iStatOperandA = GetPlayerTurnCount();
			iStatOperandB = m_iVal;
			break;

		default:
			return BTS_FAILURE;
		break;
	}
	`LogAIBT("\nStatCompare:"@String(m_eValType)@"value="$iStatOperandA@"\nOperator: "$string(m_ParamList[1])@"\nOperandB="@m_iVal);

	if (m_dStatCompareFn(iStatOperandA, iStatOperandB))
		return BTS_SUCCESS;
	return BTS_FAILURE;
}

//------------------------------------------------------------------------------------------------
// Creating these functions only because I can't seem to set operators as delegates.
function bool CheckStatEqual(int A, int B) { return A == B; }
function bool CheckStatNotEqual( int A, int B ) { return A != B; }
function bool CheckStatGreater( int A, int B ) { return A > B; }
function bool CheckStatGreaterOrEqual(int A, int B ) { return A >= B; }
function bool CheckStatLessThan(int A, int B) { return A < B; }
function bool CheckStatLessThanOrEqual(int A, int B) { return A <= B; }
//------------------------------------------------------------------------------------------------
function float CalcMetersFromObjectiveOnAxis()
{
	local float fDist;
	local vector ClosestPointOnAxis;
	if( m_kBehavior.m_kPlayer != None )
	{
		ClosestPointOnAxis = m_kBehavior.m_kPlayer.m_kNav.GetNearestPointOnAxisOfPlay(m_kBehavior.GetGameStateLocation());
		fDist = VSize2D(ClosestPointOnAxis - m_kBehavior.m_kPlayer.m_kNav.m_kAxisOfPlay.v2); // Objective location
		return `UNITSTOMETERS(fDist);
	}
	`LogAIBT("Unable to calc distance from Objective.  Non-AI unit, no AI Player attached.");
	return 0;
}

function int PriorityObjectTargetedCount()
{
	local XComGameState_AIPlayerData AIData;
	local XComGameState_InteractiveObject PriorityObject;
	if( m_kBehavior.m_kPlayer != None )
	{
		AIData = m_kBehavior.GetAIPlayerData();
		if( AIData != None && AIData.m_iPlayerObjectID == m_kUnitState.ControllingPlayer.ObjectID)
		{
			if( AIData.HasPriorityTargetObject(PriorityObject) )
			{
				return m_kBehavior.m_kPlayer.GetNumTimesUnitTargetedThisTurn(PriorityObject.ObjectID);
			}
		}
	}
	`LogAIBT("Error - No PriorityObject could be found!");
	return 0;
}

function bt_status TargetHitChanceLow()
{
	if (m_kBehavior.BT_GetHitChanceOnTarget() < 40)
		return BTS_SUCCESS;
	return BTS_FAILURE;
}
function bt_status TargetHitChanceHigh()
{
	if (m_kBehavior.BT_GetHitChanceOnTarget() >= 80)
		return BTS_SUCCESS;
	return BTS_FAILURE;
}

function bt_status BestTargetHitChanceOver50()
{
	if (m_kBehavior.BT_GetHitChanceOnBestTarget() > 50)
		return BTS_SUCCESS;
	return BTS_FAILURE;
}
function bt_status IsFlankingTarget()
{
	if (m_kBehavior.BT_IsFlankingTarget())
		return BTS_SUCCESS;
	return BTS_FAILURE;
}
function bt_status TargetAffectedByEffect()
{
	local XComGameState_Unit kTarget;
	if( m_kBehavior.BT_GetTarget(kTarget) )
	{
		if( kTarget.IsUnitAffectedByEffectName(SplitNameParam) )
			return BTS_SUCCESS;
	}
	else
	{
		`LogAIBT("IsTargetAffectedBy- failure - No current target or curr alert data active!  Unit# "$m_kUnitState.ObjectID);
	}
	return BTS_FAILURE;
}
function bt_status TargetIsApplyingEffect()
{
	local XComGameState_Unit kTarget;
	if( m_kBehavior.BT_GetTarget(kTarget) )
	{
		if( kTarget.IsUnitApplyingEffectName(SplitNameParam) )
			return BTS_SUCCESS;
	}
	else
	{
		`LogAIBT("IsTargetApplyingEffect- failure - No current target or curr alert data active!  Unit# "$m_kUnitState.ObjectID);
	}
	return BTS_FAILURE;
}
function bt_status TargetIsKillable()
{
	if (m_kBehavior.BT_TargetIsKillable())
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status TargetIsAdvent()
{
	if( m_kBehavior.BT_TargetIsAdvent() )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}
function bt_status TargetIsAlien()
{
	if( m_kBehavior.BT_TargetIsAlien() )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status TargetIsRobotic()
{
	if( m_kBehavior.BT_TargetIsRobotic() )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status TargetTemplateNameIs()
{
	local XComGameState_Unit TargetState;
	if( m_kBehavior.BT_GetTarget(TargetState) )
	{
		if( TargetState.GetMyTemplateName() == SplitNameParam )
		{
			return BTS_SUCCESS;
		}
	}
	else
	{
		`LogAIBT("TargetTemplateNameCheck failure - No current target or curr alert data active!  Unit# "$m_kUnitState.ObjectID);
	}
	return BTS_FAILURE;
}
function bt_status TemplateNameIs()
{
	if( m_kUnitState.GetMyTemplateName() == SplitNameParam )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}
function bt_status IsTargetInMovementRange()
{
	if( m_kBehavior.BT_IsTargetInMovementRange(SplitNameParam) )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status IsTargetInAttackRange()
{
	if( m_kBehavior.BT_IsTargetInAttackRange(SplitNameParam) )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status AlertDataIsAbsoluteKnowledge()
{
	if( m_kBehavior.BT_AlertDataIsAbsoluteKnowledge() )
		return BTS_SUCCESS;
	return BTS_FAILURE;
}

function bt_status AlertDataWasSoundMade()
{
	if (m_kBehavior.BT_AlertDataWasSoundMade())
		return BTS_SUCCESS;
	return BTS_FAILURE;
}

function bt_status AlertDataWasEnemyThere()
{
	if (m_kBehavior.BT_AlertDataWasEnemyThere())
		return BTS_SUCCESS;
	return BTS_FAILURE;
}

function bt_status AlertDataIsCorpseThere()
{
	if (m_kBehavior.BT_AlertDataIsCorpseThere())
		return BTS_SUCCESS;
	return BTS_FAILURE;
}

function bt_status AlertDataIsAggressive()
{
	if (m_kBehavior.BT_AlertDataIsAggressive())
		return BTS_SUCCESS;
	return BTS_FAILURE;
}

function bt_status HasBTVar()
{
	if( m_kBehavior.BT_HasBTVar(SplitNameParam) )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status AlertDataIsType()
{
	if( m_kBehavior.BT_AlertDataIsType(String(SplitNameParam)) )
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status AlertDataTileIsVisible()
{
	if( m_kBehavior.BT_AlertDataTileIsVisible() )
		return BTS_SUCCESS;
	return BTS_FAILURE;
}

function bt_status HasValidAlertDataLocation()
{
	if (m_kBehavior.BT_HasValidAlertDataLocation())
		return BTS_SUCCESS;
	return BTS_FAILURE;
}

function bt_status AlertDataHasTag()
{
	if (m_kBehavior.BT_AlertDataHasTag(String(SplitNameParam)))
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

//------------------------------------------------------------------------------
// Functions used for debugging 
function string GetNodeDetails(const out array<BTDetailedInfo> TraversalData)
{
	local string strText;
	local name Param;
	local int iParam;
	strText = super.GetNodeDetails(TraversalData);

	strText @= "CONDITION\n";

	if (m_dConditionFn != None)
	{
		strText @= "delegate="$string(m_dConditionFn)$"\n";
	}
	if (m_dStatCompareFn != None)
	{
		strText @= "StatCmpFn="$string(m_dStatCompareFn)$"\n";
	}

	if (SplitNameParam != '')
	{
		strText @= "Ability Name="$SplitNameParam@"\n";
	}

	strText @= "\nParam count="$m_ParamList.Length$"\n";
	for (iParam=0; iParam < m_ParamList.Length; iParam++)
	{
		Param = m_ParamList[iParam];
		// handle html tag failures
		if (String(Param) == "<")
		{
			Param = 'less than';
		}
		else if (String(Param) == "<=")
		{
			Param = 'less than or equal';
		}
		strText @= "(Param "$iParam$")"@Param@"\n";
	}
	return strText;
}

function int GetNumTurnsEngaged()
{
	local XComGameState_AIUnitData AIUnitData;
	local XComGameStateHistory History;
	local XComGameState_Player PlayerState;
	local int DataID;
	DataID = m_kBehavior.GetAIUnitDataID(m_kUnitState.ObjectID);
	if (DataID > 0)
	{
		History = `XCOMHISTORY;
		AIUnitData = XComGameState_AIUnitData(History.GetGameStateForObjectID(m_kBehavior.GetAIUnitDataID(m_kUnitState.ObjectID)));
		if (AIUnitData.iRedAlertTurn < 0) // Has not been in Red Alert yet. 
		{
			return 0;
		}
		PlayerState = XComGameState_Player(History.GetGameStateForObjectID(m_kUnitState.ControllingPlayer.ObjectID));
		return PlayerState.PlayerTurnCount - AIUnitData.iRedAlertTurn;
	}
	return 0;
}

function bt_status TargetIsPanicObsessedTarget()
{
	local XComGameState_Unit TargetUnit;
	local UnitValue ObsessedTargetValue;
	if (m_kBehavior.BT_GetTarget(TargetUnit))
	{
		if (m_kUnitState.GetUnitValue('ObsessedTarget', ObsessedTargetValue))
		{
			if (TargetUnit.ObjectID == ObsessedTargetValue.fValue)
			{
				return BTS_SUCCESS;
			}
		}
		else
		{
			`LogAIBT("No ObsessedTarget UnitValue found in unit state!");
		}
	}
	else
	{
		`LogAIBT("No result from XGAIBehavior::BT_GetTarget!");
	}
	return BTS_FAILURE;
}

function bt_status ShouldChosenUseKidnap()
{
	local XComGameState_HeadquartersAlien AlienHQ;
	local int CaptureChance, Roll;

	AlienHQ = XComGameState_HeadquartersAlien(`XCOMHISTORY.GetSingleGameStateObjectForClass(class'XComGameState_HeadquartersAlien'));
	
	if (AlienHQ.bChosenCapture)
	{
		CaptureChance = 100;
	}
	else
	{
		CaptureChance = AlienHQ.GetChosenCaptureChance(m_kUnitState);
	}
	
	Roll = `SYNC_RAND(100);
	`LogAIBT("ShouldChosenUseKidnap rolled a "$Roll$".  Chance = " @ CaptureChance);
	if (Roll < CaptureChance)
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status HasSelectedGenericAbility()
{
	if (m_kBehavior.BT_HasSelectedGenericAbility())
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status ShouldMoveTowardGenericAbilityOption()
{
	if (m_kBehavior.BT_ShouldMoveTowardGenericAbilityOption())
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status ShouldFlankGASTarget()
{
	if (m_kBehavior.BT_ShouldFlankGASTarget())
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status GASIsAoEAbility()
{
	if (m_kBehavior.BT_GASIsAoEAbility())
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status IsTargetMeleeUnitOnly()
{
	local XComGameState_Unit TargetState;
	if (m_kBehavior.BT_GetTarget(TargetState))
	{
		if (TargetState.IsMeleeOnly())
		{
			return BTS_SUCCESS;
		}
	}
	return BTS_FAILURE;
}

function bt_status IsTargetOutOfEnemyRange()
{
	local XComGameState_Unit TargetState;
	local int nMeters;
	local array<StateObjectReference> EnemyList;
	local XGUnit TargetUnit;
	if (m_kBehavior.BT_GetTarget(TargetState))
	{
		if (TargetState.IsMeleeOnly())
		{
			// Update - moving any melee units that are out of immediate attack range.
			TargetUnit = XGUnit(TargetState.GetVisualizer());
			nMeters = TargetUnit.m_kBehavior.GetMeleeTileRange();
			nMeters = `TILESTOMETERS(nMeters);
		}
		else if ( m_ParamList.Length > 0)
		{
			nMeters = int(String(m_ParamList[0]));
		}
		else
		{
			`LogAIBT("No Param range defined.");
			return BTS_FAILURE;
		}
		TargetState.GetEnemiesInRange(TargetState.TileLocation, nMeters, EnemyList);
		if (EnemyList.Length == 0) // Includes all living enemies.  May need to check if incapacitated?
		{
			return BTS_SUCCESS;
		}
	}
	return BTS_FAILURE;
}

function bt_status IsTargetTurret()
{
	local XComGameState_Unit TargetState;
	if (m_kBehavior.BT_GetTarget(TargetState))
	{
		if (TargetState.IsTurret())
		{
			return BTS_SUCCESS;
		}
	}
	return BTS_FAILURE;
}

function bt_status TargetTakesCover()
{
	local XComGameState_Unit TargetState;
	if (m_kBehavior.BT_GetTarget(TargetState))
	{
		if (TargetState.CanTakeCover())
		{
			return BTS_SUCCESS;
		}
	}
	return BTS_FAILURE;
}

function bt_status IsChosenOutOfRange()
{
	local float Range;
	local array<StateObjectReference> EnemyList;
	local XComGameState_Unit EnemyState;
	local StateObjectReference EnemyRef;
	local XComGameStateHistory History;
	if (m_ParamList.Length > 0)
	{
		Range = float(String(m_ParamList[0]));
		if (Range > 0)
		{
			History = `XCOMHISTORY;
				m_kUnitState.GetEnemiesInRange(m_kUnitState.TileLocation, Range, EnemyList); // Pulls all enemies that are alive.
			foreach EnemyList(EnemyRef)
			{
				EnemyState = XComGameState_Unit(History.GetGameStateForObjectID(EnemyRef.ObjectID));
				// Only consider team xcom, non concealed, not incapacitated.
				if (EnemyState.GetTeam() == eTeam_XCom
					&& !EnemyState.IsConcealed()
					&& !EnemyState.bRemovedFromPlay
					&& !EnemyState.GetMyTemplate().bIsCosmetic)
				{
					// Found a valid enemy within range.
					`LogAIBT("Chosen not out of range.  Unit #"$EnemyState.ObjectID@ "is in range.");
					return BTS_FAILURE;
				}
			}
			// No valid enemies found within range.
			return BTS_SUCCESS;
		}
		else
		{
			`LogAIBT("Error - Invalid range limit specified. ");
		}
	}
	else
	{
		`LogAIBT("Error - no range limit specified. ");
	}
	return BTS_FAILURE;
}

function bt_status IsAIControlled()
{
	if (m_kUnitState.ControllingPlayerIsAI())
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status HasPsiOverloaderTeammate()
{
	local int OverloaderID;
	local XComGameState_Unit Overloader;
	if (m_kBehavior.BT_HasBTVar('PsiOverloader', OverloaderID))
	{
		// Value is set.  Check if this unit is alive.
		Overloader = XComGameState_Unit(`XCOMHISTORY.GetGameStateForObjectID(OverloaderID));
		if (Overloader != None && Overloader.IsAbleToAct())
		{
			`LogAIBT("Found Overloader ID == "$OverloaderID@".");
				return BTS_SUCCESS;
		}
		`LogAIBT("Overloader ID == "$OverloaderID@" but is unable to act!");
	}
	else
	{
		`LogAIBT("No overloader has been set this turn.");
	}
	return BTS_FAILURE;
}

// Overload / Self Destruct code, borrowed from DLC_90 files. 
function bool GetPsiOverloadableUnits(out array<XComGameState_Unit> OverloadList_Out, XGPlayer OwningPlayer)
{
	local array<XComGameState_Unit> UnitList;
	local XComGameState_Unit UnitState;
	local StateObjectReference AbilityRef;
	OwningPlayer.GetPlayableUnits(UnitList, true);
	foreach UnitList(UnitState)
	{
		AbilityRef = UnitState.FindAbility('EngagePsiSelfDestruct');
		if (AbilityRef.ObjectID > 0)
		{
			if (!UnitState.IsUnrevealedAI() // Only revealed units can overload.
				&& !UnitState.IsUnitAffectedByEffectName(class'X2Ability_ChosenWarlock'.default.PsiSelfDestructEffectName)) 
			{
				OverloadList_Out.AddItem(UnitState);
			}
		}
	}
	return OverloadList_Out.Length > 0;
}
// If this is called, we need to update the ShouldPsiOverload unit var
function bt_status UpdatePsiOverloadVar()
{
	local array<XComGameState_Unit> UnitList, FinalList;
	local XComGameState_Unit ListUnitState;
	local float MaxDistSq, DistSq;
	local XGUnit UnitVis;
	local XGAIBehavior UnitBehavior;
	local vector UnitLocation;
	local int RandUnitIndex, Value;

	// BTVars get init-ed with the Player Init.  Only needed during the sequence of BT runs on the AI player turn, not saved out.
	if (GetPsiOverloadableUnits(UnitList, m_kBehavior.m_kPlayer))
	{
		// cannot reduce list based on ability availability, since abilities don't get updated until the unit is next to run.
		// For now reduce based on proximity to the enemy.  Remove any units that cannot reach any soldiers.  (cheat??? Soldier Location?)
		MaxDistSq = `TILESTOUNITS(PSIOVERLOAD_ACTIVATION_RANGE);
		MaxDistSq = Square(MaxDistSq);
		foreach UnitList(ListUnitState)
		{
			UnitVis = XGUnit(ListUnitState.GetVisualizer());
			if (UnitVis != None)
			{
				UnitLocation = UnitVis.GetGameStateLocation();
				m_kBehavior.m_kPlayer.GetNearestEnemy(UnitLocation, DistSq); // Note- this only skips critically wounded.  Change?
				if (DistSq > 0 && DistSq < MaxDistSq)
				{
					FinalList.AddItem(ListUnitState);
				}
			}
		}
		// For now we are selecting one nearby unit each turn randomly to be the chosen one to use Overload.
		if (FinalList.Length > 0)
		{
			RandUnitIndex = `SYNC_RAND(FinalList.Length);
			ListUnitState = FinalList[RandUnitIndex];
			FinalList.Length = 0;
			FinalList.AddItem(ListUnitState);
		}
		// Set all to false, except the chosen one.
		foreach UnitList(ListUnitState)
		{
			UnitBehavior = XGUnit(ListUnitState.GetVisualizer()).m_kBehavior;
			if (FinalList[0].ObjectID == ListUnitState.ObjectID)
			{
				Value = 1;
			}
			else
			{
				Value = 0;
			}
			UnitBehavior.BT_SetBTVar("ShouldPsiOverload", Value, true);
			UnitBehavior.BT_SetBTVar("PsiOverloader", FinalList[0].ObjectID, true); // Save out the overloader ID for suppression checks.
		}

	}

	return BTS_SUCCESS;
}

function bt_status NotLastEnemy()
{
	local array<XComGameState_Unit> KnownEnemies;
	m_kBehavior.GetAllKnownEnemyStates(KnownEnemies);
	if (KnownEnemies.Length > 1)
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;

}

function bt_status HasAlliesOfType()
{
	local XGPlayer kPlayer;
	local array<XComGameState_Unit> UnitList;
	local XComGameState_Unit Unit;
	if (SplitNameParam != '')
	{
		kPlayer = m_kBehavior.m_kUnit.GetPlayer();
		if (kPlayer != None)
		{
			kPlayer.GetPlayableUnits(UnitList);
			foreach UnitList(Unit)
			{
				if (Unit.GetMyTemplateGroupName() == SplitNameParam)
				{
					return BTS_SUCCESS;
				}
			}
		}
	}
	else
	{
		`LogAIBT("Node:HasAlliesOfType- Missing type name!");
	}
	return BTS_FAILURE;
}

function bt_status DarkEventActive()
{
	local XComGameStateHistory History;
	local XComGameState_HeadquartersXCom XComHQ;

	History = `XCOMHISTORY;
	XComHQ = XComGameState_HeadquartersXCom(History.GetSingleGameStateObjectForClass(class'XComGameState_HeadquartersXCom', true));
	if (SplitNameParam != '')
	{
		if (XComHQ.TacticalGameplayTags.Find(SplitNameParam) != INDEX_NONE)
		{
			return BTS_SUCCESS;
		}
	}
	return BTS_FAILURE;
}

function bt_status TargetIsSoldierClass()
{
	local XComGameState_Unit TargetState;
	if (SplitNameParam != '')
	{
		if (m_kBehavior.BT_GetTarget(TargetState))
		{
			if (TargetState.GetSoldierClassTemplateName() == SplitNameParam)
			{
				return BTS_SUCCESS;
			}
		}
	}
	return BTS_FAILURE;
}

function bt_status TargetWasLastTrackingShotMarked()
{
	local XComGameState_Unit TargetState;
	local UnitValue TargetValue;
	if (m_kBehavior.BT_GetTarget(TargetState))
	{
		if (m_kUnitState.GetUnitValue('LastTrackingShotTarget', TargetValue))
		{
			if (TargetValue.fValue > 0
				&& TargetValue.fValue == TargetState.ObjectID)
			{
				return BTS_SUCCESS;
			}
		}
	}
	return BTS_FAILURE;
}

function bt_status IsLastAIUnit()
{
	local XGPlayer Player, TheLostPlayer;
	local array<XComGameState_Unit> UnitsLeft;
	Player = m_kBehavior.m_kUnit.GetPlayer();
	// Also pull from TheLost units.
	TheLostPlayer = XGBattle_SP(`BATTLE).GetTheLostPlayer();
	if (TheLostPlayer != None)
	{
		TheLostPlayer.GetPlayableUnits(UnitsLeft, true);
	}
	Player.GetPlayableUnits(UnitsLeft, true);
	`LogAIBT("UnitsLeft.Length ="@UnitsLeft.Length);
	if (UnitsLeft.Length == 1)
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status TargetIsFlankingEnemy()
{
	local XComGameState_Unit kTarget;
	local int nFlankedEnemies;

	if (m_kBehavior.BT_GetTarget(kTarget))
	{
		nFlankedEnemies = class'X2TacticalVisibilityHelpers'.static.GetNumEnemiesFlankedBySource(kTarget.ObjectID);
		`LogAIBT("Num Flanked Enemies = "$nFlankedEnemies);
		if ( nFlankedEnemies > 0)
		{
			return BTS_SUCCESS;
		}
	}
	else
	{
		`LogAIBT("No target found!");
	}

	return BTS_FAILURE;
}

function bt_status TargetCharacterGroup()
{
	local XComGameState_Unit kTarget;
	local name GroupName;
	if (m_kBehavior.BT_GetTarget(kTarget))
	{
		GroupName = kTarget.GetMyTemplateGroupName();
		if (GroupName == SplitNameParam)
		{
			return BTS_SUCCESS;
		}
	}
	`LogAIBT("Target "$kTarget.ObjectID$"=" @GroupName);
	return BTS_FAILURE;
}

function bt_status JustSpawnedThisTurn()
{
	local XComGameState_AIPlayerData AIData;
	local XComGameState_Unit LastTurnUnitState;

	AIData = m_kBehavior.GetAIPlayerData();
	LastTurnUnitState = XComGameState_Unit(`XCOMHISTORY.GetGameStateForObjectID(m_kUnitState.ObjectID, , AIData.m_iLastEndTurnHistoryIndex));
	if (LastTurnUnitState == None)
	{
		return BTS_SUCCESS;
	}

	return BTS_FAILURE;
}

function bt_status TargetsExistForAoE()
{
	if (class'X2AIBTDefaultActions'.static.IsValidAoEProfile(SplitNameParam)
		&& m_kBehavior.BT_TargetsExistForAoE(SplitNameParam))
	{
		return BTS_SUCCESS;
	}
	return BTS_FAILURE;
}

function bt_status TargetIsOverwatching()
{
	local XComGameState_Unit TargetUnit;
	if (m_kBehavior.BT_GetTarget(TargetUnit))
	{
		if ( TargetUnit.ReserveActionPoints.Length > 0)
		{
			return BTS_SUCCESS;
		}
	}
	return BTS_FAILURE;
}

cpptext
{
	virtual void ResetObject();
};

defaultproperties
{
}