class X2Ability_TemplarAbilitySet extends X2Ability
	config(GameData_SoldierSkills)
	native(Core);

// Focus stat boost
var config int FOCUS1MOBILITY;
var config int FOCUS1DODGE;
var config int FOCUS1RENDDAMAGE;
var config int FOCUS2MOBILITY;
var config int FOCUS2DODGE;
var config int FOCUS2RENDDAMAGE;
var config int FOCUS3MOBILITY;
var config int FOCUS3DODGE;
var config int FOCUS3RENDDAMAGE;

var config float REND_STUN_AND_KNOCKBACK_CHANCE;
var config float REND_DISORIENT_CHANCE;
var config int OVERCHARGE_FOCUS_CHANCE;
var config array<name> FocusKillAbilities;
var config float AmplifyBonusDamageMult;
var config int AmplifyMinBonusDamage;
var config int AMPLIFY_COOLDOWN;
var config int PILLAR_COOLDOWN;
var config int VoltHitMod;
var config int ChannelChance, ChannelPsionicChance;
var config name ChannelDropItemTemplate;
var config int ReflectShotHitChance;
var config int INVERT_COOLDOWN, EXCHANGE_COOLDOWN;
var config array<name> FocusDamageBoostAbilities;
var config int GhostRendFocusCost;
var config int GhostFocusCost;
var config float GhostHPPerFocus;
var config int GHOST_CHARGES;
var config array<Name> AbilitiesGhostCantHave;
var config array<name> GhostOnlyAbilities;
var config float IONICSTORM_RADIUS_METERS;
var config float IonicStormTargetMinDelay, IonicStormTargetMaxDelay;
var config int IONICSTORM_COOLDOWN;
var config int VoidConduitInitialDamage, VoidConduitPerActionDamage;
var config float VoidConduitHPMod;
var config int VOIDCONDUIT_COOLDOWN;
var config int StunStrikeHitChance, StunStrikeFocusMultiplierHitChance;
var config int StunStrikeDisorientNumTurns, StunStrikeDisorientFocusMultiplier;
var config int STUNSTRIKE_COOLDOWN;
var config float ArcWaveConeEndDiameterTiles;
var config float ArcWaveConeLengthTiles;
var config int MEDITATION_PREPARATION_STARTING_FOCUS;

var localized string RecoilEffectName;
var localized string RecoilEffectDesc;
var localized string MaxFocusPickup;
var localized string AmplifyEffectName;
var localized string AmplifyEffectDesc;

static function array<X2DataTemplate> CreateTemplates()
{
	local array<X2DataTemplate> Templates;

	Templates.AddItem(TemplarFocus());
	Templates.AddItem(FocusKillTracker());
	Templates.AddItem(Rend());
	Templates.AddItem(Overcharge());
	Templates.AddItem(OverchargePassive());
	Templates.AddItem(ArcWave());
	Templates.AddItem(ArcWavePassive());
	Templates.AddItem(Momentum());
	Templates.AddItem(MomentumPassive());
	Templates.AddItem(Volt());
	Templates.AddItem(Parry());
	Templates.AddItem(ParryActivate());
	Templates.AddItem(Amplify());
	Templates.AddItem(Pillar());
	Templates.AddItem(Channel());
	Templates.AddItem(ChannelPassive());
	Templates.AddItem(Deflect());
	Templates.AddItem(Reflect());
	Templates.AddItem(ReflectShot());
	Templates.AddItem(TemplarInvert());
	Templates.AddItem(TemplarExchange());
	Templates.AddItem(DeepFocus());
	Templates.AddItem(Ghost());
	Templates.AddItem(Reverberation());
	Templates.AddItem(GhostKill());
	Templates.AddItem(GhostInit());
	Templates.AddItem(IonicStorm());
	Templates.AddItem(VoidConduit());
	Templates.AddItem(StunStrike());
	Templates.AddItem(MeditationPreparation());
	Templates.AddItem(MeditationPreparationPassive());
	Templates.AddItem(TemplarBladestorm());
	Templates.AddItem(TemplarBladestormAttack());

	return Templates;
}

static function X2AbilityTemplate TemplarFocus()
{
	local X2AbilityTemplate		Template;
	local X2Effect_TemplarFocus	FocusEffect;
	local array<StatChange>		StatChanges;
	local StatChange			NewStatChange;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'TemplarFocus');

//BEGIN AUTOGENERATED CODE: Template Overrides 'TemplarFocus'
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_InnerFocus";
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
//END AUTOGENERATED CODE: Template Overrides 'TemplarFocus'
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_NeverShow;
	Template.Hostility = eHostility_Neutral;
	Template.bIsPassive = true;

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SelfTarget;
	Template.AbilityTriggers.AddItem(default.UnitPostBeginPlayTrigger);

	FocusEffect = new class'X2Effect_TemplarFocus';
	FocusEffect.BuildPersistentEffect(1, true, false);
	FocusEffect.SetDisplayInfo(ePerkBuff_Passive, Template.LocFriendlyName, Template.LocLongDescription, Template.IconImage, false, , Template.AbilitySourceName);
	FocusEffect.EffectSyncVisualizationFn = FocusEffectVisualization;
	FocusEffect.VisualizationFn = FocusEffectVisualization;

	//	focus 0
	StatChanges.Length = 0;
	FocusEffect.AddNextFocusLevel(StatChanges, 0, 0);
	//	focus 1
	StatChanges.Length = 0;
	NewStatChange.StatType = eStat_Mobility;
	NewStatChange.StatAmount = default.FOCUS1MOBILITY;
	StatChanges.AddItem(NewStatChange);
	NewStatChange.StatType = eStat_Dodge;
	NewStatChange.StatAmount = default.FOCUS1DODGE;
	StatChanges.AddItem(NewStatChange);
	FocusEffect.AddNextFocusLevel(StatChanges, 0, default.FOCUS1RENDDAMAGE);
	//	focus 2
	StatChanges.Length = 0;
	NewStatChange.StatType = eStat_Mobility;
	NewStatChange.StatAmount = default.FOCUS2MOBILITY;
	StatChanges.AddItem(NewStatChange);
	NewStatChange.StatType = eStat_Dodge;
	NewStatChange.StatAmount = default.FOCUS2DODGE;
	StatChanges.AddItem(NewStatChange);
	FocusEffect.AddNextFocusLevel(StatChanges, 0, default.FOCUS2RENDDAMAGE);
	//	focus 3
	StatChanges.Length = 0;
	NewStatChange.StatType = eStat_Mobility;
	NewStatChange.StatAmount = default.FOCUS3MOBILITY;
	StatChanges.AddItem(NewStatChange);
	NewStatChange.StatType = eStat_Dodge;
	NewStatChange.StatAmount = default.FOCUS3DODGE;
	StatChanges.AddItem(NewStatChange);
	FocusEffect.AddNextFocusLevel(StatChanges, 0, default.FOCUS3RENDDAMAGE);

	Template.AddTargetEffect(FocusEffect);

	Template.AdditionalAbilities.AddItem('FocusKillTracker');

	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = TypicalAbility_BuildVisualization;
	Template.bSkipFireAction = true;

	return Template;
}

static function FocusEffectVisualization(XComGameState VisualizeGameState, out VisualizationActionMetadata ActionMetadata, const name EffectApplyResult)
{
	local XComGameState_Unit UnitState;
	local XComGameState_Effect_TemplarFocus FocusState;

	UnitState = XComGameState_Unit(ActionMetadata.StateObject_NewState);
	if( UnitState != None )
	{
		FocusState = UnitState.GetTemplarFocusEffectState();
		if( FocusState != None )
		{
			PlayFocusFX(VisualizeGameState, ActionMetadata, "ADD_StartFocus", FocusState.FocusLevel);
			UpdateFocusUI(VisualizeGameState, ActionMetadata);
		}
	}
}

static function PlayFocusFX(XComGameState VisualizeGameState, out VisualizationActionMetadata ActionMetadata, string InitialAnimName, int FocusLevel)
{
	local XGUnit Unit;
	local XComUnitPawn UnitPawn;
	local Name AnimName;
	local X2Action_PlayAdditiveAnim PlayAdditiveAnim;

	Unit = XGUnit(ActionMetadata.VisualizeActor);
	if( Unit != None )
	{
		UnitPawn = Unit.GetPawn();
		if( UnitPawn != None )
		{
			AnimName = Name(InitialAnimName $ string(FocusLevel));
			if( UnitPawn.GetAnimTreeController().CanPlayAnimation(AnimName) )
			{
				PlayAdditiveAnim = X2Action_PlayAdditiveAnim(class'X2Action_PlayAdditiveAnim'.static.AddToVisualizationTree(ActionMetadata, VisualizeGameState.GetContext(), false, ActionMetadata.LastActionAdded));
				PlayAdditiveAnim.AdditiveAnimParams.AnimName = AnimName;
				PlayAdditiveAnim.AdditiveAnimParams.BlendTime = 0.0f;
			}
		}
	}
}

static function UpdateFocusUI(XComGameState VisualizeGameState, out VisualizationActionMetadata ActionMetadata)
{
	local XComGameState_Unit UnitState;
	local XComGameState_Effect_TemplarFocus FocusState;
	local X2Action_UpdateUI UpdateUI;

	UnitState = XComGameState_Unit(ActionMetadata.StateObject_NewState);
	if( UnitState != None )
	{
		FocusState = UnitState.GetTemplarFocusEffectState();
		if( FocusState != None )
		{
			UpdateUI = X2Action_UpdateUI(class'X2Action_UpdateUI'.static.AddToVisualizationTree(ActionMetadata, VisualizeGameState.GetContext(), false, ActionMetadata.LastActionAdded));
			UpdateUI.UpdateType = EUIUT_FocusLevel;
			UpdateUI.SpecificID = FocusState.ObjectID;
		}
	}
}

static function X2AbilityTemplate FocusKillTracker()
{
	local X2AbilityTemplate					Template;
	local X2AbilityTrigger_EventListener	EventTrigger;
	local X2Effect_ModifyTemplarFocus		FocusEffect;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'FocusKillTracker');

	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_templarFocus";
//BEGIN AUTOGENERATED CODE: Template Overrides 'FocusKillTracker'
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
//END AUTOGENERATED CODE: Template Overrides 'FocusKillTracker'
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_NeverShow;
	Template.Hostility = eHostility_Neutral;
	Template.bIsPassive = true;

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SelfTarget;
	
	EventTrigger = new class'X2AbilityTrigger_EventListener';
	EventTrigger.ListenerData.Deferral = ELD_OnStateSubmitted;
	EventTrigger.ListenerData.EventID = 'KillMail';
	EventTrigger.ListenerData.Filter = eFilter_Unit;
	EventTrigger.ListenerData.EventFn = class'XComGameState_Ability'.static.FocusKillTracker_Listener;
	Template.AbilityTriggers.AddItem(EventTrigger);

	FocusEffect = new class'X2Effect_ModifyTemplarFocus';
	FocusEffect.TargetConditions.AddItem(new class'X2Condition_GhostShooter');
	Template.AddTargetEffect(FocusEffect);

	Template.bSkipFireAction = true;
	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = TypicalAbility_BuildVisualization;
	Template.MergeVisualizationFn = DesiredVisualizationBlock_MergeVisualization;

	return Template;
}

static function X2AbilityTemplate Rend(name TemplateName = 'Rend')
{
	local X2AbilityTemplate                 Template;
	local X2AbilityCost_ActionPoints        ActionPointCost;
	local X2AbilityToHitCalc_StandardMelee  StandardMelee;
	local X2Effect_ApplyWeaponDamage        WeaponDamageEffect;
	local array<name>                       SkipExclusions;
	local X2Effect_SetUnitValue				UnitValueEffect;
	local X2Condition_UnitValue				UnitValueCondition;
	local X2Effect_Knockback				KnockbackEffect;
	local X2Effect_Stunned					StunnedEffect;
	local X2Effect_PersistentStatChange		DisorientedEffect;
	local X2AbilityCost_Focus				FocusCost;

	`CREATE_X2ABILITY_TEMPLATE(Template, TemplateName);

	Template.AbilitySourceName = 'eAbilitySource_Standard';
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_AlwaysShow;
	Template.BuildNewGameStateFn = TypicalMoveEndAbility_BuildGameState;
	Template.BuildVisualizationFn = TypicalAbility_BuildVisualization;
	Template.BuildInterruptGameStateFn = TypicalMoveEndAbility_BuildInterruptGameState;
	Template.CinescriptCameraType = "Ranger_Reaper";
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_Rend";
	Template.bHideOnClassUnlock = false;
	Template.ShotHUDPriority = class'UIUtilities_Tactical'.const.REND_PRIORITY;
	Template.AbilityConfirmSound = "TacticalUI_SwordConfirm";

	ActionPointCost = new class'X2AbilityCost_ActionPoints';
	ActionPointCost.iNumPoints = 1;
	ActionPointCost.bConsumeAllPoints = true;
	Template.AbilityCosts.AddItem(ActionPointCost);

	FocusCost = new class'X2AbilityCost_Focus';
	FocusCost.FocusAmount = default.GhostRendFocusCost;
	FocusCost.GhostOnlyCost = true;
	Template.AbilityCosts.AddItem(FocusCost);

	//	no more cooldown for now
	//Template.AbilityCooldown = new class'X2AbilityCooldown_Rend';

	StandardMelee = new class'X2AbilityToHitCalc_StandardMelee';
	StandardMelee.bGuaranteedHit = true;
	Template.AbilityToHitCalc = StandardMelee;

	Template.AbilityTargetStyle = new class'X2AbilityTarget_MovingMelee';
	Template.TargetingMethod = class'X2TargetingMethod_MeleePath';

	Template.AbilityTriggers.AddItem(default.PlayerInputTrigger);
	Template.AbilityTriggers.AddItem(new class'X2AbilityTrigger_EndOfMove');

	// Target Conditions
	//
	Template.AbilityTargetConditions.AddItem(default.LivingHostileTargetProperty);
	Template.AbilityTargetConditions.AddItem(default.MeleeVisibilityCondition);

	// Shooter Conditions
	//
	Template.AbilityShooterConditions.AddItem(default.LivingShooterProperty);
	SkipExclusions.AddItem(class'X2StatusEffects'.default.BurningName);
	Template.AddShooterEffectExclusions(SkipExclusions);

	// Damage Effect
	//
	WeaponDamageEffect = new class'X2Effect_ApplyWeaponDamage';
	WeaponDamageEffect.DamageTypes.AddItem('Melee');
	Template.AddTargetEffect(WeaponDamageEffect);

	//	check for stun + knockback chance
	UnitValueEffect = new class'X2Effect_SetUnitValue';
	UnitValueEffect.NewValueToSet = 1;
	UnitValueEffect.UnitName = 'RendStunResult';
	UnitValueEffect.CleanupType = eCleanup_BeginTurn;
	UnitValueEffect.ApplyChanceFn = RendStun_ApplyChanceCheck;
	Template.AddTargetEffect(UnitValueEffect);

	//	apply stun + knockback if successful
	UnitValueCondition = new class'X2Condition_UnitValue';
	UnitValueCondition.AddCheckValue('RendStunResult', 1);

	StunnedEffect = class'X2StatusEffects'.static.CreateStunnedStatusEffect(2, 100, false);
	StunnedEffect.bRemoveWhenSourceDies = false;
	StunnedEffect.TargetConditions.AddItem(UnitValueCondition);
	Template.AddTargetEffect(StunnedEffect);
	
	KnockbackEffect = new class'X2Effect_Knockback';
	KnockbackEffect.KnockbackDistance = 2;
	KnockbackEffect.OnlyOnDeath = false;
	KnockbackEffect.TargetConditions.AddItem(UnitValueCondition);
	Template.AddTargetEffect(KnockbackEffect);

	//	check for disorient chance, but only if stun + knockback failed
	UnitValueCondition = new class'X2Condition_UnitValue';
	UnitValueCondition.AddCheckValue('RendStunResult', 0);
	UnitValueEffect = new class'X2Effect_SetUnitValue';
	UnitValueEffect.NewValueToSet = 1;
	UnitValueEffect.UnitName = 'RendDisorientResult';
	UnitValueEffect.CleanupType = eCleanup_BeginTurn;
	UnitValueEffect.ApplyChanceFn = RendDisorient_ApplyChanceCheck;
	UnitValueEffect.TargetConditions.AddItem(UnitValueCondition);
	Template.AddTargetEffect(UnitValueEffect);
	
	UnitValueCondition = new class'X2Condition_UnitValue';
	UnitValueCondition.AddCheckValue('RendDisorientResult', 1);
	DisorientedEffect = class'X2StatusEffects'.static.CreateDisorientedStatusEffect(, , false);
	DisorientedEffect.TargetConditions.AddItem(UnitValueCondition);
	Template.AddTargetEffect(DisorientedEffect);

	//	remove the result values so other rends on the same turn can function properly
	UnitValueEffect = new class'X2Effect_SetUnitValue';
	UnitValueEffect.NewValueToSet = 0;
	UnitValueEffect.UnitName = 'RendStunResult';
	UnitValueEffect.CleanupType = eCleanup_BeginTurn;
	Template.AddTargetEffect(UnitValueEffect);

	UnitValueEffect = new class'X2Effect_SetUnitValue';
	UnitValueEffect.NewValueToSet = 0;
	UnitValueEffect.UnitName = 'RendDisorientResult';
	UnitValueEffect.CleanupType = eCleanup_BeginTurn;
	Template.AddTargetEffect(UnitValueEffect);

	Template.PostActivationEvents.AddItem('RendActivated');

	Template.bAllowBonusWeaponEffects = true;
	Template.bSkipMoveStop = true;

	// Voice events
	//
	Template.SourceMissSpeech = 'SwordMiss';

	Template.SuperConcealmentLoss = class'X2AbilityTemplateManager'.default.SuperConcealmentStandardShotLoss;
	Template.ChosenActivationIncreasePerUse = class'X2AbilityTemplateManager'.default.StandardShotChosenActivationIncreasePerUse;
	Template.LostSpawnIncreasePerUse = class'X2AbilityTemplateManager'.default.MeleeLostSpawnIncreasePerUse;
//BEGIN AUTOGENERATED CODE: Template Overrides 'Rend'
	Template.bSkipExitCoverWhenFiring = false;
	Template.bFrameEvenWhenUnitIsHidden = true;
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
	Template.ActivationSpeech = 'Rend';
	Template.CinescriptCameraType = "Templar_Rend";
//END AUTOGENERATED CODE: Template Overrides 'Rend'

	return Template;
}

function name RendStun_ApplyChanceCheck(const out EffectAppliedData ApplyEffectParameters, XComGameState_BaseObject kNewTargetState, XComGameState NewGameState)
{
	local XComGameState_Unit SourceUnit;
	local float TargetRoll;

	SourceUnit = XComGameState_Unit(NewGameState.GetGameStateForObjectID(ApplyEffectParameters.SourceStateObjectRef.ObjectID));
	if (SourceUnit == none)
		SourceUnit = XComGameState_Unit(`XCOMHISTORY.GetGameStateForObjectID(ApplyEffectParameters.SourceStateObjectRef.ObjectID));

	if (SourceUnit != none)
	{
		TargetRoll = SourceUnit.GetTemplarFocusLevel() * default.REND_STUN_AND_KNOCKBACK_CHANCE;
		if (`SYNC_FRAND() <= TargetRoll)
			return 'AA_Success';
	}

	return 'AA_EffectChanceFailed';
}

function name RendDisorient_ApplyChanceCheck(const out EffectAppliedData ApplyEffectParameters, XComGameState_BaseObject kNewTargetState, XComGameState NewGameState)
{
	local XComGameState_Unit SourceUnit;
	local float TargetRoll;

	SourceUnit = XComGameState_Unit(NewGameState.GetGameStateForObjectID(ApplyEffectParameters.SourceStateObjectRef.ObjectID));
	if (SourceUnit == none)
		SourceUnit = XComGameState_Unit(`XCOMHISTORY.GetGameStateForObjectID(ApplyEffectParameters.SourceStateObjectRef.ObjectID));

	if (SourceUnit != none)
	{
		TargetRoll = SourceUnit.GetTemplarFocusLevel() * default.REND_DISORIENT_CHANCE;
		if (`SYNC_FRAND() <= TargetRoll)
			return 'AA_Success';
	}

	return 'AA_EffectChanceFailed';
}

static function X2AbilityTemplate Overcharge()
{
	local X2AbilityTemplate Template;
	local X2Effect_ModifyTemplarFocus FocusEffect;
	local X2AbilityTrigger_EventListener EventListener;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'Overcharge');
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_Overcharge";
	Template.Hostility = eHostility_Neutral;
//BEGIN AUTOGENERATED CODE: Template Overrides 'Overcharge'
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
//END AUTOGENERATED CODE: Template Overrides 'Overcharge'
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_NeverShow;

	Template.AdditionalAbilities.AddItem('OverchargePassive');
	Template.PrerequisiteAbilities.AddItem('Rend');
	
	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SelfTarget;

	EventListener = new class'X2AbilityTrigger_EventListener';
	EventListener.ListenerData.Deferral = ELD_OnStateSubmitted;
	EventListener.ListenerData.EventFn = class'XComGameState_Ability'.static.TemplarRendTargetAliveListener;
	EventListener.ListenerData.EventID = 'RendActivated';
	EventListener.ListenerData.Filter = eFilter_Unit;
	Template.AbilityTriggers.AddItem(EventListener);

	//	Chance to grant focus when activating Rend if the Templar has Overcharge
	FocusEffect = new class'X2Effect_ModifyTemplarFocus';
	FocusEffect.TargetConditions.AddItem(new class'X2Condition_GhostShooter');
	FocusEffect.ApplyChance = default.OVERCHARGE_FOCUS_CHANCE;
	Template.AddShooterEffect(FocusEffect);

	Template.AbilityShooterConditions.AddItem(default.LivingShooterProperty);

	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	//  NOTE: No visualization on purpose!

	Template.bShowPostActivation = true;
	Template.bSkipFireAction = true;

	return Template;
}

static function X2AbilityTemplate OverchargePassive()
{
	local X2AbilityTemplate						Template;

	Template = PurePassive('OverchargePassive', "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_Overcharge", , 'eAbilitySource_Psionic');

	return Template;
}

static function X2AbilityTemplate ArcWave()
{
	local X2AbilityTemplate					Template;
	local X2AbilityMultiTarget_Cone			ConeMultiTarget;

	Template = Rend('ArcWave');
	Template.OverrideAbilities.AddItem('Rend');
	Template.TargetingMethod = class'X2TargetingMethod_ArcWave';
	Template.ActionFireClass = class'X2Action_Fire_Wave';

	//	These are all handled in the editor if you want to change them!
//BEGIN AUTOGENERATED CODE: Template Overrides 'ArcWave'
	Template.bSkipMoveStop = false;
	Template.bFrameEvenWhenUnitIsHidden = true;
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
	Template.CustomFireAnim = 'FF_ArcWave_MeleeA';
	Template.CustomFireKillAnim = 'FF_ArcWave_MeleeKillA';
	Template.CustomMovingFireAnim = 'MV_ArcWave_MeleeA';
	Template.CustomMovingFireKillAnim = 'MV_ArcWave_MeleeKillA';
	Template.CustomMovingTurnLeftFireAnim = 'MV_ArcWave_RunTurn90LeftMeleeA';
	Template.CustomMovingTurnLeftFireKillAnim = 'MV_ArcWave_RunTurn90LeftMeleeKillA';
	Template.CustomMovingTurnRightFireAnim = 'MV_ArcWave_RunTurn90RightMeleeA';
	Template.CustomMovingTurnRightFireKillAnim = 'MV_ArcWave_RunTurn90RightMeleeKillA';
	Template.ActivationSpeech = 'Rend';
	Template.CinescriptCameraType = "Templar_Rend";
	Template.bSkipExitCoverWhenFiring = false;
//END AUTOGENERATED CODE: Template Overrides 'ArcWave'
	//Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_NeverShow;
	//Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_Arcwave";

	ConeMultiTarget = new class'X2AbilityMultiTarget_Cone';
	ConeMultiTarget.ConeEndDiameter = default.ArcWaveConeEndDiameterTiles * class'XComWorldData'.const.WORLD_StepSize;
	ConeMultiTarget.ConeLength = default.ArcWaveConeLengthTiles * class'XComWorldData'.const.WORLD_StepSize;
	ConeMultiTarget.fTargetRadius = Sqrt(Square(ConeMultiTarget.ConeEndDiameter / 2) + Square(ConeMultiTarget.ConeLength)) * class'XComWorldData'.const.WORLD_UNITS_TO_METERS_MULTIPLIER;
	ConeMultiTarget.bExcludeSelfAsTargetIfWithinRadius = true;
	ConeMultiTarget.bLockShooterZ = true;
	Template.AbilityMultiTargetStyle = ConeMultiTarget;

	Template.AbilityMultiTargetConditions.AddItem(default.LivingHostileUnitOnlyProperty);

	Template.AddMultiTargetEffect(new class'X2Effect_ArcWaveMultiDamage');
	
	return Template;
}

static function X2AbilityTemplate ArcWavePassive()
{
	local X2AbilityTemplate						Template;

	Template = PurePassive('ArcWavePassive', "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_Arcwave", , 'eAbilitySource_Psionic');

	Template.AdditionalAbilities.AddItem('ArcWave');
	Template.PrerequisiteAbilities.AddItem('Rend');

	return Template;
}

static function X2AbilityTemplate Momentum()
{
	local X2AbilityTemplate Template;
	local X2Effect_GrantActionPoints GrantActionPoints;
	local X2AbilityTrigger_EventListener EventListener;
	local X2Condition_UnitEffects UnitEffectsCondition;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'Momentum');
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_Momentum";
	Template.Hostility = eHostility_Neutral;
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_NeverShow;

	Template.AdditionalAbilities.AddItem('MomentumPassive');

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SelfTarget;

	EventListener = new class'X2AbilityTrigger_EventListener';
	EventListener.ListenerData.Deferral = ELD_OnStateSubmitted;
	EventListener.ListenerData.EventFn = class'XComGameState_Ability'.static.AbilityTriggerEventListener_Self;
	EventListener.ListenerData.EventID = 'RendActivated';
	EventListener.ListenerData.Filter = eFilter_Unit;
	Template.AbilityTriggers.AddItem(EventListener);

	UnitEffectsCondition = new class'X2Condition_UnitEffects';
	UnitEffectsCondition.AddExcludeEffect('Reaper', 'AA_ReaperUsed');
	Template.AbilityShooterConditions.AddItem(UnitEffectsCondition);

	Template.AbilityShooterConditions.AddItem(default.LivingShooterProperty);
	
	GrantActionPoints = new class'X2Effect_GrantActionPoints';
	GrantActionPoints.bApplyOnMiss = true;
	GrantActionPoints.NumActionPoints = 1;
	GrantActionPoints.PointType = 'Momentum';
	Template.AddShooterEffect(GrantActionPoints);

	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = TypicalAbility_BuildVisualization;

	Template.bSkipFireAction = true;
//BEGIN AUTOGENERATED CODE: Template Overrides 'Momentum'
	Template.bShowActivation = true;
	Template.bShowPostActivation = false;
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
//END AUTOGENERATED CODE: Template Overrides 'Momentum'

	return Template;
}

static function X2AbilityTemplate MomentumPassive()
{
	local X2AbilityTemplate						Template;

	Template = PurePassive('MomentumPassive', "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_Momentum", , 'eAbilitySource_Psionic');

	return Template;
}

static function X2AbilityTemplate Volt()
{
	local X2AbilityTemplate				Template;
	local X2AbilityCost_ActionPoints	ActionPointCost;
	local X2Condition_UnitProperty		TargetCondition;
	local X2Effect_ApplyWeaponDamage	DamageEffect;
	local X2Effect_ToHitModifier		HitModEffect;
	local X2Condition_AbilityProperty	AbilityCondition;
	local X2AbilityTag                  AbilityTag;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'Volt');

	Template.AbilityCosts.AddItem(new class'X2AbilityCost_Focus');

	ActionPointCost = new class'X2AbilityCost_ActionPoints';
	ActionPointCost.iNumPoints = 1;
	ActionPointCost.bConsumeAllPoints = true;
	Template.AbilityCosts.AddItem(ActionPointCost);

	Template.AbilityTargetStyle = default.SimpleSingleTarget;
	Template.AbilityMultiTargetStyle = new class'X2AbilityMultiTarget_Volt';
	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTriggers.AddItem(default.PlayerInputTrigger);

	Template.AbilityShooterConditions.AddItem(default.LivingShooterProperty);
	Template.AddShooterEffectExclusions();

	Template.AbilityTargetConditions.AddItem(default.GameplayVisibilityCondition);
	//	NOTE: visibility is NOT required for multi targets as it is required between each target (handled by multi target class)

	TargetCondition = new class'X2Condition_UnitProperty';
	TargetCondition.ExcludeAlive = false;
	TargetCondition.ExcludeDead = true;
	TargetCondition.ExcludeFriendlyToSource = true;
	TargetCondition.ExcludeHostileToSource = false;
	TargetCondition.TreatMindControlledSquadmateAsHostile = false;
	TargetCondition.FailOnNonUnits = true;
	TargetCondition.ExcludeCivilian = true;
	TargetCondition.ExcludeCosmetic = true;
	TargetCondition.ExcludeRobotic = true;
	Template.AbilityTargetConditions.AddItem(TargetCondition);
	Template.AbilityMultiTargetConditions.AddItem(TargetCondition);

	TargetCondition = new class'X2Condition_UnitProperty';
	TargetCondition.ExcludePsionic = true;
	DamageEffect = new class'X2Effect_ApplyWeaponDamage';
	DamageEffect.bIgnoreBaseDamage = true;
	DamageEffect.DamageTag = 'Volt';
	DamageEffect.bIgnoreArmor = true;
	DamageEffect.TargetConditions.AddItem(TargetCondition);
	Template.AddTargetEffect(DamageEffect);
	Template.AddMultiTargetEffect(DamageEffect);

	TargetCondition = new class'X2Condition_UnitProperty';
	TargetCondition.ExcludeNonPsionic = true;
	DamageEffect = new class'X2Effect_ApplyWeaponDamage';
	DamageEffect.bIgnoreBaseDamage = true;
	DamageEffect.DamageTag = 'Volt_Psi';
	DamageEffect.bIgnoreArmor = true;
	DamageEffect.TargetConditions.AddItem(TargetCondition);
	Template.AddTargetEffect(DamageEffect);
	Template.AddMultiTargetEffect(DamageEffect);

	HitModEffect = new class'X2Effect_ToHitModifier';
	HitModEffect.BuildPersistentEffect(2, , , , eGameRule_PlayerTurnBegin);
	HitModEffect.AddEffectHitModifier(eHit_Success, default.VoltHitMod, default.RecoilEffectName);
	HitModEffect.bApplyAsTarget = true;
	HitModEffect.bRemoveWhenTargetDies = true;
	HitModEffect.bUseSourcePlayerState = true;
	
	AbilityTag = X2AbilityTag(`XEXPANDCONTEXT.FindTag("Ability"));
	AbilityTag.ParseObj = HitModEffect;
	HitModEffect.SetDisplayInfo(ePerkBuff_Penalty, default.RecoilEffectName, `XEXPAND.ExpandString(default.RecoilEffectDesc), "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_Recoil");

	AbilityTag.ParseObj = none;
	
	AbilityCondition = new class'X2Condition_AbilityProperty';
	AbilityCondition.OwnerHasSoldierAbilities.AddItem('Reverberation');
	HitModEffect.TargetConditions.AddItem(default.LivingTargetOnlyProperty);
	HitModEffect.TargetConditions.AddItem(AbilityCondition);
	Template.AddTargetEffect(HitModEffect);
	Template.AddMultiTargetEffect(HitModEffect);

//BEGIN AUTOGENERATED CODE: Template Overrides 'Volt'
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
	Template.CustomFireAnim = 'HL_Volt';
	Template.ActivationSpeech = 'Volt';
//END AUTOGENERATED CODE: Template Overrides 'Volt'
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_AlwaysShow;
	Template.Hostility = eHostility_Offensive;
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_volt";
	Template.ShotHUDPriority = class'UIUtilities_Tactical'.const.CLASS_SQUADDIE_PRIORITY;
	Template.AbilityConfirmSound = "TacticalUI_ActivateAbility";

	Template.TargetingMethod = class'X2TargetingMethod_Volt';
	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = TypicalAbility_BuildVisualization;
	Template.ActionFireClass = class'X2Action_Fire_Volt';
	
	Template.SuperConcealmentLoss = class'X2AbilityTemplateManager'.default.SuperConcealmentStandardShotLoss;
	Template.ChosenActivationIncreasePerUse = class'X2AbilityTemplateManager'.default.StandardShotChosenActivationIncreasePerUse;
	Template.LostSpawnIncreasePerUse = class'X2AbilityTemplateManager'.default.StandardShotLostSpawnIncreasePerUse;

	Template.DamagePreviewFn = VoltDamagePreview;

	return Template;
}

function bool VoltDamagePreview(XComGameState_Ability AbilityState, StateObjectReference TargetRef, out WeaponDamageValue MinDamagePreview, out WeaponDamageValue MaxDamagePreview, out int AllowsShield)
{
	local XComGameState_Unit TargetUnit;

	TargetUnit = XComGameState_Unit(`XCOMHISTORY.GetGameStateForObjectID(TargetRef.ObjectID));
	if (TargetUnit != none)
	{
		if (TargetUnit.IsPsionic())
		{
			AbilityState.GetMyTemplate().AbilityTargetEffects[1].GetDamagePreview(TargetRef, AbilityState, false, MinDamagePreview, MaxDamagePreview, AllowsShield);
		}
		else
		{
			AbilityState.GetMyTemplate().AbilityTargetEffects[0].GetDamagePreview(TargetRef, AbilityState, false, MinDamagePreview, MaxDamagePreview, AllowsShield);
		}		
	}
	return true;
}

static function X2AbilityTemplate Reverberation()
{
	local X2AbilityTemplate						Template;

	Template = PurePassive('Reverberation', "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_Recoil", , 'eAbilitySource_Psionic');
	Template.PrerequisiteAbilities.AddItem('Volt');

	return Template;
}

static function X2AbilityTemplate Parry()
{
	local X2AbilityTemplate						Template;
	local X2Effect_Persistent                   Effect;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'Parry');

	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_NeverShow;
	Template.Hostility = eHostility_Neutral;
	Template.AdditionalAbilities.AddItem('ParryActivate');
//BEGIN AUTOGENERATED CODE: Template Overrides 'Parry'
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_parry";
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
//END AUTOGENERATED CODE: Template Overrides 'Parry'

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SelfTarget;
	Template.AbilityTriggers.AddItem(default.UnitPostBeginPlayTrigger);

	Effect = new class'X2Effect_Parry';
	Effect.BuildPersistentEffect(1, true, false);
	Effect.SetDisplayInfo(ePerkBuff_Passive, Template.LocFriendlyName, Template.GetMyHelpText(), Template.IconImage, true, , Template.AbilitySourceName);
	Template.AddTargetEffect(Effect);

	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = none;

	return Template;
}

static function X2AbilityTemplate ParryActivate()
{
	local X2AbilityTemplate						Template;
	local X2Effect_IncrementUnitValue			ParryUnitValue;
	local X2AbilityCost_ActionPoints			ActionPointCost;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'ParryActivate');

//BEGIN AUTOGENERATED CODE: Template Overrides 'ParryActivate'
	Template.bFrameEvenWhenUnitIsHidden = true;
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
//END AUTOGENERATED CODE: Template Overrides 'ParryActivate'
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_ShowIfAvailable;
	Template.Hostility = eHostility_Offensive;
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_Parry";
	Template.AbilityConfirmSound = "TacticalUI_ActivateAbility";

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SelfTarget;
	Template.AbilityTriggers.AddItem(default.PlayerInputTrigger);

	Template.AbilityShooterConditions.AddItem(default.LivingShooterProperty);
 	Template.AddShooterEffectExclusions();

	ActionPointCost = new class'X2AbilityCost_ActionPoints';
	ActionPointCost.iNumPoints = 1;
	ActionPointCost.AllowedTypes.Length = 0;
	ActionPointCost.AllowedTypes.AddItem('Momentum');
	Template.AbilityCosts.AddItem(ActionPointCost);

	ParryUnitValue = new class'X2Effect_IncrementUnitValue';
	ParryUnitValue.NewValueToSet = 1;
	ParryUnitValue.UnitName = 'Parry';
	ParryUnitValue.CleanupType = eCleanup_BeginTurn;
	Template.AddShooterEffect(ParryUnitValue);

	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = TypicalAbility_BuildVisualization;
	Template.BuildInterruptGameStateFn = TypicalAbility_BuildInterruptGameState;
	Template.bShowActivation = true;
	Template.bSkipFireAction = true;
	Template.OverrideAbilityAvailabilityFn = Parry_OverrideAbilityAvailability;

	return Template;
}

function Parry_OverrideAbilityAvailability(out AvailableAction Action, XComGameState_Ability AbilityState, XComGameState_Unit OwnerState)
{
	if (Action.AvailableCode == 'AA_Success')
	{
		if (OwnerState.ActionPoints.Length == 1 && OwnerState.ActionPoints[0] == 'Momentum')
			Action.ShotHUDPriority = class'UIUtilities_Tactical'.const.PARRY_PRIORITY;
	}
}

static function X2AbilityTemplate Amplify()
{
	local X2AbilityTemplate			Template;
	local X2Effect_Amplify			AmplifyEffect;
	local X2AbilityCost_ActionPoints	ActionPointCost;
	local X2AbilityCooldown			Cooldown;
	local X2AbilityTag				AbilityTag;
	local X2Condition_UnitEffects	EffectsCondition;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'Amplify');

//BEGIN AUTOGENERATED CODE: Template Overrides 'Amplify'
	Template.bFrameEvenWhenUnitIsHidden = true;
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
	Template.CustomFireAnim = 'HL_Lens';
	Template.ActivationSpeech = 'Amplify';
//END AUTOGENERATED CODE: Template Overrides 'Amplify'
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_AlwaysShow;
	Template.Hostility = eHostility_Offensive;
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_Amplify";
	Template.AbilityConfirmSound = "TacticalUI_ActivateAbility";

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SimpleSingleTarget;
	Template.AbilityTriggers.AddItem(default.PlayerInputTrigger);

	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = TypicalAbility_BuildVisualization;
	Template.BuildInterruptGameStateFn = TypicalAbility_BuildInterruptGameState;
	Template.bShowActivation = true;

	Template.AbilityShooterConditions.AddItem(default.LivingShooterProperty);
	Template.AddShooterEffectExclusions();

	Template.AbilityTargetConditions.AddItem(default.LivingHostileUnitOnlyProperty);
	Template.AbilityTargetConditions.AddItem(default.GameplayVisibilityCondition);

	EffectsCondition = new class'X2Condition_UnitEffects';
	EffectsCondition.AddExcludeEffect(class'X2Effect_Amplify'.default.EffectName, 'AA_AlreadyAmplified');
	Template.AbilityTargetConditions.AddItem(EffectsCondition);

	ActionPointCost = new class'X2AbilityCost_ActionPoints';
	ActionPointCost.iNumPoints = 1;
	Template.AbilityCosts.AddItem(ActionPointCost);

	Template.AbilityCosts.AddItem(new class'X2AbilityCost_Focus');
	
	Cooldown = new class'X2AbilityCooldown';
	Cooldown.iNumTurns = default.AMPLIFY_COOLDOWN;
	Template.AbilityCooldown = Cooldown;
	
	AmplifyEffect = new class'X2Effect_Amplify';
	AmplifyEffect.BuildPersistentEffect(1, true, true);
	AmplifyEffect.bRemoveWhenTargetDies = true;
	AmplifyEffect.BonusDamageMult = default.AmplifyBonusDamageMult;
	AmplifyEffect.MinBonusDamage = default.AmplifyMinBonusDamage;
	
	AbilityTag = X2AbilityTag(`XEXPANDCONTEXT.FindTag("Ability"));
	AbilityTag.ParseObj = AmplifyEffect;
	AmplifyEffect.SetDisplayInfo(ePerkBuff_Penalty, default.AmplifyEffectName, `XEXPAND.ExpandString(default.AmplifyEffectDesc), Template.IconImage, true, , Template.AbilitySourceName);

	// bsg-dforrest (7.27.17): need to clear out ParseObject
	AbilityTag.ParseObj = none;
	// bsg-dforrest (7.27.17): end

	Template.AddTargetEffect(AmplifyEffect);
	
	Template.SuperConcealmentLoss = class'X2AbilityTemplateManager'.default.SuperConcealmentStandardShotLoss;
	Template.ChosenActivationIncreasePerUse = class'X2AbilityTemplateManager'.default.StandardShotChosenActivationIncreasePerUse;
	Template.LostSpawnIncreasePerUse = class'X2AbilityTemplateManager'.default.StandardShotLostSpawnIncreasePerUse;

	return Template;
}

static function X2AbilityTemplate Pillar()
{
	local X2AbilityTemplate				Template;
	local X2AbilityTarget_Cursor		Cursor;
	local X2AbilityMultiTarget_Radius	RadiusMultiTarget;
	local X2AbilityCost_ActionPoints	ActionPointCost;
	local X2Effect_SpawnDestructible	PillarEffect;
	local X2AbilityCooldown				Cooldown;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'Pillar')

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTriggers.AddItem(default.PlayerInputTrigger);
	Template.TargetingMethod = class'X2TargetingMethod_Pillar';

	Cursor = new class'X2AbilityTarget_Cursor';
	Cursor.bRestrictToSquadsightRange = true;
	Template.AbilityTargetStyle = Cursor;

	RadiusMultiTarget = new class'X2AbilityMultiTarget_Radius';
	RadiusMultiTarget.fTargetRadius = 0.25; // small amount so it just grabs one tile
	Template.AbilityMultiTargetStyle = RadiusMultiTarget;

	ActionPointCost = new class'X2AbilityCost_ActionPoints';
	ActionPointCost.iNumPoints = 1;
	Template.AbilityCosts.AddItem(ActionPointCost);
	Template.AbilityCosts.AddItem(new class'X2AbilityCost_Focus');

	Cooldown = new class'X2AbilityCooldown';
	Cooldown.iNumTurns = default.PILLAR_COOLDOWN;
	Template.AbilityCooldown = Cooldown;

//BEGIN AUTOGENERATED CODE: Template Overrides 'Pillar'
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
	Template.CustomFireAnim = 'HL_Pillar';
	Template.ActivationSpeech = 'Pillar';
//END AUTOGENERATED CODE: Template Overrides 'Pillar'
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_AlwaysShow;
	Template.Hostility = eHostility_Defensive;
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_Pillar";
	Template.AbilityConfirmSound = "TacticalUI_ActivateAbility";
	Template.ConcealmentRule = eConceal_Never;

	Template.AbilityShooterConditions.AddItem(default.LivingShooterProperty);
	Template.AddShooterEffectExclusions();

	PillarEffect = new class'X2Effect_Pillar';
	PillarEffect.BuildPersistentEffect(1, false, true, false, eGameRule_PlayerTurnBegin);	
	PillarEffect.DestructibleArchetype = "FX_Templar_Pillar.Pillar_Destructible";
	Template.AddShooterEffect(PillarEffect);

	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = Pillar_BuildVisualization;
	
	Template.SuperConcealmentLoss = class'X2AbilityTemplateManager'.default.SuperConcealmentStandardShotLoss;
	Template.ChosenActivationIncreasePerUse = class'X2AbilityTemplateManager'.default.NonAggressiveChosenActivationIncreasePerUse;

	return Template;
}

function Pillar_BuildVisualization(XComGameState VisualizeGameState)
{
	local XComGameState_Destructible DestructibleState;
	local VisualizationActionMetadata BuildTrack;

	TypicalAbility_BuildVisualization(VisualizeGameState);

	foreach VisualizeGameState.IterateByClassType(class'XComGameState_Destructible', DestructibleState)
	{
		break;
	}
	`assert(DestructibleState != none);

	BuildTrack.StateObject_NewState = DestructibleState;
	BuildTrack.StateObject_OldState = DestructibleState;
	BuildTrack.VisualizeActor = `XCOMHISTORY.GetVisualizer(DestructibleState.ObjectID);

	//class'X2Action_WaitForAbilityEffect'.static.AddToVisualizationTree(BuildTrack, VisualizeGameState.GetContext());
	class'X2Action_ShowSpawnedDestructible'.static.AddToVisualizationTree(BuildTrack, VisualizeGameState.GetContext());
}

static function X2AbilityTemplate Channel()
{
	local X2AbilityTemplate					Template;
	local X2AbilityTrigger_EventListener	Listener;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'Channel');

//BEGIN AUTOGENERATED CODE: Template Overrides 'Channel'
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
//END AUTOGENERATED CODE: Template Overrides 'Channel'
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_NeverShow;
	Template.Hostility = eHostility_Neutral;
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_Channel";

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SelfTarget;

	Listener = new class'X2AbilityTrigger_EventListener';
	Listener.ListenerData.EventID = 'ItemLooted';
	Listener.ListenerData.Filter = eFilter_Unit;
	Listener.ListenerData.Deferral = ELD_OnStateSubmitted;
	Listener.ListenerData.EventFn = class'XComGameState_Ability'.static.ChannelLootListener;
	Template.AbilityTriggers.AddItem(Listener);

	Listener = new class'X2AbilityTrigger_EventListener';
	Listener.ListenerData.EventID = 'UnitMoveFinished';
	Listener.ListenerData.Filter = eFilter_Unit;
	Listener.ListenerData.Deferral = ELD_OnStateSubmitted;
	Listener.ListenerData.Priority = 10;
	Listener.ListenerData.EventFn = class'XComGameState_Ability'.static.ChannelMoveListener;
	Template.AbilityTriggers.AddItem(Listener);

	//	Note: this ability actually does nothing. Its listener handles a small game state change.
	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = none;

	Template.AdditionalAbilities.AddItem('ChannelPassive');

	return Template;
}

static function X2AbilityTemplate ChannelPassive()
{
	return PurePassive('ChannelPassive', "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_Channel",,'eAbilitySource_Psionic');
}

static function X2AbilityTemplate Deflect()
{
	local X2AbilityTemplate						Template;
	local X2Effect_Persistent                   Effect;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'Deflect');

	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_NeverShow;
	Template.Hostility = eHostility_Neutral;

//BEGIN AUTOGENERATED CODE: Template Overrides 'Deflect'
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_deflectshot";
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
//END AUTOGENERATED CODE: Template Overrides 'Deflect'
	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SelfTarget;
	Template.AbilityTriggers.AddItem(default.UnitPostBeginPlayTrigger);

	Effect = new class'X2Effect_Deflect';
	Effect.BuildPersistentEffect(1, true, false);
	Effect.SetDisplayInfo(ePerkBuff_Passive, Template.LocFriendlyName, Template.GetMyHelpText(), Template.IconImage, true, , Template.AbilitySourceName);
	Template.AddTargetEffect(Effect);

	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = none;

	return Template;
}

static function X2AbilityTemplate Reflect()
{
	local X2AbilityTemplate						Template;

	Template = PurePassive('Reflect', "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_ReflectShot", , 'eAbilitySource_Psionic');
	Template.PrerequisiteAbilities.AddItem('Deflect');
	Template.AdditionalAbilities.AddItem('ReflectShot');
//BEGIN AUTOGENERATED CODE: Template Overrides 'Reflect'	
	Template.CustomFireAnim = 'HL_Reflect';
//END AUTOGENERATED CODE: Template Overrides 'Reflect'

	return Template;
}

static function X2AbilityTemplate ReflectShot()
{
	local X2AbilityTemplate						Template;
	local X2AbilityToHitCalc_PercentChance		ChanceToHit;
	local X2AbilityTrigger_EventListener		EventListener;
	local X2Effect_ApplyReflectDamage			DamageEffect;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'ReflectShot');

	Template.AbilitySourceName = 'eAbilitySource_Perk';
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_NeverShow;
	Template.Hostility = eHostility_Offensive;
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_ReflectShot";

	ChanceToHit = new class'X2AbilityToHitCalc_PercentChance';
	ChanceToHit.PercentToHit = default.ReflectShotHitChance;
	Template.AbilityToHitCalc = ChanceToHit;

	EventListener = new class'X2AbilityTrigger_EventListener';
	EventListener.ListenerData.EventID = 'AbilityActivated';
	EventListener.ListenerData.Filter = eFilter_None;
	EventListener.ListenerData.Deferral = ELD_OnStateSubmitted;
	EventListener.ListenerData.EventFn = class'XComGameState_Ability'.static.TemplarReflectListener;
	Template.AbilityTriggers.AddItem(EventListener);

	Template.AbilityTargetStyle = default.SimpleSingleTarget;

	Template.AbilityShooterConditions.AddItem(default.LivingShooterProperty);
	Template.AddShooterEffectExclusions();
	Template.AbilityTargetConditions.AddItem(default.LivingHostileUnitDisallowMindControlProperty);
	Template.AbilityTargetConditions.AddItem(default.GameplayVisibilityCondition);

	DamageEffect = new class'X2Effect_ApplyReflectDamage';
	DamageEffect.EffectDamageValue.DamageType = 'Psi';
	Template.AddTargetEffect(DamageEffect);

	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = TypicalAbility_BuildVisualization;
	Template.BuildInterruptGameStateFn = TypicalAbility_BuildInterruptGameState;
	Template.MergeVisualizationFn = ReflectShotMergeVisualization;
	
	Template.SuperConcealmentLoss = class'X2AbilityTemplateManager'.default.SuperConcealmentStandardShotLoss;
	Template.LostSpawnIncreasePerUse = class'X2AbilityTemplateManager'.default.StandardShotLostSpawnIncreasePerUse;

	//BEGIN AUTOGENERATED CODE: Template Overrides 'ReflectShot'
	Template.bFrameEvenWhenUnitIsHidden = true;
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
	Template.CustomFireAnim = 'HL_ReflectFire';
	Template.CustomFireKillAnim = 'HL_ReflectFire';
	//END AUTOGENERATED CODE: Template Overrides 'ReflectShot'

	return Template;
}

function ReflectShotMergeVisualization(X2Action BuildTree, out X2Action VisualizationTree)
{
	local XComGameStateVisualizationMgr VisMgr;
	local X2Action_ExitCover SourceExitCover;
	local Array<X2Action> SourceReacts;
	local X2Action_Fire SourceFire;
	local X2Action_ExitCover TargetExitCover;
	local X2Action_Fire TargetFire;
	local X2Action_EnterCover TargetEnterCover;
	local X2Action_ApplyWeaponDamageToUnit TargetReact;
	local X2Action_MarkerTreeInsertBegin InsertHere;
	local Actor SourceUnit;
	local Actor TargetUnit;

	VisMgr = `XCOMVISUALIZATIONMGR;

	SourceFire = X2Action_Fire(VisMgr.GetNodeOfType(BuildTree, class'X2Action_Fire'));
	SourceUnit = SourceFire.Metadata.VisualizeActor;
	TargetReact = X2Action_ApplyWeaponDamageToUnit(VisMgr.GetNodeOfType(BuildTree, class'X2Action_ApplyWeaponDamageToUnit'));
	TargetUnit = TargetReact.Metadata.VisualizeActor;

	SourceExitCover = X2Action_ExitCover(VisMgr.GetNodeOfType(BuildTree, class'X2Action_ExitCover', SourceUnit));
	VisMgr.GetNodesOfType(VisualizationTree, class'X2Action_ApplyWeaponDamageToUnit', SourceReacts, SourceUnit);

	TargetExitCover = X2Action_ExitCover(VisMgr.GetNodeOfType(VisualizationTree, class'X2Action_ExitCover', TargetUnit));
	TargetFire = X2Action_Fire(VisMgr.GetNodeOfType(VisualizationTree, class'X2Action_Fire', TargetUnit));
	TargetEnterCover = X2Action_EnterCover(VisMgr.GetNodeOfType(VisualizationTree, class'X2Action_EnterCover', TargetUnit));

	// Jwats: First let's link up the start of our trees
	InsertHere = X2Action_MarkerTreeInsertBegin(VisMgr.GetNodeOfType(VisualizationTree, class'X2Action_MarkerTreeInsertBegin'));
	VisMgr.ConnectAction(BuildTree, VisualizationTree, false, InsertHere);

	// Jwats: Now Make the Exit Covers happen at the same time
	VisMgr.ConnectAction(SourceExitCover, VisualizationTree, false, , TargetExitCover.ParentActions);
	VisMgr.ConnectAction(TargetExitCover, VisualizationTree, false, , SourceExitCover.ParentActions);

	// Jwats: Make the Target Fire wait for both exit covers
	VisMgr.ConnectAction(TargetFire, VisualizationTree, false, SourceExitCover);

	// Jwats: The Target needs to wait to enter cover until after the attack
	VisMgr.ConnectAction(TargetEnterCover, VisualizationTree, false, TargetReact);

	// Jwats: Now the Source fire should wait for the hit react
	VisMgr.ConnectAction(SourceFire, VisualizationTree, false, , SourceReacts);

	// Jwats: Perk Start might need to be moved into a different place.  But Jameson isn't here to tell me where he wants it
}

static function X2AbilityTemplate TemplarInvert()
{
	local X2AbilityTemplate			Template;
	local X2AbilityCooldown			Cooldown;
	local X2AbilityCost_ActionPoints	ActionPointCost;
	local X2Condition_UnitProperty	UnitCondition;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'TemplarInvert');

//BEGIN AUTOGENERATED CODE: Template Overrides 'TemplarInvert'
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
	Template.CustomFireAnim = 'HL_ExchangeStart';
	Template.ActivationSpeech = 'Invert';
	Template.CinescriptCameraType = "Templar_Invert";
//END AUTOGENERATED CODE: Template Overrides 'TemplarInvert'
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_AlwaysShow;
	Template.Hostility = eHostility_Offensive;
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_Invert";
	Template.AbilityConfirmSound = "TacticalUI_ActivateAbility";

	Cooldown = new class'X2AbilityCooldown';
	Cooldown.iNumTurns = default.INVERT_COOLDOWN;
	Template.AbilityCooldown = Cooldown;

	Template.AbilityCosts.AddItem(new class'X2AbilityCost_Focus');

	ActionPointCost = new class'X2AbilityCost_ActionPoints';
	ActionPointCost.iNumPoints = 1;
	ActionPointCost.bConsumeAllPoints = false;
	Template.AbilityCosts.AddItem(ActionPointCost);

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SimpleSingleTarget;
	Template.AbilityTriggers.AddItem(default.PlayerInputTrigger);

	Template.AbilityShooterConditions.AddItem(default.LivingShooterProperty);
	Template.AddShooterEffectExclusions();
	Template.AbilityTargetConditions.AddItem(default.GameplayVisibilityCondition);

	UnitCondition = new class'X2Condition_UnitProperty';
	UnitCondition.ExcludeAlive = false;
	UnitCondition.ExcludeDead = true;
	UnitCondition.ExcludeFriendlyToSource = true;
	UnitCondition.ExcludeHostileToSource = false;
	UnitCondition.TreatMindControlledSquadmateAsHostile = false;
	UnitCondition.FailOnNonUnits = true;
	UnitCondition.ExcludeLargeUnits = true;
	UnitCondition.ExcludeTurret = true;
	Template.AbilityTargetConditions.AddItem(UnitCondition);
	Template.AbilityTargetConditions.AddItem(InvertAndExchangeEffectsCondition());

	Template.BuildNewGameStateFn = InvertAndExchange_BuildGameState;
	Template.BuildVisualizationFn = InvertAndExchange_BuildVisualization;
	Template.ModifyNewContextFn = InvertAndExchange_ModifyActivatedAbilityContext;
	
	Template.ChosenActivationIncreasePerUse = class'X2AbilityTemplateManager'.default.NonAggressiveChosenActivationIncreasePerUse;
	
	return Template;
}

static simulated function InvertAndExchange_ModifyActivatedAbilityContext(XComGameStateContext Context)
{
	local XComGameState_Unit UnitState, TargetUnit;
	local XComGameStateContext_Ability AbilityContext;
	local XComGameStateHistory History;
	local PathPoint NextPoint, EmptyPoint;
	local PathingInputData InputData, EmptyData;
	local XComWorldData World;
	local vector NewLocation;
	local TTile ShooterDesiredLoc;
	local TTile TargetDesiredLoc;

	History = `XCOMHISTORY;
	World = `XWORLD;

	AbilityContext = XComGameStateContext_Ability(Context);
	UnitState = XComGameState_Unit(History.GetGameStateForObjectID(AbilityContext.InputContext.SourceObject.ObjectID));
	TargetUnit = XComGameState_Unit(History.GetGameStateForObjectID(AbilityContext.InputContext.PrimaryTarget.ObjectID));

	ShooterDesiredLoc = TargetUnit.TileLocation;
	TargetDesiredLoc = UnitState.TileLocation;

	ShooterDesiredLoc.Z = World.GetFloorTileZ(ShooterDesiredLoc, true);
	TargetDesiredLoc.Z = World.GetFloorTileZ(TargetDesiredLoc, true);

	// Build the MovementData for the path
	// First position is the current location
	InputData.MovementTiles.AddItem(UnitState.TileLocation);

	NextPoint.Position = World.GetPositionFromTileCoordinates(UnitState.TileLocation);
	NextPoint.Traversal = eTraversal_Teleport;
	NextPoint.PathTileIndex = 0;
	InputData.MovementData.AddItem(NextPoint);

	// Second position is the target unit location on the floor
	NewLocation = World.GetPositionFromTileCoordinates(ShooterDesiredLoc);

	NextPoint = EmptyPoint;
	NextPoint.Position = NewLocation;
	NextPoint.Traversal = eTraversal_Landing;
	NextPoint.PathTileIndex = 1;
	InputData.MovementData.AddItem(NextPoint);
	InputData.MovementTiles.AddItem(ShooterDesiredLoc);

	//Now add the path to the input context
	InputData.MovingUnitRef = UnitState.GetReference();
	AbilityContext.InputContext.MovementPaths.AddItem(InputData);

	// Jwats: Reset the InputData
	InputData = EmptyData;

	//	Build the MovementData for the target's path
	// First position is the current location
	InputData.MovementTiles.AddItem(TargetUnit.TileLocation);

	NextPoint.Position = World.GetPositionFromTileCoordinates(TargetUnit.TileLocation);
	NextPoint.Traversal = eTraversal_Teleport;
	NextPoint.PathTileIndex = 0;
	InputData.MovementData.AddItem(NextPoint);

	// Second position is the source unit location
	NewLocation = World.GetPositionFromTileCoordinates(TargetDesiredLoc);

	NextPoint = EmptyPoint;
	NextPoint.Position = NewLocation;
	NextPoint.Traversal = eTraversal_Landing;
	NextPoint.PathTileIndex = 1;
	InputData.MovementData.AddItem(NextPoint);
	InputData.MovementTiles.AddItem(TargetDesiredLoc);

	//Now add the path to the input context
	InputData.MovingUnitRef = TargetUnit.GetReference();
	AbilityContext.InputContext.MovementPaths.AddItem(InputData);
}

static simulated function XComGameState InvertAndExchange_BuildGameState(XComGameStateContext Context)
{
	local XComGameStateContext_Ability AbilityContext;
	local XComGameState	NewGameState;
	local XComGameState_Unit ShooterUnit, TargetUnit;
	local XComGameState_Ability AbilityState;
	local XComGameState_Item WeaponState;
	local X2EventManager EventManager;
	local TTile ShooterDesiredLoc;
	local TTile TargetDesiredLoc;
	local XComWorldData WorldData;

	WorldData = `XWORLD;

	NewGameState = `XCOMHISTORY.CreateNewGameState(true, Context);
	AbilityContext = XComGameStateContext_Ability(NewGameState.GetContext());

	ShooterUnit = XComGameState_Unit(NewGameState.ModifyStateObject(class'XComGameState_Unit', AbilityContext.InputContext.SourceObject.ObjectID));
	TargetUnit = XComGameState_Unit(NewGameState.ModifyStateObject(class'XComGameState_Unit', AbilityContext.InputContext.PrimaryTarget.ObjectID));
	AbilityState = XComGameState_Ability(NewGameState.ModifyStateObject(class'XComGameState_Ability', AbilityContext.InputContext.AbilityRef.ObjectID));
	if (AbilityContext.InputContext.ItemObject.ObjectID > 0)
	{
		WeaponState = XComGameState_Item(NewGameState.ModifyStateObject(class'XComGameState_Item', AbilityContext.InputContext.ItemObject.ObjectID));
	}
	ShooterDesiredLoc = TargetUnit.TileLocation;
	TargetDesiredLoc = ShooterUnit.TileLocation;

	ShooterDesiredLoc.Z = WorldData.GetFloorTileZ(ShooterDesiredLoc, true);
	TargetDesiredLoc.Z = WorldData.GetFloorTileZ(TargetDesiredLoc, true);

	ShooterUnit.SetVisibilityLocation(ShooterDesiredLoc);
	TargetUnit.SetVisibilityLocation(TargetDesiredLoc);

	EventManager = `XEVENTMGR;
	EventManager.TriggerEvent('ObjectMoved', ShooterUnit, ShooterUnit, NewGameState);
	EventManager.TriggerEvent('UnitMoveFinished', ShooterUnit, ShooterUnit, NewGameState);
	EventManager.TriggerEvent('ObjectMoved', TargetUnit, TargetUnit, NewGameState);
	EventManager.TriggerEvent('UnitMoveFinished', TargetUnit, TargetUnit, NewGameState);
	
	AbilityState.GetMyTemplate().ApplyCost(AbilityContext, AbilityState, ShooterUnit, WeaponState, NewGameState);

	return NewGameState;
}

simulated function InvertAndExchange_BuildVisualization(XComGameState VisualizeGameState)
{
	local XComGameStateHistory History;
	local XComGameStateContext_Ability  AbilityContext;
	local StateObjectReference InteractingUnitRef;
	local VisualizationActionMetadata EmptyTrack, BuildTrack;
	local X2Action_MoveVisibleTeleport CasterTeleport, TargetTeleport;
	local XComGameStateVisualizationMgr VisMgr;
	local X2Action_MoveBegin CasterMoveBegin, TargetMoveBegin;
	local X2Action_MoveEnd CasterMoveEnd, TargetMoveEnd;

	History = `XCOMHISTORY;
	VisMgr = `XCOMVISUALIZATIONMGR;

	AbilityContext = XComGameStateContext_Ability(VisualizeGameState.GetContext());
	InteractingUnitRef = AbilityContext.InputContext.SourceObject;

	//****************************************************************************************
	//Configure the visualization track for the source
	//****************************************************************************************
	BuildTrack = EmptyTrack;
	BuildTrack.StateObject_OldState = History.GetGameStateForObjectID(InteractingUnitRef.ObjectID, eReturnType_Reference, VisualizeGameState.HistoryIndex - 1);
	BuildTrack.StateObject_NewState = VisualizeGameState.GetGameStateForObjectID(InteractingUnitRef.ObjectID);
	BuildTrack.VisualizeActor = History.GetVisualizer(InteractingUnitRef.ObjectID);

	// move action
	class'X2VisualizerHelpers'.static.ParsePath(AbilityContext, BuildTrack);

	CasterTeleport = X2Action_MoveVisibleTeleport(VisMgr.GetNodeOfType(VisMgr.BuildVisTree, class'X2Action_MoveVisibleTeleport', BuildTrack.VisualizeActor));
	CasterTeleport.ParamsStart.AnimName = 'HL_ExchangeStart';
	CasterTeleport.ParamsStop.AnimName = 'HL_ExchangeEnd';
	CasterMoveBegin = X2Action_MoveBegin(VisMgr.GetNodeOfType(VisMgr.BuildVisTree, class'X2Action_MoveBegin', BuildTrack.VisualizeActor));
	CasterMoveEnd = X2Action_MoveEnd(VisMgr.GetNodeOfType(VisMgr.BuildVisTree, class'X2Action_MoveEnd', BuildTrack.VisualizeActor));

	//****************************************************************************************
	//Configure the visualization track for the target
	//****************************************************************************************
	InteractingUnitRef = AbilityContext.InputContext.PrimaryTarget;
	BuildTrack = EmptyTrack;
	BuildTrack.StateObject_OldState = History.GetGameStateForObjectID(InteractingUnitRef.ObjectID, eReturnType_Reference, VisualizeGameState.HistoryIndex - 1);
	BuildTrack.StateObject_NewState = VisualizeGameState.GetGameStateForObjectID(InteractingUnitRef.ObjectID);
	BuildTrack.VisualizeActor = History.GetVisualizer(InteractingUnitRef.ObjectID);
	
	// move action
	class'X2VisualizerHelpers'.static.ParsePath(AbilityContext, BuildTrack);

	TargetTeleport = X2Action_MoveVisibleTeleport(VisMgr.GetNodeOfType(VisMgr.BuildVisTree, class'X2Action_MoveVisibleTeleport', BuildTrack.VisualizeActor));
	TargetTeleport.PlayAnim = false;
	TargetTeleport.WaitForTeleportEvent = true;
	TargetMoveBegin = X2Action_MoveBegin(VisMgr.GetNodeOfType(VisMgr.BuildVisTree, class'X2Action_MoveBegin', BuildTrack.VisualizeActor));
	TargetMoveEnd = X2Action_MoveEnd(VisMgr.GetNodeOfType(VisMgr.BuildVisTree, class'X2Action_MoveEnd', BuildTrack.VisualizeActor));

	// Jwats: Sync the move begins
	VisMgr.DisconnectAction(TargetMoveBegin);
	VisMgr.ConnectAction(TargetMoveBegin, VisMgr.BuildVisTree, false, , CasterMoveBegin.ParentActions);

	// Jwats: Sync the teleports
	VisMgr.ConnectAction(TargetTeleport, VisMgr.BuildVisTree, false, CasterTeleport);

	// Jwats: Sync the MoveEnds
	VisMgr.ConnectAction(TargetMoveEnd, VisMgr.BuildVisTree, false, CasterMoveEnd);
}

static function X2AbilityTemplate TemplarExchange()
{
	local X2AbilityTemplate			Template;
	local X2AbilityCooldown			Cooldown;
	local X2Condition_UnitProperty	SquadmateCondition;
	local X2AbilityCost_ActionPoints	ActionPointCost;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'TemplarExchange');

//BEGIN AUTOGENERATED CODE: Template Overrides 'TemplarExchange'
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
	Template.CustomFireAnim = 'HL_ExchangeStart';
	Template.ActivationSpeech = 'Exchange';
	Template.CinescriptCameraType = "Templar_Exchange";
//END AUTOGENERATED CODE: Template Overrides 'TemplarExchange'
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_AlwaysShow;
	Template.Hostility = eHostility_Neutral;
	Template.ConcealmentRule = eConceal_Never;
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_Exchange";
	Template.AbilityConfirmSound = "TacticalUI_ActivateAbility";

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SimpleSingleTarget;
	Template.AbilityTriggers.AddItem(default.PlayerInputTrigger);

	Cooldown = new class'X2AbilityCooldown';
	Cooldown.iNumTurns = default.EXCHANGE_COOLDOWN;
	Template.AbilityCooldown = Cooldown;

	Template.AbilityCosts.AddItem(new class'X2AbilityCost_Focus');
	
	ActionPointCost = new class'X2AbilityCost_ActionPoints';
	ActionPointCost.iNumPoints = 1;
	ActionPointCost.bConsumeAllPoints = false;
	Template.AbilityCosts.AddItem(ActionPointCost);

	Template.AbilityShooterConditions.AddItem(default.LivingShooterProperty);
	Template.AddShooterEffectExclusions();
	
	SquadmateCondition = new class'X2Condition_UnitProperty';
	SquadmateCondition.ExcludeFriendlyToSource = false;
	SquadmateCondition.ExcludeHostileToSource = true;
	SquadmateCondition.ExcludeDead = true;
	SquadmateCondition.ExcludeAlive = false;
	SquadmateCondition.FailOnNonUnits = true;
	SquadmateCondition.RequireSquadmates = true;
	SquadmateCondition.ExcludeLargeUnits = true;
	SquadmateCondition.TreatMindControlledSquadmateAsHostile = false;
	Template.AbilityTargetConditions.AddItem(SquadmateCondition);
	Template.AbilityTargetConditions.AddItem(InvertAndExchangeEffectsCondition());
	
	Template.BuildNewGameStateFn = InvertAndExchange_BuildGameState;
	Template.BuildVisualizationFn = InvertAndExchange_BuildVisualization;
	Template.ModifyNewContextFn = InvertAndExchange_ModifyActivatedAbilityContext;
	
	Template.ChosenActivationIncreasePerUse = class'X2AbilityTemplateManager'.default.NonAggressiveChosenActivationIncreasePerUse;
	
	return Template;
}

static function X2Condition_UnitEffects InvertAndExchangeEffectsCondition()
{
	local X2Condition_UnitEffects ExcludeEffects;

	ExcludeEffects = new class'X2Condition_UnitEffects';
	ExcludeEffects.AddExcludeEffect(class'X2AbilityTemplateManager'.default.BoundName, 'AA_UnitIsBound');
	ExcludeEffects.AddExcludeEffect(class'X2Ability_CarryUnit'.default.CarryUnitEffectName, 'AA_CarryingUnit');
	ExcludeEffects.AddExcludeEffect(class'X2Effect_PersistentVoidConduit'.default.EffectName, 'AA_UnitIsBound');
	ExcludeEffects.AddExcludeEffect(class'X2Ability_ChryssalidCocoon'.default.GestationStage1EffectName, 'AA_UnitHasCocoonOnIt');
	ExcludeEffects.AddExcludeEffect(class'X2Ability_ChryssalidCocoon'.default.GestationStage2EffectName, 'AA_UnitHasCocoonOnIt');
	ExcludeEffects.AddExcludeEffect('IcarusDropGrabbeeEffect_Sustained', 'AA_UnitIsBound');
	ExcludeEffects.AddExcludeEffect('IcarusDropGrabberEffect', 'AA_UnitIsBound');

	return ExcludeEffects;
}

static function X2AbilityTemplate DeepFocus()
{
	return PurePassive('DeepFocus', "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_DeepFocus", , 'eAbilitySource_Psionic', false);
}

static function X2AbilityTemplate Ghost()
{
	local X2AbilityTemplate				Template;
	local X2AbilityCost_ActionPoints	ActionPointCost;
	local X2Condition_UnitValue			ValueCondition;
	local X2Condition_UnitProperty		TargetCondition;
	local X2Effect_SpawnGhost			GhostEffect;
	local X2AbilityCharges				Charges;
	local X2AbilityCost_Focus			FocusCost;
	local X2AbilityCost_Charges			ChargeCost;
	local X2Condition_UnitEffects		GhostKillCondition;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'Ghost');

//BEGIN AUTOGENERATED CODE: Template Overrides 'Ghost'
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
	Template.ActivationSpeech = 'Ghost';
	Template.CinescriptCameraType = "Templar_Ghost";
//END AUTOGENERATED CODE: Template Overrides 'Ghost'
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_HideSpecificErrors;
	Template.HideErrors.AddItem('AA_UnitIsWrongType');
	Template.Hostility = eHostility_Neutral;
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_Ghost";
	Template.AbilityConfirmSound = "TacticalUI_ActivateAbility";

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SimpleSingleTarget;
	Template.AbilityTriggers.AddItem(default.PlayerInputTrigger);

	FocusCost = new class'X2AbilityCost_Focus';
	FocusCost.FocusAmount = default.GhostFocusCost;
	Template.AbilityCosts.AddItem(FocusCost);

	Charges = new class'X2AbilityCharges';
	Charges.InitialCharges = default.GHOST_CHARGES;
	Template.AbilityCharges = Charges;

	ChargeCost = new class'X2AbilityCost_Charges';
	ChargeCost.NumCharges = 1;
	Template.AbilityCosts.AddItem(ChargeCost);

	ActionPointCost = new class'X2AbilityCost_ActionPoints';
	ActionPointCost.iNumPoints = 1;
	ActionPointCost.bConsumeAllPoints = true;
	Template.AbilityCosts.AddItem(ActionPointCost);
	
	Template.AbilityShooterConditions.AddItem(new class'X2Condition_GhostShooter');
	Template.AbilityShooterConditions.AddItem(default.LivingShooterProperty);
	Template.AddShooterEffectExclusions();

	ValueCondition = new class'X2Condition_UnitValue';
	ValueCondition.AddCheckValue(class'X2Effect_SpawnGhost'.default.SpawnedUnitValueName, 0, , , , 'AA_UnitIsImmune');
	Template.AbilityTargetConditions.AddItem(ValueCondition);

	TargetCondition = new class'X2Condition_UnitProperty';
	TargetCondition.ExcludeFriendlyToSource = false;
	TargetCondition.ExcludeHostileToSource = false;
	TargetCondition.ExcludeDead = false;
	TargetCondition.ExcludeAlive = true;
	TargetCondition.FailOnNonUnits = true;
	TargetCondition.ExcludeRobotic = true;
	TargetCondition.ExcludeAlien = true;
	TargetCondition.RequireWithinRange = true;
	Template.AbilityTargetConditions.AddItem(TargetCondition);
	Template.AbilityTargetConditions.AddItem(default.GameplayVisibilityCondition);

	// Jwats: Dead ghosts can't be used to create more ghosts
	GhostKillCondition = new class'X2Condition_UnitEffects';
	GhostKillCondition.AddExcludeEffect('GhostKillUnit', 'AA_DuplicateEffectIgnored');
	Template.AbilityTargetConditions.AddItem(GhostKillCondition);

	GhostEffect = new class'X2Effect_SpawnGhost';
	GhostEffect.BuildPersistentEffect(1, true, true);
	Template.AddTargetEffect(GhostEffect);

	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = Ghost_BuildVisualization;
	
	Template.ChosenActivationIncreasePerUse = class'X2AbilityTemplateManager'.default.NonAggressiveChosenActivationIncreasePerUse;
	
	return Template;
}

simulated function Ghost_BuildVisualization(XComGameState VisualizeGameState)
{
	local XComGameStateHistory History;
	local XComGameStateContext_Ability Context;
	local StateObjectReference InteractingUnitRef;
	local X2Action_PlayAnimation AnimationAction;

	local VisualizationActionMetadata EmptyTrack;
	local VisualizationActionMetadata ActionMetadata, GhostTrack, DeadUnitTrack;
	local XComGameState_Unit SpawnedUnit, DeadUnit, TemplarUnit;
	local UnitValue SpawnedUnitValue;
	local X2Effect_SpawnGhost SpawnGhostEffect;
	local Array<X2Action> ParentActions;

	History = `XCOMHISTORY;

	Context = XComGameStateContext_Ability(VisualizeGameState.GetContext());
	InteractingUnitRef = Context.InputContext.SourceObject;

	//Configure the visualization track for the shooter
	//****************************************************************************************
	ActionMetadata = EmptyTrack;
	ActionMetadata.StateObject_OldState = History.GetGameStateForObjectID(InteractingUnitRef.ObjectID, eReturnType_Reference, VisualizeGameState.HistoryIndex - 1);
	ActionMetadata.StateObject_NewState = VisualizeGameState.GetGameStateForObjectID(InteractingUnitRef.ObjectID);
	ActionMetadata.VisualizeActor = History.GetVisualizer(InteractingUnitRef.ObjectID);

	TemplarUnit = XComGameState_Unit(ActionMetadata.StateObject_NewState);

	if (TemplarUnit != none)
	{
		// Configure the visualization track for the Target Unit
		//******************************************************************************************
		DeadUnitTrack.StateObject_OldState = History.GetGameStateForObjectID(Context.InputContext.PrimaryTarget.ObjectID, eReturnType_Reference, VisualizeGameState.HistoryIndex);
		DeadUnitTrack.StateObject_NewState = DeadUnitTrack.StateObject_OldState;
		DeadUnit = XComGameState_Unit(VisualizeGameState.GetGameStateForObjectID(Context.InputContext.PrimaryTarget.ObjectID));
		`assert(DeadUnit != none);
		DeadUnitTrack.VisualizeActor = History.GetVisualizer(DeadUnit.ObjectID);

		DeadUnit.GetUnitValue(class'X2Effect_SpawnGhost'.default.SpawnedUnitValueName, SpawnedUnitValue);

		// Configure the visualization track for the Ghost
		//******************************************************************************************
		GhostTrack = EmptyTrack;
		GhostTrack.StateObject_OldState = History.GetGameStateForObjectID(SpawnedUnitValue.fValue, eReturnType_Reference, VisualizeGameState.HistoryIndex);
		GhostTrack.StateObject_NewState = GhostTrack.StateObject_OldState;
		SpawnedUnit = XComGameState_Unit(GhostTrack.StateObject_NewState);
		`assert(SpawnedUnit != none);
		GhostTrack.VisualizeActor = History.GetVisualizer(SpawnedUnit.ObjectID);

		SpawnGhostEffect = X2Effect_SpawnGhost(Context.ResultContext.TargetEffectResults.Effects[0]);

		if (SpawnGhostEffect == none)
		{
			`RedScreenOnce("Ghost_BuildVisualization missing X2Effect_SpawnGhost - @jbouscher @gameplay");
			return;
		}

		// Build the tracks
		class'X2Action_ExitCover'.static.AddToVisualizationTree(ActionMetadata, Context, false, ActionMetadata.LastActionAdded);
		class'X2Action_AbilityPerkStart'.static.AddToVisualizationTree(ActionMetadata, Context, false, ActionMetadata.LastActionAdded);

		AnimationAction = X2Action_PlayAnimation(class'X2Action_PlayAnimation'.static.AddToVisualizationTree(ActionMetadata, Context, false, ActionMetadata.LastActionAdded));
		AnimationAction.Params.AnimName = 'HL_Ghost';

		class'X2Action_EnterCover'.static.AddToVisualizationTree(ActionMetadata, Context, false, ActionMetadata.LastActionAdded);

		class'X2Action_WaitForAbilityEffect'.static.AddToVisualizationTree(GhostTrack, Context, false, AnimationAction);
		SpawnGhostEffect.AddSpawnVisualizationsToTracks(Context, SpawnedUnit, GhostTrack, DeadUnit, DeadUnitTrack);

		if( ActionMetadata.LastActionAdded != None )
		{
			ParentActions.AddItem(ActionMetadata.LastActionAdded);
		}
		
		if( GhostTrack.LastActionAdded != None )
		{
			ParentActions.AddItem(GhostTrack.LastActionAdded);
		}
		
		class'X2Action_AbilityPerkEnd'.static.AddToVisualizationTree(ActionMetadata, Context, false, , ParentActions);
	}
}

static function X2AbilityTemplate GhostKill()
{
	local X2AbilityTemplate					Template;
	local X2Effect_KillUnit					KillUnitEffect;
	local X2AbilityTrigger_EventListener	EventTrigger;
	local X2Condition_UnitEffects			GhostKillCondition;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'GhostKill');

//BEGIN AUTOGENERATED CODE: Template Overrides 'GhostKill'
	Template.bFrameEvenWhenUnitIsHidden = true;
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
//END AUTOGENERATED CODE: Template Overrides 'GhostKill'
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_NeverShow;

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SelfTarget;

	GhostKillCondition = new class'X2Condition_UnitEffects';
	GhostKillCondition.AddExcludeEffect('GhostKillUnit', 'AA_DuplicateEffectIgnored');
	Template.AbilityTargetConditions.AddItem(GhostKillCondition);

	// Jwats: Trigger if the ghost decides he wants to die (out of focus)
	EventTrigger = new class'X2AbilityTrigger_EventListener';
	EventTrigger.ListenerData.Deferral = ELD_OnStateSubmitted;
	EventTrigger.ListenerData.EventID = 'GhostKill';
	EventTrigger.ListenerData.Filter = eFilter_Unit;
	EventTrigger.ListenerData.EventFn = class'XComGameState_Ability'.static.AbilityTriggerEventListener_Self;
	Template.AbilityTriggers.AddItem(EventTrigger);

	// Jwats: Make sure we trigger when we die
	EventTrigger = new class'X2AbilityTrigger_EventListener';
	EventTrigger.ListenerData.Deferral = ELD_OnStateSubmitted;
	EventTrigger.ListenerData.EventID = 'UnitDied';
	EventTrigger.ListenerData.Filter = eFilter_Unit;
	EventTrigger.ListenerData.EventFn = class'XComGameState_Ability'.static.AbilityTriggerEventListener_Self;
	Template.AbilityTriggers.AddItem(EventTrigger);

	// Jwats: Also trigger if our source unit dies
	EventTrigger = new class'X2AbilityTrigger_EventListener';
	EventTrigger.ListenerData.Deferral = ELD_OnStateSubmitted;
	EventTrigger.ListenerData.EventID = 'UnitDied';
	EventTrigger.ListenerData.EventFn = class'XComGameState_Ability'.static.TemplarDeathRemoveGhostsListener;
	Template.AbilityTriggers.AddItem(EventTrigger);

	//	jbouscher: trigger if the source is removed from play (e.g. evacs)
	EventTrigger = new class'X2AbilityTrigger_EventListener';
	EventTrigger.ListenerData.Deferral = ELD_OnStateSubmitted;
	EventTrigger.ListenerData.EventID = 'UnitRemovedFromPlay';
	EventTrigger.ListenerData.EventFn = class'XComGameState_Ability'.static.TemplarDeathRemoveGhostsListener;
	Template.AbilityTriggers.AddItem(EventTrigger);

	KillUnitEffect = new class'X2Effect_KillUnit';
	KillUnitEffect.bHideDeathWorldMessage = true;
	KillUnitEffect.BuildPersistentEffect(1, true, false);
	KillUnitEffect.EffectName = 'GhostKillUnit';
	KillUnitEffect.TargetConditions.AddItem(default.LivingTargetOnlyProperty);
	Template.AddTargetEffect(KillUnitEffect);

	Template.BuildNewGameStateFn = GhostKillBuildGameState;
	Template.BuildVisualizationFn = GhostKillBuildVisualization;
	Template.bSkipFireAction = true;

	Template.ChosenActivationIncreasePerUse = class'X2AbilityTemplateManager'.default.NonAggressiveChosenActivationIncreasePerUse;

	return Template;
}

static function XComGameState GhostKillBuildGameState(XComGameStateContext Context)
{
	local XComGameStateContext_Ability AbilityContext;
	local XComGameState_Unit GhostUnit;
	local XComGameState NewGameState;

	NewGameState = TypicalAbility_BuildGameState(Context);
	
	AbilityContext = XComGameStateContext_Ability(Context);
	GhostUnit = XComGameState_Unit(`XCOMHISTORY.GetGameStateForObjectID(AbilityContext.InputContext.PrimaryTarget.ObjectID));

	`XEVENTMGR.TriggerEvent('UnitRemovedFromPlay', GhostUnit, GhostUnit, NewGameState);

	return NewGameState;
}

simulated function GhostKillBuildVisualization(XComGameState VisualizeGameState)
{
	local XComGameStateVisualizationMgr VisualizationMgr;
	local XComGameStateHistory History;
	local XComGameStateContext_Ability AbilityContext;
	local XGUnit UnitVisualizer;
	local X2Action_Death DeathAction;
	local X2Action_Delay DelayAction;
	local VisualizationActionMetadata ActionMetadata;
	local X2Action_PlayAdditiveAnim AdditiveAction;
	local XComGameState_Unit GhostState;

	History = `XCOMHISTORY;
	VisualizationMgr = `XCOMVISUALIZATIONMGR;

	TypicalAbility_BuildVisualization(VisualizeGameState);

	AbilityContext = XComGameStateContext_Ability(VisualizeGameState.GetContext());
	UnitVisualizer = XGUnit(History.GetVisualizer(AbilityContext.InputContext.PrimaryTarget.ObjectID));
	GhostState = XComGameState_Unit(History.GetGameStateForObjectID(AbilityContext.InputContext.PrimaryTarget.ObjectID, eReturnType_Reference, VisualizeGameState.HistoryIndex));
	DeathAction = X2Action_Death(VisualizationMgr.GetNodeOfType(VisualizationMgr.BuildVisTree, class'X2Action_Death', UnitVisualizer));
	
	if( DeathAction == None )
	{
		DeathAction = X2Action_Death(VisualizationMgr.GetNodeOfType(VisualizationMgr.VisualizationTree, class'X2Action_Death', UnitVisualizer));
	}
	
	if (DeathAction != None)
	{
		ActionMetadata = DeathAction.Metadata;
		if ( GhostState.GetTemplarFocusLevel() == 0)
		{
			DeathAction.bForceMeleeDeath = true;
		}
	}
	else
	{
		ActionMetadata.StateObjectRef = AbilityContext.InputContext.PrimaryTarget;
		ActionMetadata.StateObject_OldState = History.GetGameStateForObjectID(UnitVisualizer.ObjectID, eReturnType_Reference, VisualizeGameState.HistoryIndex - 1);
		ActionMetadata.StateObject_NewState = VisualizeGameState.GetGameStateForObjectID(UnitVisualizer.ObjectID);
		ActionMetadata.VisualizeActor = UnitVisualizer;
	}

	// Jwats: Play the additive right before death (If it happens during/after death then it will be halted)
	AdditiveAction = X2Action_PlayAdditiveAnim(class'X2Action_PlayAdditiveAnim'.static.AddToVisualizationTree(ActionMetadata, AbilityContext, true, , DeathAction.ParentActions));
	AdditiveAction.AdditiveAnimParams.AnimName = 'ADD_EndGhost';
	AdditiveAction.AdditiveAnimParams.BlendTime = 0.0f;

	DelayAction = X2Action_Delay(class'X2Action_Delay'.static.AddToVisualizationTree(ActionMetadata, AbilityContext, true, DeathAction));
	DelayAction.Duration = 4.0f;
}

static function X2AbilityTemplate GhostInit()
{
	local X2AbilityTemplate Template;
	local X2Effect_DamageImmunity DamageImmunity;
	local X2Effect_GhostStuff GhostEffect;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'GhostInit');

	Template.AbilitySourceName = 'eAbilitySource_Perk';
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_NeverShow;
	Template.Hostility = eHostility_Neutral;

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SelfTarget;
	Template.AbilityTriggers.AddItem(default.UnitPostBeginPlayTrigger);

	// Build the immunities
	DamageImmunity = new class'X2Effect_DamageImmunity';
	DamageImmunity.BuildPersistentEffect(1, true, false, true);
	DamageImmunity.ImmuneTypes.AddItem(class'X2Item_DefaultDamageTypes'.default.ParthenogenicPoisonType);
	DamageImmunity.ImmuneTypes.AddItem('unconscious');
	DamageImmunity.ImmuneTypes.AddItem('bleeding');
	DamageImmunity.EffectName = 'GhostImmunity';
	Template.AddTargetEffect(DamageImmunity);

	GhostEffect = new class'X2Effect_GhostStuff';
	GhostEffect.BuildPersistentEffect(1, true, false, true);
	GhostEffect.EffectName = 'GhostStuff';
	Template.AddTargetEffect(GhostEffect);

	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;

	return Template;
}

static function X2AbilityTemplate IonicStorm()
{
	local X2AbilityTemplate						Template;
	local X2AbilityMultiTarget_Radius           MultiTargetRadius;
	local X2Effect_ApplyWeaponDamage            DamageEffect;
	local X2AbilityCost_Focus					ConsumeAllFocusCost;
	local X2Condition_UnitProperty				TargetCondition;
	local X2AbilityCost_ActionPoints			ActionPointCost;
	local X2AbilityCooldown						Cooldown;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'IonicStorm');
//BEGIN AUTOGENERATED CODE: Template Overrides 'IonicStorm'
	Template.bFrameEvenWhenUnitIsHidden = true;
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
	Template.CustomFireKillAnim = 'HL_IonicStorm';
	Template.ActivationSpeech = 'IonicStorm';
	Template.CinescriptCameraType = "Templar_IonicStorm";
//END AUTOGENERATED CODE: Template Overrides 'IonicStorm'
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_AlwaysShow;
	Template.Hostility = eHostility_Offensive;
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_IonicStorm";
	Template.AbilityConfirmSound = "TacticalUI_ActivateAbility";
	Template.bFriendlyFireWarning = false;

	ConsumeAllFocusCost = new class'X2AbilityCost_Focus';
	ConsumeAllFocusCost.FocusAmount = 1;
	ConsumeAllFocusCost.ConsumeAllFocus = true;
	Template.AbilityCosts.AddItem(ConsumeAllFocusCost);

	ActionPointCost = new class'X2AbilityCost_ActionPoints';
	ActionPointCost.iNumPoints = 1;
	ActionPointCost.bConsumeAllPoints = true;
	Template.AbilityCosts.AddItem(ActionPointCost);

	Cooldown = new class'X2AbilityCooldown';
	Cooldown.iNumTurns = default.IONICSTORM_COOLDOWN;
	Template.AbilityCooldown = Cooldown;

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = new class'X2AbilityTarget_Cursor';
	Template.AbilityTriggers.AddItem(default.PlayerInputTrigger);
	Template.TargetingMethod = class'X2TargetingMethod_PathTarget';

	MultiTargetRadius = new class'X2AbilityMultiTarget_RadiusTimesFocus';
	MultiTargetRadius.fTargetRadius = default.IONICSTORM_RADIUS_METERS;
	MultiTargetRadius.bExcludeSelfAsTargetIfWithinRadius = true;
	Template.AbilityMultiTargetStyle = MultiTargetRadius;

	Template.AddShooterEffectExclusions();
	Template.AbilityShooterConditions.AddItem(default.LivingShooterProperty);
	Template.AbilityMultiTargetConditions.AddItem(default.LivingHostileUnitOnlyProperty);

	TargetCondition = new class'X2Condition_UnitProperty';
	TargetCondition.ExcludePsionic = true;
	DamageEffect = new class'X2Effect_ApplyWeaponDamage';
	DamageEffect.bIgnoreBaseDamage = true;
	DamageEffect.DamageTag = 'IonicStorm';
	DamageEffect.bIgnoreArmor = true;
	DamageEffect.TargetConditions.AddItem(TargetCondition);
	Template.AddMultiTargetEffect(DamageEffect);

	TargetCondition = new class'X2Condition_UnitProperty';
	TargetCondition.ExcludeNonPsionic = true;
	DamageEffect = new class'X2Effect_ApplyWeaponDamage';
	DamageEffect.bIgnoreBaseDamage = true;
	DamageEffect.DamageTag = 'IonicStorm_Psi';
	DamageEffect.bIgnoreArmor = true;
	DamageEffect.TargetConditions.AddItem(TargetCondition);
	Template.AddMultiTargetEffect(DamageEffect);

	Template.BuildNewGameStateFn = TypicalMoveEndAbility_BuildGameState;
	Template.BuildInterruptGameStateFn = TypicalMoveEndAbility_BuildInterruptGameState;
	Template.BuildVisualizationFn = IonicStorm_BuildVisualization;

	Template.bSkipExitCoverWhenFiring = false;
	Template.CustomFireAnim = 'HL_IonicStorm';
	Template.DamagePreviewFn = IonicStormDamagePreview;

	Template.SuperConcealmentLoss = class'X2AbilityTemplateManager'.default.SuperConcealmentStandardShotLoss;
	Template.ChosenActivationIncreasePerUse = class'X2AbilityTemplateManager'.default.StandardShotChosenActivationIncreasePerUse;

	return Template;
}

simulated function IonicStorm_BuildVisualization(XComGameState VisualizeGameState)
{
	local XComGameStateHistory History;
	local XComGameStateVisualizationMgr VisMgr;
	local XComGameStateContext_Ability AbilityContext;
	local VisualizationActionMetadata SourceMetadata;
	local VisualizationActionMetadata ActionMetadata;
	local VisualizationActionMetadata BlankMetadata;
	local XGUnit SourceVisualizer;
	local X2Action_Fire FireAction;
	local X2Action_ExitCover ExitCoverAction;
	local StateObjectReference CurrentTarget;
	local int ScanTargets;
	local X2Action ParentAction;
	local X2Action_Delay CurrentDelayAction;
	local X2Action_ApplyWeaponDamageToUnit UnitDamageAction;
	local X2Effect CurrentEffect;
	local int ScanEffect;
	local Array<X2Action> LeafNodes;
	local X2Action_MarkerNamed JoinActions;
	local XComGameState_Effect_TemplarFocus FocusState;
	local int NumActualTargets;

	History = `XCOMHISTORY;
	VisMgr = `XCOMVISUALIZATIONMGR;

	AbilityContext = XComGameStateContext_Ability(VisualizeGameState.GetContext());

	SourceVisualizer = XGUnit(History.GetVisualizer(AbilityContext.InputContext.SourceObject.ObjectID));

	SourceMetadata.StateObject_OldState = History.GetGameStateForObjectID(SourceVisualizer.ObjectID, eReturnType_Reference, VisualizeGameState.HistoryIndex - 1);
	SourceMetadata.StateObject_NewState = VisualizeGameState.GetGameStateForObjectID(SourceVisualizer.ObjectID);
	SourceMetadata.StateObjectRef = AbilityContext.InputContext.SourceObject;
	SourceMetadata.VisualizeActor = SourceVisualizer;

	if( AbilityContext.InputContext.MovementPaths.Length > 0 )
	{
		class'X2VisualizerHelpers'.static.ParsePath(AbilityContext, SourceMetadata);
	}

	ExitCoverAction = X2Action_ExitCover(class'X2Action_ExitCover'.static.AddToVisualizationTree(SourceMetadata, AbilityContext, false, SourceMetadata.LastActionAdded));
	FireAction = X2Action_Fire(class'X2Action_Fire'.static.AddToVisualizationTree(SourceMetadata, AbilityContext, false, ExitCoverAction));
	class'X2Action_EnterCover'.static.AddToVisualizationTree(SourceMetadata, AbilityContext, false, FireAction);

	FocusState = XComGameState_Unit(SourceMetadata.StateObject_OldState).GetTemplarFocusEffectState();
	// Jwats: We care about the focus that was used to cast this ability
	FocusState = XComGameState_Effect_TemplarFocus(History.GetGameStateForObjectID(FocusState.ObjectID, eReturnType_Reference, VisualizeGameState.HistoryIndex - 1));
	NumActualTargets = AbilityContext.InputContext.MultiTargets.Length / FocusState.FocusLevel;

	ParentAction = FireAction;
	for (ScanTargets = 0; ScanTargets < AbilityContext.InputContext.MultiTargets.Length; ++ScanTargets)
	{
		CurrentTarget = AbilityContext.InputContext.MultiTargets[ScanTargets];
		ActionMetadata = BlankMetadata;

		ActionMetadata.StateObject_OldState = History.GetGameStateForObjectID(CurrentTarget.ObjectID, eReturnType_Reference, VisualizeGameState.HistoryIndex - 1);
		ActionMetadata.StateObject_NewState = VisualizeGameState.GetGameStateForObjectID(CurrentTarget.ObjectID);
		ActionMetadata.StateObjectRef = CurrentTarget;
		ActionMetadata.VisualizeActor = History.GetVisualizer(CurrentTarget.ObjectID);

		if (ScanTargets == 0)
		{
			ParentAction = class'X2Action_WaitForAbilityEffect'.static.AddToVisualizationTree(ActionMetadata, AbilityContext, false, ParentAction);
		}
		else
		{
			CurrentDelayAction = X2Action_Delay(class'X2Action_Delay'.static.AddToVisualizationTree(ActionMetadata, AbilityContext, false, ParentAction));
			CurrentDelayAction.Duration = (`SYNC_FRAND() * (IonicStormTargetMaxDelay - IonicStormTargetMinDelay)) + IonicStormTargetMinDelay;
			ParentAction = CurrentDelayAction;
		}

		UnitDamageAction = X2Action_ApplyWeaponDamageToUnit(class'X2Action_ApplyWeaponDamageToUnit'.static.AddToVisualizationTree(ActionMetadata, AbilityContext, false, ParentAction));
		for (ScanEffect = 0; ScanEffect < AbilityContext.ResultContext.MultiTargetEffectResults[ScanTargets].Effects.Length; ++ScanEffect)
		{
			if (AbilityContext.ResultContext.MultiTargetEffectResults[ScanTargets].ApplyResults[ScanEffect] == 'AA_Success')
			{
				CurrentEffect = AbilityContext.ResultContext.MultiTargetEffectResults[ScanTargets].Effects[ScanEffect];
				break;
			}
		}
		UnitDamageAction.OriginatingEffect = CurrentEffect;
		UnitDamageAction.bShowFlyovers = false;

		// Jwats: Only add death during the last apply weapon damage pass
		if (ScanTargets + NumActualTargets >= AbilityContext.InputContext.MultiTargets.Length)
		{
			UnitDamageAction.bShowFlyovers = true;
			UnitDamageAction.bCombineFlyovers = true;
			XGUnit(ActionMetadata.VisualizeActor).BuildAbilityEffectsVisualization(VisualizeGameState, ActionMetadata);
		}

	}

	VisMgr.GetAllLeafNodes(VisMgr.BuildVisTree, LeafNodes);
	JoinActions = X2Action_MarkerNamed(class'X2Action_MarkerNamed'.static.AddToVisualizationTree(SourceMetadata, AbilityContext, false, , LeafNodes));
	JoinActions.SetName("Join");
}

function bool IonicStormDamagePreview(XComGameState_Ability AbilityState, StateObjectReference TargetRef, out WeaponDamageValue MinDamagePreview, out WeaponDamageValue MaxDamagePreview, out int AllowsShield)
{
	local XComGameState_Unit SourceUnit;
	local int FocusLevel;
	
	// Call the default damage preview first, but only for the organic ability target effect
	AbilityState.GetMyTemplate().AbilityMultiTargetEffects[0].GetDamagePreview(TargetRef, AbilityState, false, MinDamagePreview, MaxDamagePreview, AllowsShield); 

	SourceUnit = XComGameState_Unit(`XCOMHISTORY.GetGameStateForObjectID(AbilityState.OwnerStateObject.ObjectID));

	if( SourceUnit != None && SourceUnit.ObjectID != TargetRef.ObjectID )
	{
		FocusLevel = SourceUnit.GetTemplarFocusLevel();
		
		// Then modify based on current Focus level
		MinDamagePreview.Damage = MinDamagePreview.Damage * FocusLevel;
		MaxDamagePreview.Damage = MaxDamagePreview.Damage * FocusLevel;
	}

	return true;
}
static function X2AbilityTemplate VoidConduit()
{
	local X2AbilityTemplate					Template;
	local X2AbilityCost_ActionPoints		ActionPointCost;
	local X2Condition_UnitProperty			TargetCondition;
	local X2Effect_PersistentVoidConduit	PersistentEffect;
	local X2Effect_VoidConduit				TickEffect;
	local X2Condition_UnitEffects			EffectCondition;
	local X2AbilityCooldown					Cooldown;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'VoidConduit');

//BEGIN AUTOGENERATED CODE: Template Overrides 'VoidConduit'
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
	Template.CustomFireAnim = 'HL_VoidConduit';
	Template.CustomFireKillAnim = 'HL_VoidConduit';
	Template.ActivationSpeech = 'VoidConduit';
	Template.CinescriptCameraType = "Templar_VoidConduit";
//END AUTOGENERATED CODE: Template Overrides 'VoidConduit'
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_AlwaysShow;
	Template.Hostility = eHostility_Offensive;
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_VoidConduit";
	Template.AbilityConfirmSound = "TacticalUI_ActivateAbility";

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SimpleSingleTarget;
	Template.AbilityTriggers.AddItem(default.PlayerInputTrigger);

	ActionPointCost = new class'X2AbilityCost_ActionPoints';
	ActionPointCost.iNumPoints = 1;
	ActionPointCost.bConsumeAllPoints = true;
	Template.AbilityCosts.AddItem(ActionPointCost);
	Template.AbilityCosts.AddItem(new class'X2AbilityCost_Focus');

	Cooldown = new class'X2AbilityCooldown';
	Cooldown.iNumTurns = default.VOIDCONDUIT_COOLDOWN;
	Template.AbilityCooldown = Cooldown;

	Template.AbilityShooterConditions.AddItem(default.LivingShooterProperty);
	Template.AddShooterEffectExclusions();

	Template.AbilityTargetConditions.AddItem(default.GameplayVisibilityCondition);

	TargetCondition = new class'X2Condition_UnitProperty';
	TargetCondition.ExcludeAlive = false;
	TargetCondition.ExcludeDead = true;
	TargetCondition.ExcludeFriendlyToSource = true;
	TargetCondition.ExcludeHostileToSource = false;
	TargetCondition.TreatMindControlledSquadmateAsHostile = false;
	TargetCondition.FailOnNonUnits = true;
	TargetCondition.ExcludeCivilian = true;
	TargetCondition.ExcludeCosmetic = true;
	TargetCondition.ExcludeRobotic = true;
	TargetCondition.ExcludeAlien = true;
	Template.AbilityTargetConditions.AddItem(TargetCondition);

	//	don't allow a target to be affected by this more than one at a time
	EffectCondition = new class'X2Condition_UnitEffects';
	EffectCondition.AddExcludeEffect(class'X2Effect_PersistentVoidConduit'.default.EffectName, 'AA_UnitIsImmune');
	Template.AbilityTargetConditions.AddItem(EffectCondition);

	//	build the persistent effect
	PersistentEffect = new class'X2Effect_PersistentVoidConduit';
	PersistentEffect.InitialDamage = default.VoidConduitInitialDamage;
	PersistentEffect.BuildPersistentEffect(1, true, true, false, eGameRule_PlayerTurnBegin);
	PersistentEffect.SetDisplayInfo(ePerkBuff_Penalty, Template.LocFriendlyName, Template.LocLongDescription, Template.IconImage, false, , Template.AbilitySourceName);
	PersistentEffect.bRemoveWhenTargetDies = true;
	//	build the per tick damage effect
	TickEffect = new class'X2Effect_VoidConduit';
	TickEffect.DamagePerAction = default.VoidConduitPerActionDamage;
	TickEffect.HealthReturnMod = default.VoidConduitHPMod;
	PersistentEffect.ApplyOnTick.AddItem(TickEffect);
	Template.AddTargetEffect(PersistentEffect);

	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = TypicalAbility_BuildVisualization;
	Template.DamagePreviewFn = VoidConduitDamagePreview;

	return Template;
}

function bool VoidConduitDamagePreview(XComGameState_Ability AbilityState, StateObjectReference TargetRef, out WeaponDamageValue MinDamagePreview, out WeaponDamageValue MaxDamagePreview, out int AllowsShield)
{
	MinDamagePreview.Damage = default.VoidConduitInitialDamage;
	MaxDamagePreview.Damage = default.VoidConduitInitialDamage;
	return true;
}

static function X2AbilityTemplate StunStrike()
{
	local X2AbilityTemplate							Template;
	local X2AbilityToHitCalc_PercentChancePlusFocus	ChanceToHit;
	local X2Effect_Knockback						KnockbackEffect;
	local X2Effect_PersistentStatChange				DisorientEffect;
	local X2AbilityCost_ActionPoints				ActionPointCost;
	local X2AbilityCooldown							Cooldown;
	local X2Effect_ApplyWeaponDamage				DamageEffect;
	local X2Effect_TriggerEvent						TriggerEventEffect;
	local X2Condition_UnitProperty					TargetCondition;
	local X2Condition_UnitEffects					UnitEffectsCondition;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'StunStrike');

//BEGIN AUTOGENERATED CODE: Template Overrides 'StunStrike'
	Template.bFrameEvenWhenUnitIsHidden = true;
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
	Template.AbilityConfirmSound = "TacticalUI_ActivateAbility";
	Template.ActivationSpeech = 'StunStrike';
	Template.CinescriptCameraType = "Psionic_FireAtUnit";
//END AUTOGENERATED CODE: Template Overrides 'StunStrike'
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_AlwaysShow;
	Template.Hostility = eHostility_Offensive;
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_StunStrike";

	ChanceToHit = new class'X2AbilityToHitCalc_PercentChancePlusFocus';
	ChanceToHit.PercentToHit = default.StunStrikeHitChance;
	ChanceToHit.FocusMultiplier = default.StunStrikeFocusMultiplierHitChance;
	Template.AbilityToHitCalc = ChanceToHit;

	Template.AbilityCosts.AddItem(new class'X2AbilityCost_Focus');

	ActionPointCost = new class'X2AbilityCost_ActionPoints';
	ActionPointCost.iNumPoints = 1;
	ActionPointCost.bConsumeAllPoints = false;
	Template.AbilityCosts.AddItem(ActionPointCost);

	Cooldown = new class'X2AbilityCooldown';
	Cooldown.iNumTurns = default.STUNSTRIKE_COOLDOWN;
	Template.AbilityCooldown = Cooldown;

	Template.AbilityTriggers.AddItem(default.PlayerInputTrigger);

	Template.AbilityTargetStyle = default.SimpleSingleTarget;

	Template.AbilityShooterConditions.AddItem(default.LivingShooterProperty);
	Template.AddShooterEffectExclusions();

	TargetCondition = new class'X2Condition_UnitProperty';
	TargetCondition.ExcludeAlive = false;
	TargetCondition.ExcludeDead = true;
	TargetCondition.ExcludeFriendlyToSource = true;
	TargetCondition.ExcludeHostileToSource = false;
	TargetCondition.TreatMindControlledSquadmateAsHostile = false;
	TargetCondition.FailOnNonUnits = true;
	TargetCondition.ExcludeLargeUnits = true;
	Template.AbilityTargetConditions.AddItem(TargetCondition);
	Template.AbilityTargetConditions.AddItem(default.GameplayVisibilityCondition);

	UnitEffectsCondition = new class'X2Condition_UnitEffects';
	UnitEffectsCondition.AddExcludeEffect(class'X2Ability_Viper'.default.BindSustainedEffectName, 'AA_UnitIsBound');
	Template.AbilityTargetConditions.AddItem(UnitEffectsCondition);

	KnockbackEffect = new class'X2Effect_Knockback';
	KnockbackEffect.KnockbackDistance = 2;
	KnockbackEffect.OnlyOnDeath = false; 
	Template.AddTargetEffect(KnockbackEffect);

	TriggerEventEffect = new class'X2Effect_TriggerEvent';
	TriggerEventEffect.TriggerEventName = 'StunStrikeActivated';
	TriggerEventEffect.PassTargetAsSource = true;
	Template.AddTargetEffect(TriggerEventEffect);

	//	this effect is just here for visuals on a miss
	DamageEffect = new class'X2Effect_ApplyWeaponDamage';
	DamageEffect.bIgnoreBaseDamage = true;
	DamageEffect.bApplyOnHit = false;
	DamageEffect.bApplyOnMiss = true;
	DamageEffect.bApplyToWorldOnHit = false;
	DamageEffect.bApplyToWorldOnMiss = false;
	Template.AddTargetEffect(DamageEffect);

	DisorientEffect = class'X2StatusEffects'.static.CreateDisorientedStatusEffect();
	DisorientEffect.iNumTurns = default.StunStrikeDisorientNumTurns;
	DisorientEffect.ApplyChanceFn = StunStrikeDisorientApplyChance;
	Template.AddTargetEffect(DisorientEffect);

	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = TypicalAbility_BuildVisualization;
	Template.CustomFireAnim = 'HL_StunStrike';

	Template.SuperConcealmentLoss = class'X2AbilityTemplateManager'.default.SuperConcealmentStandardShotLoss;
	Template.LostSpawnIncreasePerUse = class'X2AbilityTemplateManager'.default.StandardShotLostSpawnIncreasePerUse;

	return Template;
}

function name StunStrikeDisorientApplyChance(const out EffectAppliedData ApplyEffectParameters, XComGameState_BaseObject kNewTargetState, XComGameState NewGameState)
{
	local XComGameStateHistory History;
	local XComGameState_Unit UnitState;
	local int ApplyChance;

	History = `XCOMHISTORY;

	UnitState = XComGameState_Unit(History.GetGameStateForObjectID(ApplyEffectParameters.SourceStateObjectRef.ObjectID, eReturnType_Reference, NewGameState.HistoryIndex));
	ApplyChance = UnitState.GetTemplarFocusLevel() * default.StunStrikeDisorientFocusMultiplier;

	if( `SYNC_RAND(100 ) >= ApplyChance)
	{
		return 'AA_EffectChanceFailed';
	}

	return 'AA_Success';
}

static function X2AbilityTemplate MeditationPreparationPassive()
{
	local X2AbilityTemplate			Template;

	Template = PurePassive('MeditationPreparationPassive', "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_meditation");

	return Template;
}

static function X2AbilityTemplate MeditationPreparation( )
{
	local X2AbilityTemplate						Template;
	local X2Effect_ModifyTemplarFocus			FocusEffect;
	local X2AbilityTrigger_OnAbilityActivated	ActivationTrigger;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'MeditationPreparation');

//BEGIN AUTOGENERATED CODE: Template Overrides 'MeditationPreparation'
	Template.AbilitySourceName = 'eAbilitySource_Psionic';
//END AUTOGENERATED CODE: Template Overrides 'MeditationPreparation'
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_NeverShow;
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_meditation";

	Template.Hostility = eHostility_Neutral;

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SelfTarget;

	ActivationTrigger = new class'X2AbilityTrigger_OnAbilityActivated';
	ActivationTrigger.SetListenerData( 'TemplarFocus' );
	Template.AbilityTriggers.AddItem(ActivationTrigger);

	FocusEffect = new class'X2Effect_ModifyTemplarFocus';
	FocusEffect.ModifyFocus = default.MEDITATION_PREPARATION_STARTING_FOCUS;
	Template.AddShooterEffect(FocusEffect);

	Template.bSkipFireAction = true;
	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = TypicalAbility_BuildVisualization;

	Template.AdditionalAbilities.AddItem('MeditationPreparationPassive');

	return Template;
}

static function X2AbilityTemplate TemplarBladestorm()
{
	local X2AbilityTemplate                 Template;

	Template = PurePassive('TemplarBladestorm', "img:///UILibrary_PerkIcons.UIPerk_bladestorm", false, 'eAbilitySource_Perk');
	Template.AdditionalAbilities.AddItem('TemplarBladestormAttack');

	return Template;
}

static function X2AbilityTemplate TemplarBladestormAttack()
{
	local X2AbilityTemplate                 Template;
	local X2Effect_ApplyWeaponDamage		DamageEffect;
	local int i;

	Template = class'X2Ability_RangerAbilitySet'.static.BladestormAttack('TemplarBladestormAttack');
	X2AbilityToHitCalc_StandardMelee(Template.AbilityToHitCalc).bGuaranteedHit = true;

	//	mark up the damage as melee
	for (i = 0; i < Template.AbilityTargetEffects.Length; ++i)
	{
		DamageEffect = X2Effect_ApplyWeaponDamage(Template.AbilityTargetEffects[i]);
		if (DamageEffect != none)
			DamageEffect.DamageTypes.AddItem('melee');
	}

	return Template;
}
