{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"X2WOTCCommunityHighlander Documentation Current status of the Documentation The documentation is freshly introduced. It will take us a while to document all old features, but it is expected that new features all come with their documentation page. How to read The nav bar has a list of features. Click on a feature to view that feature's documentation. Every feature has: A GitHub tracking issue for discussion A documented way to use it, for example with an event tuple Code references that link to HL source code where the documentation is Documentation for the documentation tool We place our documentation inside of the source code next to where the main change for the given feature is. make_docs.py extracts this documentation and renders MarkDown pages, which MkDocs in turn renders to a web page. You can run the documentation tool locally by installing Python (recommended version 3.7) and running python .\\.scripts\\make_docs.py --indirsfile .\\docs_directories.txt --outdir .\\target\\ --docsdir .\\docs_src\\ --dumpelt .\\target\\CHL_Event_Compiletest.uc or the makeDocs task in VS Code. This creates Markdown files for the documentation; rendering HTML documentation requires MkDocs : pip install mkdocs cd .\\target\\ mkdocs serve Whenever the master branch is committed to, the documentation is built and deployed here. Additionally, upon opening or updating a Pull Request, the documentation is built and uploaded as a GitHub artifact. This can be used to easily check the resulting documentation for a Pull Request. Inline Documentation The core concept of the documentation script is \"features\". Documentation always relates to a given feature, and usually the feature name is the name of the function or event that is added. Every feature needs exactly one definition , and may have additional documentation scattered throughout other source files. Syntax Every block of comments starting with triple comment characters ( /// for UnrealScript files and ;;; for Ini files) and an optional whitespace character (space or tab) will be considered for documentation. Additionally, the first line must begin with HL-Docs: . All directly following lines that start with the same triple comment will be included until the first line that does not have that triple comment. Standard MarkDown syntax is expected and supported. You may include source code fragments directly from the game code by placing a single HL-Include: in an otherwise empty triple comment line; all following lines until the next triple comment line will be included as source code in the documentation. Feature definitions A feature definition has the following syntax: HL-Docs: feature:<string>; issue:<int>; tags:<string>,<string>... Feature references If you have defined a feature somewhere but want to reference other parts of the source code, or want to spread the documentation for a feature across different files, you may place a reference: HL-Docs: ref:<string> All text from the reference block will be appended to the main documentation as well. Complete example (Taken from ArmorEquipRollDLCPartChance ) XComGameState_Unit.uc : /// HL-Docs: feature:ArmorEquipRollDLCPartChance; issue:155; tags:customization,compatibility /// When a unit equips new armor, the game rolls from all customization options, even the ones where /// the slider for the `DLCName` is set to `0`. The HL change fixes this, but if your custom armor only /// has customization options with a `DLCName` set, the game may discard that `DLCName` (default: in 85% of cases) /// which results in soldiers without torsos. If you want to keep having `DLCName`-only armor /// (for example to display mod icons in `UICustomize`), you must disable that behavior /// by creating the following lines in `XComGame.ini`: /// /// ```ini /// [XComGame.CHHelpers] /// +CosmeticDLCNamesUnaffectedByRoll=MyDLCName /// ``` XComGame.ini : ;;; HL-Docs: ref:ArmorEquipRollDLCPartChance Tags You may tag your documentation with a number of built-in and custom tags. strategy and tactical are built-in tags used to categorize features in the navigation bar. If a feature has one tag and not the other, it'll land in that category. Otherwise, it'll land in the misc category. Custom tags can be used, but need a custom page that serves as an index page for that tag; for example the compatibility tag has a page docs_src/compatibility.md that describes what the tag is supposed to mean and (automatically generated) links to all features with that tag. Bugfixes The Bugfixes feature is owned by the documentation script and as such has no definition in the game code. It is used for generating a page listing all bugfixes that can be explained by a single line. It uses a slightly modified reference syntax: HL-Docs: ref:Bugfixes; issue:<int> <string> for example: /// HL-Docs: ref:Bugfixes; issue:70 /// `CharacterPoolManager:CreateCharacter` now honors ForceCountry Events The Highlander triggers some events to pass data to and receive data from mods. We document these events with a special syntax and automatically generate a copy-pasteable listener template that developers can simply copy into their mod and fill out. Additionally, that listener template is printed into a CHL source file so that it can be tested whether it successfully compiles. The syntax for events is the following ```event EventID: OverridePromotionUIClass, EventData: [in enum[CHLPromotionScreenType] PromotionScreenType, inout class[class<UIArmory_Promotion>] PromotionUIClass], EventSource: XComHQPresentationLayer (Pres), NewGameState: none ``` Entries need to be comma-separated EventData or EventSource specify the type, and then optionally in parentheses the variable name. EventData can be an XComLWTuple. In that case, use [ inout int a, ... ] Tuple parameters can be in , out , or inout In the template, in parameters will be copied from the tuple into a local property out parameters will be copied from a local property into the tuple inout parameters do both All XComLWTuple types are supported enum s can be typed with enum[EnumType] class es can be typed with class[class<Type>] If the type is not a primitive, it's assumed to be an object NewGameState needs to be one of three values: yes , maybe or none The above example generates the following code static function EventListenerReturn OnOverridePromotionUIClass(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComHQPresentationLayer Pres; local XComLWTuple Tuple; local CHLPromotionScreenType PromotionScreenType; local class<UIArmory_Promotion> PromotionUIClass; Pres = XComHQPresentationLayer(EventSource); Tuple = XComLWTuple(EventData); PromotionScreenType = CHLPromotionScreenType(Tuple.Data[0].i); PromotionUIClass = class<UIArmory_Promotion>(Tuple.Data[1].o); // Your code here Tuple.Data[1].o = PromotionUIClass; return ELR_NoInterrupt; } All generated listeners will be dumped into CHL_Event_Compiletest.uc , which will only be included in normal compilation in \"compiletest\" tasks. CI automatically determines the changes your PR would make to that file and posts a comment containing the diff for reviewers (and you). This comment will be updated whenever the PR is updated. If you provide a better example listener, you can simply opt out of the template with ```event,notemplate .","title":"X2WOTCCommunityHighlander Documentation"},{"location":"#x2wotccommunityhighlander-documentation","text":"","title":"X2WOTCCommunityHighlander Documentation"},{"location":"#current-status-of-the-documentation","text":"The documentation is freshly introduced. It will take us a while to document all old features, but it is expected that new features all come with their documentation page.","title":"Current status of the Documentation"},{"location":"#how-to-read","text":"The nav bar has a list of features. Click on a feature to view that feature's documentation. Every feature has: A GitHub tracking issue for discussion A documented way to use it, for example with an event tuple Code references that link to HL source code where the documentation is","title":"How to read"},{"location":"#documentation-for-the-documentation-tool","text":"We place our documentation inside of the source code next to where the main change for the given feature is. make_docs.py extracts this documentation and renders MarkDown pages, which MkDocs in turn renders to a web page. You can run the documentation tool locally by installing Python (recommended version 3.7) and running python .\\.scripts\\make_docs.py --indirsfile .\\docs_directories.txt --outdir .\\target\\ --docsdir .\\docs_src\\ --dumpelt .\\target\\CHL_Event_Compiletest.uc or the makeDocs task in VS Code. This creates Markdown files for the documentation; rendering HTML documentation requires MkDocs : pip install mkdocs cd .\\target\\ mkdocs serve Whenever the master branch is committed to, the documentation is built and deployed here. Additionally, upon opening or updating a Pull Request, the documentation is built and uploaded as a GitHub artifact. This can be used to easily check the resulting documentation for a Pull Request.","title":"Documentation for the documentation tool"},{"location":"#inline-documentation","text":"The core concept of the documentation script is \"features\". Documentation always relates to a given feature, and usually the feature name is the name of the function or event that is added. Every feature needs exactly one definition , and may have additional documentation scattered throughout other source files.","title":"Inline Documentation"},{"location":"#syntax","text":"Every block of comments starting with triple comment characters ( /// for UnrealScript files and ;;; for Ini files) and an optional whitespace character (space or tab) will be considered for documentation. Additionally, the first line must begin with HL-Docs: . All directly following lines that start with the same triple comment will be included until the first line that does not have that triple comment. Standard MarkDown syntax is expected and supported. You may include source code fragments directly from the game code by placing a single HL-Include: in an otherwise empty triple comment line; all following lines until the next triple comment line will be included as source code in the documentation.","title":"Syntax"},{"location":"#feature-definitions","text":"A feature definition has the following syntax: HL-Docs: feature:<string>; issue:<int>; tags:<string>,<string>...","title":"Feature definitions"},{"location":"#feature-references","text":"If you have defined a feature somewhere but want to reference other parts of the source code, or want to spread the documentation for a feature across different files, you may place a reference: HL-Docs: ref:<string> All text from the reference block will be appended to the main documentation as well.","title":"Feature references"},{"location":"#complete-example","text":"(Taken from ArmorEquipRollDLCPartChance ) XComGameState_Unit.uc : /// HL-Docs: feature:ArmorEquipRollDLCPartChance; issue:155; tags:customization,compatibility /// When a unit equips new armor, the game rolls from all customization options, even the ones where /// the slider for the `DLCName` is set to `0`. The HL change fixes this, but if your custom armor only /// has customization options with a `DLCName` set, the game may discard that `DLCName` (default: in 85% of cases) /// which results in soldiers without torsos. If you want to keep having `DLCName`-only armor /// (for example to display mod icons in `UICustomize`), you must disable that behavior /// by creating the following lines in `XComGame.ini`: /// /// ```ini /// [XComGame.CHHelpers] /// +CosmeticDLCNamesUnaffectedByRoll=MyDLCName /// ``` XComGame.ini : ;;; HL-Docs: ref:ArmorEquipRollDLCPartChance","title":"Complete example"},{"location":"#tags","text":"You may tag your documentation with a number of built-in and custom tags. strategy and tactical are built-in tags used to categorize features in the navigation bar. If a feature has one tag and not the other, it'll land in that category. Otherwise, it'll land in the misc category. Custom tags can be used, but need a custom page that serves as an index page for that tag; for example the compatibility tag has a page docs_src/compatibility.md that describes what the tag is supposed to mean and (automatically generated) links to all features with that tag.","title":"Tags"},{"location":"#bugfixes","text":"The Bugfixes feature is owned by the documentation script and as such has no definition in the game code. It is used for generating a page listing all bugfixes that can be explained by a single line. It uses a slightly modified reference syntax: HL-Docs: ref:Bugfixes; issue:<int> <string> for example: /// HL-Docs: ref:Bugfixes; issue:70 /// `CharacterPoolManager:CreateCharacter` now honors ForceCountry","title":"Bugfixes"},{"location":"#events","text":"The Highlander triggers some events to pass data to and receive data from mods. We document these events with a special syntax and automatically generate a copy-pasteable listener template that developers can simply copy into their mod and fill out. Additionally, that listener template is printed into a CHL source file so that it can be tested whether it successfully compiles. The syntax for events is the following ```event EventID: OverridePromotionUIClass, EventData: [in enum[CHLPromotionScreenType] PromotionScreenType, inout class[class<UIArmory_Promotion>] PromotionUIClass], EventSource: XComHQPresentationLayer (Pres), NewGameState: none ``` Entries need to be comma-separated EventData or EventSource specify the type, and then optionally in parentheses the variable name. EventData can be an XComLWTuple. In that case, use [ inout int a, ... ] Tuple parameters can be in , out , or inout In the template, in parameters will be copied from the tuple into a local property out parameters will be copied from a local property into the tuple inout parameters do both All XComLWTuple types are supported enum s can be typed with enum[EnumType] class es can be typed with class[class<Type>] If the type is not a primitive, it's assumed to be an object NewGameState needs to be one of three values: yes , maybe or none The above example generates the following code static function EventListenerReturn OnOverridePromotionUIClass(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComHQPresentationLayer Pres; local XComLWTuple Tuple; local CHLPromotionScreenType PromotionScreenType; local class<UIArmory_Promotion> PromotionUIClass; Pres = XComHQPresentationLayer(EventSource); Tuple = XComLWTuple(EventData); PromotionScreenType = CHLPromotionScreenType(Tuple.Data[0].i); PromotionUIClass = class<UIArmory_Promotion>(Tuple.Data[1].o); // Your code here Tuple.Data[1].o = PromotionUIClass; return ELR_NoInterrupt; } All generated listeners will be dumped into CHL_Event_Compiletest.uc , which will only be included in normal compilation in \"compiletest\" tasks. CI automatically determines the changes your PR would make to that file and posts a comment containing the diff for reviewers (and you). This comment will be updated whenever the PR is updated. If you provide a better example listener, you can simply opt out of the template with ```event,notemplate .","title":"Events"},{"location":"Bugfixes/","text":"Bugfixes This page accomodates all bug fixes that do not deserve their own documentation page, as they are simple enough to be entirely explained by a single line. #20 - X2Ability.uc:1517-1518 : Reaper's Banish now properly visualizes subsequent shots. #33 - XGUnitNativeBase.uc:543-544 : Gremlins owned by AI units now correctly use fast walk animations even if their owner is in Red Alert #36 - X2TacticalGameRuleset.uc:4851-4852 : Do not clear Reinforcements' \"Summoning Sickness\" when interrupted by Skirmisher, denying them an erronous bonus turn. #39 - UIArmory_WeaponUpgrade.uc:558-559 : Create weapon pawn before setting PawnLocationTag so that the weapon can rotate when previewing weapon upgrades. #42 - X2Action_ApplyWeaponDamageToUnit.uc:1286-1287 : Prevent X2Action_ApplyWeaponDamageToUnit from resetting unit's weapons to default sockets if the unit is interrupted. #51 - XComGameState_AdventChosen.uc:264-265 : Prevent Assassin from gaining perks incompatible with forced \"Shadowstep\" in Lost and Abandoned #55 - CHItemSlot.uc:349-350 : Check a soldier's NeedsSecondaryWeapon everywhere instead of hardcoding based on Rookie rank #70 - CharacterPoolManager.uc:449-450 : CharacterPoolManager:CreateCharacter now honors ForceCountry #95 - XComGameState_Unit.uc:13902-13903 : ResetRankToRookie now correctly applies Beta Strike HP bonuses #160 - UIOptionsPCScreen.uc:3148-3149 : UIOptionsPCScreen now shows all part pack sliders, adding a scroll bar if needed #215 - XGUnit.uc:1537-1538 : Units are now allowed to have personality speech (affected by personality) even below \"Veteran\" rank #269 - XComIdleAnimationStateMachine.uc:1101-1102 : Fix some edge cases in XComIdleAnimationStateMachine regarding idle animations, targeting, and step-outs #273 - X2Ability.uc:1571-1572 : Fix an issue causing Rapid Fire/Chain Shot/Banish/... entering cover early #303 - UITooltipInfoList.uc:98-99 : UITooltipInfoList no longer displays stale data like weapon upgrades from other units #318 - X2Camera_Cinescript.uc:528-529 : Fix Cinescript CutAfterPrevious not working in combination with MatineeReplacements , breaking Spark BIT hack camera #326 - X2Action_ApplyWeaponDamageToUnit.uc:205-207 : Allow damage flyovers from weapon-less Psi abilities to use the Psi damage popup (e.g. Effect Damage from X2Effect_ApplyWeaponDamage, PsiBombStage2 & modded abilities) #346 - X2AbilityToHitCalc_StandardAim.uc:387-388 : Prevent X2AbilityToHitCalc_StandardAim from applying BuiltInHitMod and BuiltInCritMod against non-units. #350 - XComCharacterCustomization.uc:546-548 : Updates various classes (XComCharacterCustomization, XCGS_Unit, XComHumanPawn and XGCharacterGenerator) to carry out proper validation and selection of valid body parts on soldiers when other parts are changed in the armory. #367 - XComGameState_Item.uc:486-487 : Gremlins now correctly die when the Gremlin's owner dies while the Gremlin is attached to another unit. #376 - XGUnit.uc:3771-3772 : Gremlins (and other Cosmetic Units) are now correctly tinted and patterned #379 - XComGameState_HuntersLodgeManager.uc:181-183 : Check if the Chosen is defeated to determine whether the Hunter's Lodge should display their trophy, rather than checking if XCOM has researched their weapons. #380 - XComCharacterCustomization.uc:825-826 : Update cosmetic pawns when secondary armor color is changed as well as primary #380 - XComUnitPawn.uc:2361-2362 : Ensure that the appearence of cosmetic unit pawns is updated properly, even when a new pawn is not created #384 - XComHumanPawn.uc:2370-2371 : Remove cosmetics from separate Left and Right Arm slots when updating Appearance to one that includes a cosmetic body part for both Arms in one slot. #384 - XComHumanPawn.uc:2437-2438 : Allow bForcedAppearance to work with new deco slots added with Anarchy Children and WOTC. #384 - XGCharacterGenerator.uc:714-715 : Randomize deco slots only if the character template is not using bForceAppearance . #426 - X2AbilityToHitCalc_StandardAim.uc:201-202 : Fix X2AbilityToHitCalc_StandardAim discarding unfavorable (for XCOM) changes to hit results from effects #493 - X2AbilityToHitCalc_StandardAim.uc:762-763 : Allow REACTION_DASHING_FINALMOD to reduce reaction fire hit chance against dashing targets #496 - X2Ability_Chosen.uc:1569-1570 : Fix the timeout during Chosen death teleport visualization by refactoring ChosenDefeatedEscape_BuildVisualization. #503 - XGAIBehavior.uc:9726-9727 : \"Flying\" pod leaders now patrol despite non-flat tiles on their paths #508 - XComGameState_AIGroup.uc:422-423 : Patrol logic now ensures units do not attempt to patrol outside of the map which would cause them to stop patrolling #520 - X2MeleePathingPawn.uc:186-187 : Controller input now allows choosing melee attack destination tile despite floor differences #531 - X2Ability_ChosenAssassin.uc:565-566 : Assassin gains a temporary instead of permanently stacking mobility boost from performing a melee attack #551 - X2Action_SwapTeams.uc:48-49 : Rescue rings no longer disappear on other rescuable units after a neutral unit swaps to team XCom #557 - XComGameState_Unit.uc:2434-2435 : Soldiers that have been carried out of a mission are no longer unable to be carried out of a later mission #608 - XComGameState_Unit.uc:4463-4464 : MergeAmmoAsNeeded now also works for units spawned from the Avenger #609 - XComGameState_Unit.uc:8239-8240 : Apply weapon customization from soldier appearance when equipping weapons. #613 - UIX2PanelHeader.uc:53-54 : SetText now sends text to flash instead of requiring calling SetHeaderWidth #617 - X2TargetingMethod_RocketLauncher.uc:44-45 : Ray trace from the peek tile to the target, not from the unit tile to the peek tile. #637 - XComGameState_Unit.uc:14801-14802 : Will recovery project and soldier mental state are now consistent with each other, fixing Shaken/Tired soldiers occasionally recovering instantly #638 - UIScanButton.uc:278-279 : UIScanButton can now work properly when it's a grandchild of UIStrategyMapItem, not only when direct child #644 - X2Ability_DefaultAbilitySet.uc:426-427 : Allow patrolling units to occupy the same tile instead of teleporting to (0,0,0) when out of space, potentially revealing XCOM #648 - UIHackingScreen.uc:410-411 : Cancelling a hack in progress using Esc no longer bypasses Haywire's cooldown #682 - XComGameState_Unit.uc:6979-6981 : Zombies will no longer drop loot. Only affects mods that destroy loot when killing units with explosives. #701 - UIArmory_LoadoutItem.uc:78-79 : Allows armory UI to highlight the item the player needs to build during the tutorial even if it's not the item with the exact template name 'Medikit' #775 - XGBase.uc:263-264 : Applying facility upgrades before the facility map is loaded no longer crashes the game. #817 - UIOptionsPCScreen.uc:1544-1545 : Disable the Framerate Smoothing option, as it's known to break Mod Class Overrides. #824 - XComGameState_Unit.uc:2581-2583 : Units that are still stunned when a mission ends no longer lose action points at the start of their next mission. #861 - UIStaffSlot.uc:223-227 : By default, UIStaffSlot removes highlighting when a personnel is selected. However, the slot still has navigator focus, and should remain highlighted. This only affects controllers since the mouse has moved off the button at this point. If a controller is active, don't let the game un-highlight it. #862 - UIStaffSlot.uc:405-408 : By default, UIStaffSlot will blink on and off a staff slot that \"loses\" focus when focus doesn't belong to it in the first place. Make sure to only change focus if the element is not already in the destination focus state #866 - UIStaffContainer.uc:58-60 : By default, UIStaffContainer tries to shortcut which UIPanel should receive focus, but the shortcut is often wrong and the time it saves is negligible, so this bypasses it. #879 - X2Ability.uc:815-816 : Use HistoryIndex to access the AbilityState as it was when the ability was activated rather than getting the most recent version. #879 - X2Ability.uc:834-835 : Use HistoryIndex to access the WeaponState as it was when the ability was activated rather than getting the most recent version. #880 - UIArmory_WeaponUpgrade.uc:750-751 : Remove unnecessary text coloring from the weapon pattern value text. #896 - X2Effect_ApplyWeaponDamage.uc:476-478 : Call the (hopefully) relevant delegate, if this weapon upgrade has it. This makes the guaranteed damage on missed shots added by Stocks properly benefit from Insider Knowledge #896 - X2Effect_ApplyWeaponDamage.uc:855-857 : Call the (hopefully) relevant delegate, if this weapon upgrade has it. This makes the guaranteed damage on missed shots added by Stocks properly benefit from Insider Knowledge #896 - X2Effect_LaserSight.uc:28-29 : Add bonus crit if Insider Knowledge is present. #924 - UIChoosePsiAbility.uc:211-212 : Prevent the psi ability training screen from showing duplicate abilities #927 - XComGameState_GeoscapeEntity.uc:311-314 : When cancelling out of squad select or mission launch, the selected map item will now return back to the mission rather than the Avenger (affects controller users). #952 - UIChosenInfo.uc:56-57 : Focus the top Chosen button when the screen is opened. #952 - UIChosenInfo.uc:431-432 : Fix typo in the MC function call. #990 - X2Ability_HackRewards.uc:736-738 : Trigger the hack reward ability only if it's present in the Game State. This prevents hack rewards from being granted multiple times. #1008 - XGAIBehavior.uc:10059-10061 : Entire pods no longer fail to scamper if the pod leader skips its turn, for example if it's immobilized. #1029 - SeqAct_SpawnUnitFromAvenger.uc:201-203 : Units spawned from the Avenger would sometimes not be able to take actions because their abilities weren't initialized properly. This is now fixed. #1035 - UICovertActions.uc:466-467 : Use SlotContainer.Navigator.SelectedIndex instead of Navigator.SelectedIndex to allow controller users editing all soldiers' loadouts. #1035 - UICovertActions.uc:1027-1028 : Use SlotContainer.Navigator.SelectedIndex instead of Navigator.SelectedIndex to allow controller users editing all soldiers' loadouts. #1035 - UICovertActions.uc:1031-1032 : Use SlotContainer.Navigator.SelectedIndex instead of Navigator.SelectedIndex to allow controller users editing all soldiers' loadouts. #1065 - UIArmory_LoadoutItem.uc:64-65 : UIArmory_LoadoutItem now shows the correct stack counts for modified finite items. #1073 - XComGameState_Unit.uc:13923-13924 : Get the unit's own Soldier Class Template rather than using Ranger's for all classes. #1082 - X2TacticalGameRuleset.uc:3012-3013 : MarkPlotUsed() - commented out original call and moved it outside of the if() statement #1090 - X2Item_DLC_Day60Armors.uc:64-67 : Prevent log warnings and redscreens when Alien Hunters armor is equipped in the Shell, e.g. Character Pool. Alien Hunters armor uses OnEquippedFn delegates to alter soldier appearance when the player equips them for the first time. The \"is first time\" check is done using XComHQ, which doesn't exist in the Shell. #1096 - UIChosenInfo.uc:155-156 : Abilities related to Chosen strengths and weaknesses now have their description expanded. #1096 - UIChosenInfo.uc:175 : #1096 - UIChosenLevelUp.uc:59 : #1096 - UIChosenReveal.uc:55 : #1096 - UIChosenReveal.uc:69 : #1108 - XComGameState_Unit.uc:8621-8622 : If there is a cosmetic pawn associated with the unequipped item item, remove it. #1118 - UICharacterPool_ListPools.uc:486-487 : LoadCharacterPool() may alter PoolFileName in certain conditions. #1120 - XComGameState_Unit.uc:14423-14424 : Add the effect's status icon only if it's not empty. #1131 - X2Ability_ReaperAbilitySet.uc:834-842 : A Target Condition on an X2Effect cannot be used to decide whether environmental damage should apply or not, because environmental damage is not triggered against any specific target, so there's nothing to check the condition against. The bugfix moves the condition logic into X2Effect_HomingMineDamage. This effect's condition is removed and the effect itself is neutered. The effect is left on the ability template to maintain the number of effects the same. #1145 - XComGameState_AIReinforcementSpawner.uc:283-284 : Reinforcements will now spawn their cosmetic units properly. Units spawned without their cosmetic units will crash when trying to use abilities that use them. #1171 - XComGameState_HeadquartersProjectHealSoldier.uc:81-83 : Round the HealthPercent value to prevent it landing above MaxHealthPercent of one Wound Severity, but below MinHealthPercent of the next one, making the code fail to select a Wound Severity at all. #1181 - UIFacilityGrid_FacilityOverlay.uc:1354-1355 : Make facility staff icons correctly display which staff slots are filled. #1182 - X2StrategyElement_XpackChosenActions.uc:326-327 : Make Defense Matrix properly reduce the chance of Chosen sabotage. #1190 - XComGameState_HeadquartersXCom.uc:4323-4326 : Fixes an issue where loot caches / hack rewards were ignoring the quantity of caches obtained (resulting in only a single cache reward of each type being awarded at the end of a mission, regardless of how many were obtained). Also fixes the issue where resources obtained from different cache types (e.g. Large + small intel) were not stacking in the post mission UI. #1192 - UIPawnMgr.uc:647-648 : Add call to StopSounds to remove sound effects for destroyed pawns. #1193 - XGAIPlayer.uc:939-941 : Added IsUnconcious and IsBleedingOut check to skip AI units in group who are Unconcious or Bleeding out as the AI processing hangs here until it times out, which causes the rest of the group to be skipped. #1195 - X2Ability_DefaultAbilitySet.uc:775-776 : Allow Return Fire shots to respond to enemy attacks if the enemy is in cover that requires a step out. #1196 - X2Ability_DefaultAbilitySet.uc:852-853 : Make Return Fire visualize after Covering Fire Overwatch, so they no longer fight for visualization. #1200 - X2AbilityToHitCalc.uc:126-127 : Make Dodge apply to Hit and Crit equally to fix Dodge increasing Miss chance. #1223 - X2Ability_CarryUnit.uc:304-305 : Added a skip exclusion for burning status so units can set down other carried units when they are on fire #1233 - UITacticalHUD_Enemies.uc:365-366 : Cache hit chances of visible targets to prevent multiple expensive GetHitChance() calls for each target. #1262 - X2Item_HeavyWeapons.uc:354-355 : Remove build time from the Shredstorm Cannon. #1274 - X2Action_ApplyWeaponDamageToUnit.uc:161-167 : Adjusted base-game logic for display of standard Red (Normal Damage), or Purple (Psionic) flyovers when damage is inflicted on a unit. Base game code first takes damage type from the weapon template, then if nothing is found, checks for DOTs / environmental damage. Issue #326 resolves flyovers for psionic effects not bound to weapons but modded abilities may wish to display the psionic flyover even when bound. The adjusted code changes the logic so the damagetype for flyovers is taken from the originating effect first, falls back to the weapon's base damage type and then uses default if nothing is found. #1276 - X2Ability_Chosen.uc:1770-1771 : Limit Chosen Low Profile to one trigger per turn. #1276 - X2Ability_Chosen.uc:1811-1813 : Comment out the effect that removes the Covering Fire effect responsible for triggering the Chosen Low Profile defense bonus ability, so it can trigger more than once per mission. #1281 - X2Effect_ApplyWeaponDamage.uc:671-672 : If the effect ignores all armor, max out the Pierce value in the Damage Preview so it will show up on the unit flag damage preview. #1286 - X2StatusEffects.uc:2490-2491 : Keep lure effect alive when source dies, tick on turn begin. Adjust icon and displayinfo to display as debuff rather than passive. #1288 - XComGameState_Effect.uc:1548-1551 : Fixes a bug in which a unit's cover may not be not correctly updated by the visibility manager when destructible actors are created directly adjacent to them (e.g. Pillar). The fix uses an eventlistener deferred to the end of the visualization block to clear and refresh the visibility manager. Resetting it in this way is a bit of a sledgehammer but since much of the cover/visibility system is native, limited viable alternatives exist. #1290 - XGUnit.uc:3231-3232 : Update XGUnit::DropWeapon() function with code from Chimera Squad to prevent unit weapons from glitching when dropped on death. #1293 - X2Ability_SkirmisherAbilitySet.uc:412-413 : Allow Justice to target enemies Mind Controlled by XCOM #1293 - X2Ability_SkirmisherAbilitySet.uc:687-688 : Allow Wrath to target enemies Mind Controlled by XCOM #1293 - X2Ability_SkirmisherAbilitySet.uc:815-816 : Allow Whiplash to target enemies Mind Controlled by XCOM #1293 - X2Ability_SkirmisherAbilitySet.uc:843-844 : Make enemies Mind Controlled by XCOM eligible for Whiplash's bonus damage #1298 - X2AbilityToHitCalc_StandardAim.uc:377-378 : Add 100 crit chance to guaranteed crit abilities for the purposes of UI. #1299 - X2Effect_ApplyWeaponDamage.uc:153-154 : Apply rupture after dealing the damage from the attack. #1299 - X2Effect_ApplyWeaponDamage.uc:970-971 : Remove the cap from the amount of bonus damage that can be added to an attack by rupture, and do not add rupture added by this attack to the attack's damage. #1300 - X2AbilityToHitCalc_StandardAim.uc:191-192 : Code block moved to be right after aim assist logic, so that if a miss is converted to a hit by aim assist, the ability will still crit if it is set up to always crit on hit. #1301 - XComIdleAnimationStateMachine.uc:934-935 : Targeting enemies from concealment will no longer make them face the unit doing the targeting. #1311 - X2Ability_SpecialistAbilitySet.uc:521-522 : Make Combat Protocol deal bonus damage to robots hacked by XCOM #1312 - X2Ability_StunLancer.uc:55-56 : Allow Stun Lance to target Mind Controlled units (currently on the same team as the Stun Lancer) #1318 - X2Condition_StasisLanceTarget.uc:27-28 : Disallow using Skulljack and Skullmine on units in Stasis. #1319 - X2TacticalGameRuleset.uc:1273-1279 : If mission start concealment is disabled by bForceNoSquadConcealment flag in BattleData, trigger the SquadConcealmentBroken event on mission start. In the base game, this flag is set only by the \"High Alert\" Dark Event. Triggering the event fixes the bug on Supply Extraction missions, where ADVENT never starts collecting supply crates if XCOM starts unconcealed, because the mission kismet starts the crate collection when the SquadConcealmentBroken event is triggered. #1320 - X2Action_ApplyWeaponDamageToUnit.uc:912-913 : Allow hit results other than eHit_Success to display flyovers. #1322 - X2Item_XpackWeapons.uc:495-496 : Comment out the line setting iTypicalActionCost for the conventional Vektor Rifle to match magnetic and beam variants. #1329 - X2Ability.uc:485-486 : Apply bonus weapon effects and ammo effects to multi targets. #1329 - X2Ability.uc:1166-1167 : Visualize bonus weapon effects and ammo effects being applied to multi targets. #1329 - X2Ability_GrenadierAbilitySet.uc:782-783 : Make Saturation Fire apply ammo effects and bonus weapon effects. #1329 - X2Ability_SharpshooterAbilitySet.uc:1182-1183 : Visualize applying bonus weapon effects and ammo effects to the primary target. #1329 - X2Ability_SharpshooterAbilitySet.uc:1286-1287 : Make Faceoff visualize applying bonus weapon effects and ammo effects to multi targets. #1332 - X2Ability_DefaultBondmateAbilities.uc:590-591 : Add the missing Stock damage effect. #1332 - X2Ability_DefaultBondmateAbilities.uc:666-667 : Add the missing Stock damage effect. #1332 - X2Ability_GrenadierAbilitySet.uc:640-641 : Add the missing Stock damage effect. #1332 - X2Ability_GrenadierAbilitySet.uc:788-789 : Add the missing Stock damage effect. #1332 - X2Ability_RangerAbilitySet.uc:760-761 : Add the missing Stock damage effect. #1332 - X2Ability_RangerAbilitySet.uc:823-824 : Add the missing Stock damage effect. #1332 - X2Ability_ReaperAbilitySet.uc:1172-1173 : Add the missing Stock damage effect. #1332 - X2Ability_ReaperAbilitySet.uc:1239-1240 : Add the missing Stock damage effect. #1332 - X2Ability_SharpshooterAbilitySet.uc:986-987 : Add the missing Stock damage effect. #1334 - X2Ability_ReaperAbilitySet.uc:1103-1104 : Use Weapon Typical Action Cost for Banish. #1334 - X2Ability_ReaperAbilitySet.uc:1275-1276 : Use Weapon Typical Action Cost for Sting. #1347 - UIUtilities_Strategy.uc:1940-1941 : Make GetMinimumContactCost() return zero when there are no more uncontacted regions to prevent Low Intel warnings. #1348 - UIArmory_MainMenu.uc:180-181 : Display the \"needs attention\" icon on the PCS button only if the soldier has an empty PCS slot. #1349 - X2Effect_PersistentVoidConduit.uc:62-66 : Fixes a bug in which the incorrect number of action points are removed from units under the effect of Void Conduit. This fix ensures that persistent effect remains on the unit during the tick instead of removing it. Furthermore, the on-tick visualization in X2Effect_VoidConduit was also found to be broken and hangs the visualiser so that is fixed as well. #1352 - XComGameState_HeadquartersXCom.uc:4160-4162 : Fixes a bug that caused PCS items which did not have exactly one stat boost, to not stack properly in the UI by making HasUnModifiedItem() properly compare items with multiple stat boosts or no stat boosts at all. #1353 - X2Ability_PsiOperativeAbilitySet.uc:306-307 : Fix issue with solace passive aura not applying to psi-operatives when more than one unit with the ability is present on the mission #1356 - XComHQPresentationLayer.uc:1515-1516 : ShowPromotionUI now casts the spawned promotion screen to UIArmory_Promotion instead of its subclasses #1372 - UIPhotoboothBase.uc:1378-1379 : Fixes a potential crash when the Photobooth shows many list items. #1380 - XComGameState_Effect.uc:272-276 : Fix bug where burst fire abilities with stacking effects were applying the wrong number of effect stacks to the target. This fix comments out base-game 'special handling' for burst-fire abilities - since each shot in the burst is handled independently, the stacking effects are already incremented in the onRefresh function so it is not necessary to additionally adjust them by the number of extra burst-fire shots when the ability is initiated. #1389 - X2Effect_Brutal.uc:14-15 : Make X2Effect_Brutal use unit's current Will instead of base Will so it can properly reduce and display it. #1391 - X2Ability_DLC_Day60ItemGrantedAbilitySet.uc:1121-1122 : Make Icarus Jump ability not offensive. #1391 - X2Ability_ChosenWarlock.uc:755-756 : Make Chosen Warlock's teleport ally ability not offensive. #1391 - X2Ability_Cyberus.uc:123-124 : Make Codex' teleport ability not offensive. #1391 - X2Ability_Cyberus.uc:381-382 : Make Codex' clone teleport ability not offensive. #1391 - X2Ability_Cyberus.uc:1257-1258 : Make MP Codex' teleport ability not offensive. #1391 - X2Ability_PsiWitch.uc:805-806 : Make Avatar's teleport-on-damage ability not offensive. #1393 - UIShellDifficulty.uc:1079-1083 : If skipping Intro movies, play the 'floating logo' movie instead of the standard intros. If nothing else plays here when starting a normal campaign, there is a high high chance of a hang on the loading screen. All of the downstream code is native so why this is required is not clear, but presumably some native code is expecting to find the end of a movie before initializing the start of the campaign / skyranger. #1394 - XComGameState_Ability.uc:1235-1240 : Abilities which do not specify a custom damage preview function will show rupture damage on the damage preview, even if the ability is not capable of doing any damage (e.g. self target abilities like reload). Checking that the previewed damage is non-zero before adding rupture damage to it mitigates this and improves the display (mainly for modded gameplay, but it also occurs in niche base game circumstances e.g. if a ruptured unit becomes mind controlled). #1395 - X2Helpers_DLC_Day60.uc:911-912 : Guard-rail to prevent vipers being able to target units grabbed by the archon king #1396 - X2Effect_ApplyWeaponDamage.uc:954-956 : Ensure that Damage-over-time effects applied by abilities that grazed or critted the target do not get their damage adjusted by checking for ApplyOnTick behavior #1398 - XGUnit.uc:1910-1914 : This fix adds additional checks to X2Action_ApplyWeaponDamageToUnit, to prevent 'Taking Damage' or 'Critically Wounded' voicelines from playing alongside the 'Death Scream' voiceline if a unit is killed. Additionally, it adds a delay to the 'Squad Member Dead' voicelines to reduce overlapy with deathscream voicelines that may already be playing. #1404 - X2Effect_Sustain.uc:50-51 : Update unit's lowest HP value when sustain activates since it wasn't being set properly before. #1408 - X2TargetingMethod_ArcWave.uc:124-125 : Fixes a bug with Arc Wave targeting where an ability could hit enemies not targeted by the player #1414 - X2Ability_SpecialistAbilitySet.uc:763-767 : Fixes the specialist's Revival Protocol and Restoration abilities to make them function as intended. Revival Protocol now can target any allied unit, not just units under player's control. Revival Protocol and Restoration now properly remove Stun, and no longer recover action points for Disoriented units. Revival Protocol now properly gets more Charges with higher GREMLIN tiers. #1417 - CHHelpers.uc:1157-1160 : This helper function uses a more robust check to ensure the geoscape is ready for alerts. This replaces functions that only check for the presence of a UIAlert screen, which can result in popups in places such as Squad Select or the Black Market screen if the campaign date lines up with flight time. #1419 - XGUnit.uc:1477-1478 : Characters that use WWise to play voicelines no longer attempt to play missing voicelines #1420 - XComTacticalInput.uc:3133-3134 : Abilities using X2TargetingMethod_ArcWave will now validate its additional targets when making a right-click pathing attack #1429 - XComGameState_Item.uc:796-800 : Fix bug that caused weapons that have weapon upgrades installed, despite not having any weapon upgrade slots, to stack in the HQ inventory, causing them to lose their installed upgrades when equipped. The fix removes the check for the number of weapon upgrade slots on the weapon from the logic that determines whether the item has been modified or not, and leaves just the check for number of installed weapon upgrades. #1431 - X2Effect_Knockback.uc:196-197 : Knockback actor trace is now a line trace: tracing with extents often resulted to units getting stuck on map geometry, moving no tiles #1431 - X2Effect_Knockback.uc:239-240 : Units knocked back may fly over units and land on them if they are high enough to take fall damage #1431 - X2Effect_Knockback.uc:358-359 : Units knocked back can now take fall damage falling from heights #1435 - X2Ability_SpecialistAbilitySet.uc:752-758 : Fix bug that allows Revival Protocol to remove effects that are normally removed by a Medikit heal, despite this functionality not being mentioned in the in-game localization, and units with these effects not being valid targets for this ability, unless they are also mentally impaired. The bug was caused by Firaxis reusing the RemoveAdditionalEffectsForRevivalProtocolAndRestorativeMist() function, which makes sense for Restoration, as that ability also applies Medikit heal, but not for Revival Protocol, which is only supposed to remove mental impairments. #1436 - X2Ability_SpecialistAbilitySet.uc:1242-1246 : Targeting conditions for the Restoration ability do not allow the ability to target units which have mental status effects but are not otherwise injured (or affected by an effect which can be removed by a medikit). This fix re-works the targeting conditions so that such units can be properly targeted. #1443 - X2HackReward.uc:301-303 : Fixes a bug where temporary hacking stat modifiers were being erroneously added to the Enemy Protocol hack reward bonus. Function adjusted to use GetBaseStat instead of GetMaxStat. #1459 - XComGameState_Ability.uc:1485-1486 : Unit carrying another unit now properly updates the location of the carried unit instead of reduntantly updating its own location again #1461 - XComUnitPawn.uc:1102-1103 : Animations that use a powered ragdoll work again after unit had been previously ragdolled #1466 - XComGameState_HeadquartersXCom.uc:7546-7551 : Do not cache mission data in GetGeneratedMissionData(). Doing so bloats the save file and causes problems for mods like LWOTC and CI, which need hacks to clear stale data from the cache. The cache is still used temporarily during the post-mission sequence, because the XCGS_MissionSite is deleted too early. #1498 - UITacticalHUD_MouseControls.uc:127-128 : Fix a crash when assigning commander abilities to invalid hotkeys #1508 - XGUnit.uc:1059-1060 : XGUnit.UnitSpeak can now allow alien pawns that are used for XCOM soldiers to use voicepacks and speak.","title":"Bugfixes"},{"location":"Bugfixes/#bugfixes","text":"This page accomodates all bug fixes that do not deserve their own documentation page, as they are simple enough to be entirely explained by a single line. #20 - X2Ability.uc:1517-1518 : Reaper's Banish now properly visualizes subsequent shots. #33 - XGUnitNativeBase.uc:543-544 : Gremlins owned by AI units now correctly use fast walk animations even if their owner is in Red Alert #36 - X2TacticalGameRuleset.uc:4851-4852 : Do not clear Reinforcements' \"Summoning Sickness\" when interrupted by Skirmisher, denying them an erronous bonus turn. #39 - UIArmory_WeaponUpgrade.uc:558-559 : Create weapon pawn before setting PawnLocationTag so that the weapon can rotate when previewing weapon upgrades. #42 - X2Action_ApplyWeaponDamageToUnit.uc:1286-1287 : Prevent X2Action_ApplyWeaponDamageToUnit from resetting unit's weapons to default sockets if the unit is interrupted. #51 - XComGameState_AdventChosen.uc:264-265 : Prevent Assassin from gaining perks incompatible with forced \"Shadowstep\" in Lost and Abandoned #55 - CHItemSlot.uc:349-350 : Check a soldier's NeedsSecondaryWeapon everywhere instead of hardcoding based on Rookie rank #70 - CharacterPoolManager.uc:449-450 : CharacterPoolManager:CreateCharacter now honors ForceCountry #95 - XComGameState_Unit.uc:13902-13903 : ResetRankToRookie now correctly applies Beta Strike HP bonuses #160 - UIOptionsPCScreen.uc:3148-3149 : UIOptionsPCScreen now shows all part pack sliders, adding a scroll bar if needed #215 - XGUnit.uc:1537-1538 : Units are now allowed to have personality speech (affected by personality) even below \"Veteran\" rank #269 - XComIdleAnimationStateMachine.uc:1101-1102 : Fix some edge cases in XComIdleAnimationStateMachine regarding idle animations, targeting, and step-outs #273 - X2Ability.uc:1571-1572 : Fix an issue causing Rapid Fire/Chain Shot/Banish/... entering cover early #303 - UITooltipInfoList.uc:98-99 : UITooltipInfoList no longer displays stale data like weapon upgrades from other units #318 - X2Camera_Cinescript.uc:528-529 : Fix Cinescript CutAfterPrevious not working in combination with MatineeReplacements , breaking Spark BIT hack camera #326 - X2Action_ApplyWeaponDamageToUnit.uc:205-207 : Allow damage flyovers from weapon-less Psi abilities to use the Psi damage popup (e.g. Effect Damage from X2Effect_ApplyWeaponDamage, PsiBombStage2 & modded abilities) #346 - X2AbilityToHitCalc_StandardAim.uc:387-388 : Prevent X2AbilityToHitCalc_StandardAim from applying BuiltInHitMod and BuiltInCritMod against non-units. #350 - XComCharacterCustomization.uc:546-548 : Updates various classes (XComCharacterCustomization, XCGS_Unit, XComHumanPawn and XGCharacterGenerator) to carry out proper validation and selection of valid body parts on soldiers when other parts are changed in the armory. #367 - XComGameState_Item.uc:486-487 : Gremlins now correctly die when the Gremlin's owner dies while the Gremlin is attached to another unit. #376 - XGUnit.uc:3771-3772 : Gremlins (and other Cosmetic Units) are now correctly tinted and patterned #379 - XComGameState_HuntersLodgeManager.uc:181-183 : Check if the Chosen is defeated to determine whether the Hunter's Lodge should display their trophy, rather than checking if XCOM has researched their weapons. #380 - XComCharacterCustomization.uc:825-826 : Update cosmetic pawns when secondary armor color is changed as well as primary #380 - XComUnitPawn.uc:2361-2362 : Ensure that the appearence of cosmetic unit pawns is updated properly, even when a new pawn is not created #384 - XComHumanPawn.uc:2370-2371 : Remove cosmetics from separate Left and Right Arm slots when updating Appearance to one that includes a cosmetic body part for both Arms in one slot. #384 - XComHumanPawn.uc:2437-2438 : Allow bForcedAppearance to work with new deco slots added with Anarchy Children and WOTC. #384 - XGCharacterGenerator.uc:714-715 : Randomize deco slots only if the character template is not using bForceAppearance . #426 - X2AbilityToHitCalc_StandardAim.uc:201-202 : Fix X2AbilityToHitCalc_StandardAim discarding unfavorable (for XCOM) changes to hit results from effects #493 - X2AbilityToHitCalc_StandardAim.uc:762-763 : Allow REACTION_DASHING_FINALMOD to reduce reaction fire hit chance against dashing targets #496 - X2Ability_Chosen.uc:1569-1570 : Fix the timeout during Chosen death teleport visualization by refactoring ChosenDefeatedEscape_BuildVisualization. #503 - XGAIBehavior.uc:9726-9727 : \"Flying\" pod leaders now patrol despite non-flat tiles on their paths #508 - XComGameState_AIGroup.uc:422-423 : Patrol logic now ensures units do not attempt to patrol outside of the map which would cause them to stop patrolling #520 - X2MeleePathingPawn.uc:186-187 : Controller input now allows choosing melee attack destination tile despite floor differences #531 - X2Ability_ChosenAssassin.uc:565-566 : Assassin gains a temporary instead of permanently stacking mobility boost from performing a melee attack #551 - X2Action_SwapTeams.uc:48-49 : Rescue rings no longer disappear on other rescuable units after a neutral unit swaps to team XCom #557 - XComGameState_Unit.uc:2434-2435 : Soldiers that have been carried out of a mission are no longer unable to be carried out of a later mission #608 - XComGameState_Unit.uc:4463-4464 : MergeAmmoAsNeeded now also works for units spawned from the Avenger #609 - XComGameState_Unit.uc:8239-8240 : Apply weapon customization from soldier appearance when equipping weapons. #613 - UIX2PanelHeader.uc:53-54 : SetText now sends text to flash instead of requiring calling SetHeaderWidth #617 - X2TargetingMethod_RocketLauncher.uc:44-45 : Ray trace from the peek tile to the target, not from the unit tile to the peek tile. #637 - XComGameState_Unit.uc:14801-14802 : Will recovery project and soldier mental state are now consistent with each other, fixing Shaken/Tired soldiers occasionally recovering instantly #638 - UIScanButton.uc:278-279 : UIScanButton can now work properly when it's a grandchild of UIStrategyMapItem, not only when direct child #644 - X2Ability_DefaultAbilitySet.uc:426-427 : Allow patrolling units to occupy the same tile instead of teleporting to (0,0,0) when out of space, potentially revealing XCOM #648 - UIHackingScreen.uc:410-411 : Cancelling a hack in progress using Esc no longer bypasses Haywire's cooldown #682 - XComGameState_Unit.uc:6979-6981 : Zombies will no longer drop loot. Only affects mods that destroy loot when killing units with explosives. #701 - UIArmory_LoadoutItem.uc:78-79 : Allows armory UI to highlight the item the player needs to build during the tutorial even if it's not the item with the exact template name 'Medikit' #775 - XGBase.uc:263-264 : Applying facility upgrades before the facility map is loaded no longer crashes the game. #817 - UIOptionsPCScreen.uc:1544-1545 : Disable the Framerate Smoothing option, as it's known to break Mod Class Overrides. #824 - XComGameState_Unit.uc:2581-2583 : Units that are still stunned when a mission ends no longer lose action points at the start of their next mission. #861 - UIStaffSlot.uc:223-227 : By default, UIStaffSlot removes highlighting when a personnel is selected. However, the slot still has navigator focus, and should remain highlighted. This only affects controllers since the mouse has moved off the button at this point. If a controller is active, don't let the game un-highlight it. #862 - UIStaffSlot.uc:405-408 : By default, UIStaffSlot will blink on and off a staff slot that \"loses\" focus when focus doesn't belong to it in the first place. Make sure to only change focus if the element is not already in the destination focus state #866 - UIStaffContainer.uc:58-60 : By default, UIStaffContainer tries to shortcut which UIPanel should receive focus, but the shortcut is often wrong and the time it saves is negligible, so this bypasses it. #879 - X2Ability.uc:815-816 : Use HistoryIndex to access the AbilityState as it was when the ability was activated rather than getting the most recent version. #879 - X2Ability.uc:834-835 : Use HistoryIndex to access the WeaponState as it was when the ability was activated rather than getting the most recent version. #880 - UIArmory_WeaponUpgrade.uc:750-751 : Remove unnecessary text coloring from the weapon pattern value text. #896 - X2Effect_ApplyWeaponDamage.uc:476-478 : Call the (hopefully) relevant delegate, if this weapon upgrade has it. This makes the guaranteed damage on missed shots added by Stocks properly benefit from Insider Knowledge #896 - X2Effect_ApplyWeaponDamage.uc:855-857 : Call the (hopefully) relevant delegate, if this weapon upgrade has it. This makes the guaranteed damage on missed shots added by Stocks properly benefit from Insider Knowledge #896 - X2Effect_LaserSight.uc:28-29 : Add bonus crit if Insider Knowledge is present. #924 - UIChoosePsiAbility.uc:211-212 : Prevent the psi ability training screen from showing duplicate abilities #927 - XComGameState_GeoscapeEntity.uc:311-314 : When cancelling out of squad select or mission launch, the selected map item will now return back to the mission rather than the Avenger (affects controller users). #952 - UIChosenInfo.uc:56-57 : Focus the top Chosen button when the screen is opened. #952 - UIChosenInfo.uc:431-432 : Fix typo in the MC function call. #990 - X2Ability_HackRewards.uc:736-738 : Trigger the hack reward ability only if it's present in the Game State. This prevents hack rewards from being granted multiple times. #1008 - XGAIBehavior.uc:10059-10061 : Entire pods no longer fail to scamper if the pod leader skips its turn, for example if it's immobilized. #1029 - SeqAct_SpawnUnitFromAvenger.uc:201-203 : Units spawned from the Avenger would sometimes not be able to take actions because their abilities weren't initialized properly. This is now fixed. #1035 - UICovertActions.uc:466-467 : Use SlotContainer.Navigator.SelectedIndex instead of Navigator.SelectedIndex to allow controller users editing all soldiers' loadouts. #1035 - UICovertActions.uc:1027-1028 : Use SlotContainer.Navigator.SelectedIndex instead of Navigator.SelectedIndex to allow controller users editing all soldiers' loadouts. #1035 - UICovertActions.uc:1031-1032 : Use SlotContainer.Navigator.SelectedIndex instead of Navigator.SelectedIndex to allow controller users editing all soldiers' loadouts. #1065 - UIArmory_LoadoutItem.uc:64-65 : UIArmory_LoadoutItem now shows the correct stack counts for modified finite items. #1073 - XComGameState_Unit.uc:13923-13924 : Get the unit's own Soldier Class Template rather than using Ranger's for all classes. #1082 - X2TacticalGameRuleset.uc:3012-3013 : MarkPlotUsed() - commented out original call and moved it outside of the if() statement #1090 - X2Item_DLC_Day60Armors.uc:64-67 : Prevent log warnings and redscreens when Alien Hunters armor is equipped in the Shell, e.g. Character Pool. Alien Hunters armor uses OnEquippedFn delegates to alter soldier appearance when the player equips them for the first time. The \"is first time\" check is done using XComHQ, which doesn't exist in the Shell. #1096 - UIChosenInfo.uc:155-156 : Abilities related to Chosen strengths and weaknesses now have their description expanded. #1096 - UIChosenInfo.uc:175 : #1096 - UIChosenLevelUp.uc:59 : #1096 - UIChosenReveal.uc:55 : #1096 - UIChosenReveal.uc:69 : #1108 - XComGameState_Unit.uc:8621-8622 : If there is a cosmetic pawn associated with the unequipped item item, remove it. #1118 - UICharacterPool_ListPools.uc:486-487 : LoadCharacterPool() may alter PoolFileName in certain conditions. #1120 - XComGameState_Unit.uc:14423-14424 : Add the effect's status icon only if it's not empty. #1131 - X2Ability_ReaperAbilitySet.uc:834-842 : A Target Condition on an X2Effect cannot be used to decide whether environmental damage should apply or not, because environmental damage is not triggered against any specific target, so there's nothing to check the condition against. The bugfix moves the condition logic into X2Effect_HomingMineDamage. This effect's condition is removed and the effect itself is neutered. The effect is left on the ability template to maintain the number of effects the same. #1145 - XComGameState_AIReinforcementSpawner.uc:283-284 : Reinforcements will now spawn their cosmetic units properly. Units spawned without their cosmetic units will crash when trying to use abilities that use them. #1171 - XComGameState_HeadquartersProjectHealSoldier.uc:81-83 : Round the HealthPercent value to prevent it landing above MaxHealthPercent of one Wound Severity, but below MinHealthPercent of the next one, making the code fail to select a Wound Severity at all. #1181 - UIFacilityGrid_FacilityOverlay.uc:1354-1355 : Make facility staff icons correctly display which staff slots are filled. #1182 - X2StrategyElement_XpackChosenActions.uc:326-327 : Make Defense Matrix properly reduce the chance of Chosen sabotage. #1190 - XComGameState_HeadquartersXCom.uc:4323-4326 : Fixes an issue where loot caches / hack rewards were ignoring the quantity of caches obtained (resulting in only a single cache reward of each type being awarded at the end of a mission, regardless of how many were obtained). Also fixes the issue where resources obtained from different cache types (e.g. Large + small intel) were not stacking in the post mission UI. #1192 - UIPawnMgr.uc:647-648 : Add call to StopSounds to remove sound effects for destroyed pawns. #1193 - XGAIPlayer.uc:939-941 : Added IsUnconcious and IsBleedingOut check to skip AI units in group who are Unconcious or Bleeding out as the AI processing hangs here until it times out, which causes the rest of the group to be skipped. #1195 - X2Ability_DefaultAbilitySet.uc:775-776 : Allow Return Fire shots to respond to enemy attacks if the enemy is in cover that requires a step out. #1196 - X2Ability_DefaultAbilitySet.uc:852-853 : Make Return Fire visualize after Covering Fire Overwatch, so they no longer fight for visualization. #1200 - X2AbilityToHitCalc.uc:126-127 : Make Dodge apply to Hit and Crit equally to fix Dodge increasing Miss chance. #1223 - X2Ability_CarryUnit.uc:304-305 : Added a skip exclusion for burning status so units can set down other carried units when they are on fire #1233 - UITacticalHUD_Enemies.uc:365-366 : Cache hit chances of visible targets to prevent multiple expensive GetHitChance() calls for each target. #1262 - X2Item_HeavyWeapons.uc:354-355 : Remove build time from the Shredstorm Cannon. #1274 - X2Action_ApplyWeaponDamageToUnit.uc:161-167 : Adjusted base-game logic for display of standard Red (Normal Damage), or Purple (Psionic) flyovers when damage is inflicted on a unit. Base game code first takes damage type from the weapon template, then if nothing is found, checks for DOTs / environmental damage. Issue #326 resolves flyovers for psionic effects not bound to weapons but modded abilities may wish to display the psionic flyover even when bound. The adjusted code changes the logic so the damagetype for flyovers is taken from the originating effect first, falls back to the weapon's base damage type and then uses default if nothing is found. #1276 - X2Ability_Chosen.uc:1770-1771 : Limit Chosen Low Profile to one trigger per turn. #1276 - X2Ability_Chosen.uc:1811-1813 : Comment out the effect that removes the Covering Fire effect responsible for triggering the Chosen Low Profile defense bonus ability, so it can trigger more than once per mission. #1281 - X2Effect_ApplyWeaponDamage.uc:671-672 : If the effect ignores all armor, max out the Pierce value in the Damage Preview so it will show up on the unit flag damage preview. #1286 - X2StatusEffects.uc:2490-2491 : Keep lure effect alive when source dies, tick on turn begin. Adjust icon and displayinfo to display as debuff rather than passive. #1288 - XComGameState_Effect.uc:1548-1551 : Fixes a bug in which a unit's cover may not be not correctly updated by the visibility manager when destructible actors are created directly adjacent to them (e.g. Pillar). The fix uses an eventlistener deferred to the end of the visualization block to clear and refresh the visibility manager. Resetting it in this way is a bit of a sledgehammer but since much of the cover/visibility system is native, limited viable alternatives exist. #1290 - XGUnit.uc:3231-3232 : Update XGUnit::DropWeapon() function with code from Chimera Squad to prevent unit weapons from glitching when dropped on death. #1293 - X2Ability_SkirmisherAbilitySet.uc:412-413 : Allow Justice to target enemies Mind Controlled by XCOM #1293 - X2Ability_SkirmisherAbilitySet.uc:687-688 : Allow Wrath to target enemies Mind Controlled by XCOM #1293 - X2Ability_SkirmisherAbilitySet.uc:815-816 : Allow Whiplash to target enemies Mind Controlled by XCOM #1293 - X2Ability_SkirmisherAbilitySet.uc:843-844 : Make enemies Mind Controlled by XCOM eligible for Whiplash's bonus damage #1298 - X2AbilityToHitCalc_StandardAim.uc:377-378 : Add 100 crit chance to guaranteed crit abilities for the purposes of UI. #1299 - X2Effect_ApplyWeaponDamage.uc:153-154 : Apply rupture after dealing the damage from the attack. #1299 - X2Effect_ApplyWeaponDamage.uc:970-971 : Remove the cap from the amount of bonus damage that can be added to an attack by rupture, and do not add rupture added by this attack to the attack's damage. #1300 - X2AbilityToHitCalc_StandardAim.uc:191-192 : Code block moved to be right after aim assist logic, so that if a miss is converted to a hit by aim assist, the ability will still crit if it is set up to always crit on hit. #1301 - XComIdleAnimationStateMachine.uc:934-935 : Targeting enemies from concealment will no longer make them face the unit doing the targeting. #1311 - X2Ability_SpecialistAbilitySet.uc:521-522 : Make Combat Protocol deal bonus damage to robots hacked by XCOM #1312 - X2Ability_StunLancer.uc:55-56 : Allow Stun Lance to target Mind Controlled units (currently on the same team as the Stun Lancer) #1318 - X2Condition_StasisLanceTarget.uc:27-28 : Disallow using Skulljack and Skullmine on units in Stasis. #1319 - X2TacticalGameRuleset.uc:1273-1279 : If mission start concealment is disabled by bForceNoSquadConcealment flag in BattleData, trigger the SquadConcealmentBroken event on mission start. In the base game, this flag is set only by the \"High Alert\" Dark Event. Triggering the event fixes the bug on Supply Extraction missions, where ADVENT never starts collecting supply crates if XCOM starts unconcealed, because the mission kismet starts the crate collection when the SquadConcealmentBroken event is triggered. #1320 - X2Action_ApplyWeaponDamageToUnit.uc:912-913 : Allow hit results other than eHit_Success to display flyovers. #1322 - X2Item_XpackWeapons.uc:495-496 : Comment out the line setting iTypicalActionCost for the conventional Vektor Rifle to match magnetic and beam variants. #1329 - X2Ability.uc:485-486 : Apply bonus weapon effects and ammo effects to multi targets. #1329 - X2Ability.uc:1166-1167 : Visualize bonus weapon effects and ammo effects being applied to multi targets. #1329 - X2Ability_GrenadierAbilitySet.uc:782-783 : Make Saturation Fire apply ammo effects and bonus weapon effects. #1329 - X2Ability_SharpshooterAbilitySet.uc:1182-1183 : Visualize applying bonus weapon effects and ammo effects to the primary target. #1329 - X2Ability_SharpshooterAbilitySet.uc:1286-1287 : Make Faceoff visualize applying bonus weapon effects and ammo effects to multi targets. #1332 - X2Ability_DefaultBondmateAbilities.uc:590-591 : Add the missing Stock damage effect. #1332 - X2Ability_DefaultBondmateAbilities.uc:666-667 : Add the missing Stock damage effect. #1332 - X2Ability_GrenadierAbilitySet.uc:640-641 : Add the missing Stock damage effect. #1332 - X2Ability_GrenadierAbilitySet.uc:788-789 : Add the missing Stock damage effect. #1332 - X2Ability_RangerAbilitySet.uc:760-761 : Add the missing Stock damage effect. #1332 - X2Ability_RangerAbilitySet.uc:823-824 : Add the missing Stock damage effect. #1332 - X2Ability_ReaperAbilitySet.uc:1172-1173 : Add the missing Stock damage effect. #1332 - X2Ability_ReaperAbilitySet.uc:1239-1240 : Add the missing Stock damage effect. #1332 - X2Ability_SharpshooterAbilitySet.uc:986-987 : Add the missing Stock damage effect. #1334 - X2Ability_ReaperAbilitySet.uc:1103-1104 : Use Weapon Typical Action Cost for Banish. #1334 - X2Ability_ReaperAbilitySet.uc:1275-1276 : Use Weapon Typical Action Cost for Sting. #1347 - UIUtilities_Strategy.uc:1940-1941 : Make GetMinimumContactCost() return zero when there are no more uncontacted regions to prevent Low Intel warnings. #1348 - UIArmory_MainMenu.uc:180-181 : Display the \"needs attention\" icon on the PCS button only if the soldier has an empty PCS slot. #1349 - X2Effect_PersistentVoidConduit.uc:62-66 : Fixes a bug in which the incorrect number of action points are removed from units under the effect of Void Conduit. This fix ensures that persistent effect remains on the unit during the tick instead of removing it. Furthermore, the on-tick visualization in X2Effect_VoidConduit was also found to be broken and hangs the visualiser so that is fixed as well. #1352 - XComGameState_HeadquartersXCom.uc:4160-4162 : Fixes a bug that caused PCS items which did not have exactly one stat boost, to not stack properly in the UI by making HasUnModifiedItem() properly compare items with multiple stat boosts or no stat boosts at all. #1353 - X2Ability_PsiOperativeAbilitySet.uc:306-307 : Fix issue with solace passive aura not applying to psi-operatives when more than one unit with the ability is present on the mission #1356 - XComHQPresentationLayer.uc:1515-1516 : ShowPromotionUI now casts the spawned promotion screen to UIArmory_Promotion instead of its subclasses #1372 - UIPhotoboothBase.uc:1378-1379 : Fixes a potential crash when the Photobooth shows many list items. #1380 - XComGameState_Effect.uc:272-276 : Fix bug where burst fire abilities with stacking effects were applying the wrong number of effect stacks to the target. This fix comments out base-game 'special handling' for burst-fire abilities - since each shot in the burst is handled independently, the stacking effects are already incremented in the onRefresh function so it is not necessary to additionally adjust them by the number of extra burst-fire shots when the ability is initiated. #1389 - X2Effect_Brutal.uc:14-15 : Make X2Effect_Brutal use unit's current Will instead of base Will so it can properly reduce and display it. #1391 - X2Ability_DLC_Day60ItemGrantedAbilitySet.uc:1121-1122 : Make Icarus Jump ability not offensive. #1391 - X2Ability_ChosenWarlock.uc:755-756 : Make Chosen Warlock's teleport ally ability not offensive. #1391 - X2Ability_Cyberus.uc:123-124 : Make Codex' teleport ability not offensive. #1391 - X2Ability_Cyberus.uc:381-382 : Make Codex' clone teleport ability not offensive. #1391 - X2Ability_Cyberus.uc:1257-1258 : Make MP Codex' teleport ability not offensive. #1391 - X2Ability_PsiWitch.uc:805-806 : Make Avatar's teleport-on-damage ability not offensive. #1393 - UIShellDifficulty.uc:1079-1083 : If skipping Intro movies, play the 'floating logo' movie instead of the standard intros. If nothing else plays here when starting a normal campaign, there is a high high chance of a hang on the loading screen. All of the downstream code is native so why this is required is not clear, but presumably some native code is expecting to find the end of a movie before initializing the start of the campaign / skyranger. #1394 - XComGameState_Ability.uc:1235-1240 : Abilities which do not specify a custom damage preview function will show rupture damage on the damage preview, even if the ability is not capable of doing any damage (e.g. self target abilities like reload). Checking that the previewed damage is non-zero before adding rupture damage to it mitigates this and improves the display (mainly for modded gameplay, but it also occurs in niche base game circumstances e.g. if a ruptured unit becomes mind controlled). #1395 - X2Helpers_DLC_Day60.uc:911-912 : Guard-rail to prevent vipers being able to target units grabbed by the archon king #1396 - X2Effect_ApplyWeaponDamage.uc:954-956 : Ensure that Damage-over-time effects applied by abilities that grazed or critted the target do not get their damage adjusted by checking for ApplyOnTick behavior #1398 - XGUnit.uc:1910-1914 : This fix adds additional checks to X2Action_ApplyWeaponDamageToUnit, to prevent 'Taking Damage' or 'Critically Wounded' voicelines from playing alongside the 'Death Scream' voiceline if a unit is killed. Additionally, it adds a delay to the 'Squad Member Dead' voicelines to reduce overlapy with deathscream voicelines that may already be playing. #1404 - X2Effect_Sustain.uc:50-51 : Update unit's lowest HP value when sustain activates since it wasn't being set properly before. #1408 - X2TargetingMethod_ArcWave.uc:124-125 : Fixes a bug with Arc Wave targeting where an ability could hit enemies not targeted by the player #1414 - X2Ability_SpecialistAbilitySet.uc:763-767 : Fixes the specialist's Revival Protocol and Restoration abilities to make them function as intended. Revival Protocol now can target any allied unit, not just units under player's control. Revival Protocol and Restoration now properly remove Stun, and no longer recover action points for Disoriented units. Revival Protocol now properly gets more Charges with higher GREMLIN tiers. #1417 - CHHelpers.uc:1157-1160 : This helper function uses a more robust check to ensure the geoscape is ready for alerts. This replaces functions that only check for the presence of a UIAlert screen, which can result in popups in places such as Squad Select or the Black Market screen if the campaign date lines up with flight time. #1419 - XGUnit.uc:1477-1478 : Characters that use WWise to play voicelines no longer attempt to play missing voicelines #1420 - XComTacticalInput.uc:3133-3134 : Abilities using X2TargetingMethod_ArcWave will now validate its additional targets when making a right-click pathing attack #1429 - XComGameState_Item.uc:796-800 : Fix bug that caused weapons that have weapon upgrades installed, despite not having any weapon upgrade slots, to stack in the HQ inventory, causing them to lose their installed upgrades when equipped. The fix removes the check for the number of weapon upgrade slots on the weapon from the logic that determines whether the item has been modified or not, and leaves just the check for number of installed weapon upgrades. #1431 - X2Effect_Knockback.uc:196-197 : Knockback actor trace is now a line trace: tracing with extents often resulted to units getting stuck on map geometry, moving no tiles #1431 - X2Effect_Knockback.uc:239-240 : Units knocked back may fly over units and land on them if they are high enough to take fall damage #1431 - X2Effect_Knockback.uc:358-359 : Units knocked back can now take fall damage falling from heights #1435 - X2Ability_SpecialistAbilitySet.uc:752-758 : Fix bug that allows Revival Protocol to remove effects that are normally removed by a Medikit heal, despite this functionality not being mentioned in the in-game localization, and units with these effects not being valid targets for this ability, unless they are also mentally impaired. The bug was caused by Firaxis reusing the RemoveAdditionalEffectsForRevivalProtocolAndRestorativeMist() function, which makes sense for Restoration, as that ability also applies Medikit heal, but not for Revival Protocol, which is only supposed to remove mental impairments. #1436 - X2Ability_SpecialistAbilitySet.uc:1242-1246 : Targeting conditions for the Restoration ability do not allow the ability to target units which have mental status effects but are not otherwise injured (or affected by an effect which can be removed by a medikit). This fix re-works the targeting conditions so that such units can be properly targeted. #1443 - X2HackReward.uc:301-303 : Fixes a bug where temporary hacking stat modifiers were being erroneously added to the Enemy Protocol hack reward bonus. Function adjusted to use GetBaseStat instead of GetMaxStat. #1459 - XComGameState_Ability.uc:1485-1486 : Unit carrying another unit now properly updates the location of the carried unit instead of reduntantly updating its own location again #1461 - XComUnitPawn.uc:1102-1103 : Animations that use a powered ragdoll work again after unit had been previously ragdolled #1466 - XComGameState_HeadquartersXCom.uc:7546-7551 : Do not cache mission data in GetGeneratedMissionData(). Doing so bloats the save file and causes problems for mods like LWOTC and CI, which need hacks to clear stale data from the cache. The cache is still used temporarily during the post-mission sequence, because the XCGS_MissionSite is deleted too early. #1498 - UITacticalHUD_MouseControls.uc:127-128 : Fix a crash when assigning commander abilities to invalid hotkeys #1508 - XGUnit.uc:1059-1060 : XGUnit.UnitSpeak can now allow alien pawns that are used for XCOM soldiers to use voicepacks and speak.","title":"Bugfixes"},{"location":"compatibility/","text":"Compatibility Because the Highlander is a core mod that many different mods on the workshop depend on, it strives to not make any observable changes to the base game (save for bug fixes and features that mods explicitly make use of). However, everything can potentially be a breaking change because the existing behavior rarely has any documentation in the game. Additionally, ModClassOverrides in mods occasionally override functions that were changed in the Highlander, essentially reverting the change and breaking a Highlander feature. As a result, sometimes modders need to pay special attention to Highlander features. This page is a list of pages tagged compatibility , indicating a potential incompatibility. Every page listed here has an section Compatibility that describes the issue and how modders can fix it. #155 - ArmorEquipRollDLCPartChance #257 - OverrideUnitFocusUI #290 - ScreenStackSubClasses #313 - GetStatModifiersFixed #511 - DLCRunOrder #524 - ModDependencyCheck #724 - DisplayCustomOverwatchActionPointOnUnitFlag #749 - OverrideAbilityIconColorImproved #763 - CustomTargetStyles #783 - ModifyGeneratedUnitAppearance #854 - OverrideCameraRotationAngle #909 - RequiredHighlanderVersion #923 - ExtraDamageModifierHooks #1057 - IsWeaponAllowedByClass","title":"Compatibility"},{"location":"compatibility/#compatibility","text":"Because the Highlander is a core mod that many different mods on the workshop depend on, it strives to not make any observable changes to the base game (save for bug fixes and features that mods explicitly make use of). However, everything can potentially be a breaking change because the existing behavior rarely has any documentation in the game. Additionally, ModClassOverrides in mods occasionally override functions that were changed in the Highlander, essentially reverting the change and breaking a Highlander feature. As a result, sometimes modders need to pay special attention to Highlander features. This page is a list of pages tagged compatibility , indicating a potential incompatibility. Every page listed here has an section Compatibility that describes the issue and how modders can fix it. #155 - ArmorEquipRollDLCPartChance #257 - OverrideUnitFocusUI #290 - ScreenStackSubClasses #313 - GetStatModifiersFixed #511 - DLCRunOrder #524 - ModDependencyCheck #724 - DisplayCustomOverwatchActionPointOnUnitFlag #749 - OverrideAbilityIconColorImproved #763 - CustomTargetStyles #783 - ModifyGeneratedUnitAppearance #854 - OverrideCameraRotationAngle #909 - RequiredHighlanderVersion #923 - ExtraDamageModifierHooks #1057 - IsWeaponAllowedByClass","title":"Compatibility"},{"location":"customization/","text":"Customization This is a list of all pages tagged \"customization\". #155 - ArmorEquipRollDLCPartChance #169 - UpdateHumanPawnMeshMaterial #216 - UpdateHumanPawnMeshComponent #219 - ModAddedHeads #317 - PersonalitySpeech #328 - BodyPartTemplateNames #356 - TintMaterialConfigs #397 - ChangeDefaultWeaponColor #783 - ModifyGeneratedUnitAppearance #832 - AdjustPositionOfWeaponPawn","title":"Customization"},{"location":"customization/#customization","text":"This is a list of all pages tagged \"customization\". #155 - ArmorEquipRollDLCPartChance #169 - UpdateHumanPawnMeshMaterial #216 - UpdateHumanPawnMeshComponent #219 - ModAddedHeads #317 - PersonalitySpeech #328 - BodyPartTemplateNames #356 - TintMaterialConfigs #397 - ChangeDefaultWeaponColor #783 - ModifyGeneratedUnitAppearance #832 - AdjustPositionOfWeaponPawn","title":"Customization"},{"location":"dlc2/","text":"DLC2 DLC2 (also known as DLC_2, DLC_60, AH and Alien Hunters) is the DLC that introduces Alien Rulers into the game. This page contains a list of features that allow mods to control the behaviour of various features included in DLC2. #771 - NonIntegratedAlienRulerLocations #791 - AllowRulerOnMission","title":"DLC2"},{"location":"dlc2/#dlc2","text":"DLC2 (also known as DLC_2, DLC_60, AH and Alien Hunters) is the DLC that introduces Alien Rulers into the game. This page contains a list of features that allow mods to control the behaviour of various features included in DLC2. #771 - NonIntegratedAlienRulerLocations #791 - AllowRulerOnMission","title":"DLC2"},{"location":"events/","text":"Events Many of the Highlander's features utilize Event Hooks . Mods can subscribe to any event by name, and then Read some of the data passed with the event Perform actions in response to the event Send data back to the sender of the event Especially the last option is something many Highlander hooks expect mods to do. This is done with the XComLWTuple class. It can contain arbitrary tagged data, can be read and written to by mods. Consider it a polymorphic tuple that is compatible with any event trigger/listener signature. HL Event documentation All Highlander-triggered events use a specification that looks like the following: OverridePromotionUIClass event Param Value EventID OverridePromotionUIClass EventData XComLWTuple EventSource XComHQPresentationLayer NewGameState none Tuple contents Index Name Type Direction 0 PromotionScreenType enum (CHLPromotionScreenType) in 1 PromotionUIClass class (class<UIArmory_Promotion>) inout Listener template static function EventListenerReturn OnOverridePromotionUIClass(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComHQPresentationLayer Pres; local XComLWTuple Tuple; local CHLPromotionScreenType PromotionScreenType; local class<UIArmory_Promotion> PromotionUIClass; Pres = XComHQPresentationLayer(EventSource); Tuple = XComLWTuple(EventData); PromotionScreenType = CHLPromotionScreenType(Tuple.Data[0].i); PromotionUIClass = class<UIArmory_Promotion>(Tuple.Data[1].o); // Your code here Tuple.Data[1].o = PromotionUIClass; return ELR_NoInterrupt; } The \"$event_name event\" paragraph describes which values a listener receives. EventID is the event name, EventData and EventSource list the types of the objects passed along, and NewGameState describes whether there is a NewGameState provided in the TriggerEvent call. If the EventData is an XComLWTuple , the \"Tuple contents\" paragraph lists the type and name of every variable passed using the tuple, along with its direction: An in variable has a meaningful value when the event is triggered, and mods may read it, usually to inspect the default value the game has determined. If a variable is not in , it may not be initialized when read from. An out variable will be read from by the game after all event listeners have been executed, usually with the expectation that a mod may have changed it to control some behaviors of the game. If a variable is not out , assigning to it is a no-op. An inout variable has a meaningful default value and will be read from after the event listeners have been executed. Note that exchanging data through an XComLWTuple requires subscribing to the event with the ELD_Immediate deferral. The \"Listener template\" is a copy-pasteable function that you can copy into your own mod as a starting point for using the event. Note: It is highly recommended that you use the CHEventListenerTemplate to subscribe to such events, as it is robust against history changes and allows you to provide the ELD_Immediate deferral. For this event, you would subscribe like this: Template.RegisterInStrategy = true; Template.AddCHEvent('OverridePromotionUIClass', OnOverridePromotionUIClass, ELD_Immediate, 50); Event-relevant pages The following is a list of all pages tagged \"Events\" due to their relevance to or use of the event system. #4 - CHEventListenerTemplate #93 - OverrideNumUpgradeSlots #106 - DynamicSoldierClassDisplay #110 - OnGetPCSImage #172 - OverrideHasHeavyWeapon #257 - OverrideUnitFocusUI #289 - ItemUpgraded #365 - Geoscape_ResInfoButtonVisible #365 - UIStrategyPolicy_ShowCovertActionsOnClose #368 - UIAvengerShortcuts_ShowCQResistanceOrders #391 - GetCovertActionEvents_Settings #393 - OverrideClipSize #400 - OverrideAbilityIconColor #408 - DynamicSoldierRankDisplay #420 - UpdateNavHelp #438 - CovertAction_PreventGiveRewards #448 - OverrideDisableReinforcementsFlare #490 - DrawDebugLabels #500 - OverrideEncounterZoneAnchorPoint #507 - OverridePatrolBehavior #534 - PsiProjectCompleted #561 - SitRepCheckAdditionalRequirements #562 - OnDistributeTacticalGameEndXp #562 - OverrideKillXp #562 - OverrideTotalNumKills #564 - AllowInteractHack #600 - OverridePromotionBlueprintTagPrefix #600 - OverridePromotionUIClass #624 - OverrideRespecSoldierProjectPoints #631 - OverrideShowPromoteIcon #633 - CanTechBeInspired #635 - OverrideMissionImage #650 - WillRecoveryTimeModifier #663 - UIResistanceReport_ShowCouncil #666 - ShouldCivilianRun #667 - OverrideNextRetaliationDisplay #676 - OnBestGearLoadoutApplied #694 - ItemAddedOrRemovedToSlot #711 - OverrideDarkEventCount #718 - OverridePatrolDestination #735 - OverrideHasAmmoPocket #735 - OverrideHasExtraUtilitySlot #735 - OverrideHasGrenadePocket #749 - OverrideAbilityIconColorImproved #752 - AllowOnCovertActionCompleteAnalytics #753 - PreDarkEventDeactivated #754 - XComLWTuple #774 - OverrideAllowStartingRegionLink #785 - PreCompleteStrategyFromTacticalTransfer #791 - AllowRulerOnMission #800 - PostInventoryLoadoutApplied #801 - FirstPromotionOverrideClass #807 - CovertAction_OverrideCostScalar #807 - CovertAction_OverrideRewardScalar #814 - ValidateGTSClassTraining #815 - OverrideEligibleTrainingCenterAbilities #825 - OverrideHitEffects #829 - OverrideProjectileInstance #837 - KismetGameStateMatinee #842 - OverrideHasInfiniteAmmo #844 - ShowItemInLockerList #864 - WorldRegionGetMeshScale #864 - WorldRegionGetStaticMesh #871 - HeadquartersUnitFired #875 - OverrideCanTakeFacilityMission #903 - OverrideDamageRemovesReserveActionPoints #921 - OverrideWeaponScale #932 - StrategyMap_NavHelpUpdated #986 - UIStrategyPolicy_MiscEvents #994 - AllowNoSquadSizeUpgradeAchievement #996 - OverrideReactionFireSlomo #1036 - OverrideEnemyFactionsAlertsOutsideVision #1094 - OverrideCanEquipImplant #1112 - GetLocalizedItemCategory #1116 - OverrideMetaHitEffect #1126 - OverrideInjuryClearingFatigueBehavior #1134 - OverrideStackedClassIcon #1150 - OverrideNegativeTraitRoll #1153 - FinalizePlayerStateForTacticalMusic #1218 - OverrideStrategyCostString #1303 - OverrideEligibleStartingRegion #1316 - PostUFOSetInterceptionTime #1354 - ShouldUnitPatrolUnderway #1406 - PostMissionIntroKismet #1509 - OverrideEffectIconColor","title":"Events"},{"location":"events/#events","text":"Many of the Highlander's features utilize Event Hooks . Mods can subscribe to any event by name, and then Read some of the data passed with the event Perform actions in response to the event Send data back to the sender of the event Especially the last option is something many Highlander hooks expect mods to do. This is done with the XComLWTuple class. It can contain arbitrary tagged data, can be read and written to by mods. Consider it a polymorphic tuple that is compatible with any event trigger/listener signature.","title":"Events"},{"location":"events/#hl-event-documentation","text":"All Highlander-triggered events use a specification that looks like the following:","title":"HL Event documentation"},{"location":"events/#overridepromotionuiclass-event","text":"Param Value EventID OverridePromotionUIClass EventData XComLWTuple EventSource XComHQPresentationLayer NewGameState none","title":"OverridePromotionUIClass event"},{"location":"events/#tuple-contents","text":"Index Name Type Direction 0 PromotionScreenType enum (CHLPromotionScreenType) in 1 PromotionUIClass class (class<UIArmory_Promotion>) inout","title":"Tuple contents"},{"location":"events/#listener-template","text":"static function EventListenerReturn OnOverridePromotionUIClass(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComHQPresentationLayer Pres; local XComLWTuple Tuple; local CHLPromotionScreenType PromotionScreenType; local class<UIArmory_Promotion> PromotionUIClass; Pres = XComHQPresentationLayer(EventSource); Tuple = XComLWTuple(EventData); PromotionScreenType = CHLPromotionScreenType(Tuple.Data[0].i); PromotionUIClass = class<UIArmory_Promotion>(Tuple.Data[1].o); // Your code here Tuple.Data[1].o = PromotionUIClass; return ELR_NoInterrupt; } The \"$event_name event\" paragraph describes which values a listener receives. EventID is the event name, EventData and EventSource list the types of the objects passed along, and NewGameState describes whether there is a NewGameState provided in the TriggerEvent call. If the EventData is an XComLWTuple , the \"Tuple contents\" paragraph lists the type and name of every variable passed using the tuple, along with its direction: An in variable has a meaningful value when the event is triggered, and mods may read it, usually to inspect the default value the game has determined. If a variable is not in , it may not be initialized when read from. An out variable will be read from by the game after all event listeners have been executed, usually with the expectation that a mod may have changed it to control some behaviors of the game. If a variable is not out , assigning to it is a no-op. An inout variable has a meaningful default value and will be read from after the event listeners have been executed. Note that exchanging data through an XComLWTuple requires subscribing to the event with the ELD_Immediate deferral. The \"Listener template\" is a copy-pasteable function that you can copy into your own mod as a starting point for using the event. Note: It is highly recommended that you use the CHEventListenerTemplate to subscribe to such events, as it is robust against history changes and allows you to provide the ELD_Immediate deferral. For this event, you would subscribe like this: Template.RegisterInStrategy = true; Template.AddCHEvent('OverridePromotionUIClass', OnOverridePromotionUIClass, ELD_Immediate, 50);","title":"Listener template"},{"location":"events/#event-relevant-pages","text":"The following is a list of all pages tagged \"Events\" due to their relevance to or use of the event system. #4 - CHEventListenerTemplate #93 - OverrideNumUpgradeSlots #106 - DynamicSoldierClassDisplay #110 - OnGetPCSImage #172 - OverrideHasHeavyWeapon #257 - OverrideUnitFocusUI #289 - ItemUpgraded #365 - Geoscape_ResInfoButtonVisible #365 - UIStrategyPolicy_ShowCovertActionsOnClose #368 - UIAvengerShortcuts_ShowCQResistanceOrders #391 - GetCovertActionEvents_Settings #393 - OverrideClipSize #400 - OverrideAbilityIconColor #408 - DynamicSoldierRankDisplay #420 - UpdateNavHelp #438 - CovertAction_PreventGiveRewards #448 - OverrideDisableReinforcementsFlare #490 - DrawDebugLabels #500 - OverrideEncounterZoneAnchorPoint #507 - OverridePatrolBehavior #534 - PsiProjectCompleted #561 - SitRepCheckAdditionalRequirements #562 - OnDistributeTacticalGameEndXp #562 - OverrideKillXp #562 - OverrideTotalNumKills #564 - AllowInteractHack #600 - OverridePromotionBlueprintTagPrefix #600 - OverridePromotionUIClass #624 - OverrideRespecSoldierProjectPoints #631 - OverrideShowPromoteIcon #633 - CanTechBeInspired #635 - OverrideMissionImage #650 - WillRecoveryTimeModifier #663 - UIResistanceReport_ShowCouncil #666 - ShouldCivilianRun #667 - OverrideNextRetaliationDisplay #676 - OnBestGearLoadoutApplied #694 - ItemAddedOrRemovedToSlot #711 - OverrideDarkEventCount #718 - OverridePatrolDestination #735 - OverrideHasAmmoPocket #735 - OverrideHasExtraUtilitySlot #735 - OverrideHasGrenadePocket #749 - OverrideAbilityIconColorImproved #752 - AllowOnCovertActionCompleteAnalytics #753 - PreDarkEventDeactivated #754 - XComLWTuple #774 - OverrideAllowStartingRegionLink #785 - PreCompleteStrategyFromTacticalTransfer #791 - AllowRulerOnMission #800 - PostInventoryLoadoutApplied #801 - FirstPromotionOverrideClass #807 - CovertAction_OverrideCostScalar #807 - CovertAction_OverrideRewardScalar #814 - ValidateGTSClassTraining #815 - OverrideEligibleTrainingCenterAbilities #825 - OverrideHitEffects #829 - OverrideProjectileInstance #837 - KismetGameStateMatinee #842 - OverrideHasInfiniteAmmo #844 - ShowItemInLockerList #864 - WorldRegionGetMeshScale #864 - WorldRegionGetStaticMesh #871 - HeadquartersUnitFired #875 - OverrideCanTakeFacilityMission #903 - OverrideDamageRemovesReserveActionPoints #921 - OverrideWeaponScale #932 - StrategyMap_NavHelpUpdated #986 - UIStrategyPolicy_MiscEvents #994 - AllowNoSquadSizeUpgradeAchievement #996 - OverrideReactionFireSlomo #1036 - OverrideEnemyFactionsAlertsOutsideVision #1094 - OverrideCanEquipImplant #1112 - GetLocalizedItemCategory #1116 - OverrideMetaHitEffect #1126 - OverrideInjuryClearingFatigueBehavior #1134 - OverrideStackedClassIcon #1150 - OverrideNegativeTraitRoll #1153 - FinalizePlayerStateForTacticalMusic #1218 - OverrideStrategyCostString #1303 - OverrideEligibleStartingRegion #1316 - PostUFOSetInterceptionTime #1354 - ShouldUnitPatrolUnderway #1406 - PostMissionIntroKismet #1509 - OverrideEffectIconColor","title":"Event-relevant pages"},{"location":"loadoutslots/","text":"Loadout Slots The Highlander has a number of features to add new loadout slots, change existing loadout slot availability, or modify which items can be equipped under which conditions. This is a list of pages tagged \"Loadoutslots\". #114 - CanAddItemToInventory #118 - CustomInventorySlots #171 - GetNumHeavyWeaponSlotsOverride #172 - OverrideHasHeavyWeapon #735 - OverrideHasAmmoPocket #735 - OverrideHasExtraUtilitySlot #735 - OverrideHasGrenadePocket #881 - ExtendHasHeavyWeapon","title":"Loadout Slots"},{"location":"loadoutslots/#loadout-slots","text":"The Highlander has a number of features to add new loadout slots, change existing loadout slot availability, or modify which items can be equipped under which conditions. This is a list of pages tagged \"Loadoutslots\". #114 - CanAddItemToInventory #118 - CustomInventorySlots #171 - GetNumHeavyWeaponSlotsOverride #172 - OverrideHasHeavyWeapon #735 - OverrideHasAmmoPocket #735 - OverrideHasExtraUtilitySlot #735 - OverrideHasGrenadePocket #881 - ExtendHasHeavyWeapon","title":"Loadout Slots"},{"location":"pawns/","text":"Pawns In the context of XCOM 2, Pawns are the Unreal-3D representation of units and weapons. These Pawns define the 3D meshes and materials, their attachments, animations, and state. A pawn always has an archetype that is usually specified in the template. When a unit or weapon is spawned, a clone of the archetype is created and placed in the 3D world. This leaves mods that want to make modifications with two options: Modify the archetype: The archetype can be dynamically loaded ( RequestGameArchetype / DynamicLoadObject ) by mods for modification. This can, especially with many mods, take a fair while as some mods would have to load every archetype they want to modify. It also interacts badly with the garbage collector, as unused archetypes will be removed from memory and have their changes reverted. Additionally, these changes are static; all future instances will be affected the same and different instances cannot receive individual changes. Modify the instance: The mod finds a way to modify the instance that was just created as a clone. This allows mods to change things that are considered properties of the archetype on a per-instance basis. However, it is difficult to reliably receive a notification when an archetype is cloned and a new instance is created. The Highlander can help with this by triggering events and calling DLC hooks whenever mods may need to change instance properties. This page contains a list of features that can help with pawn modification on a per-instance basis. #169 - UpdateHumanPawnMeshMaterial #216 - UpdateHumanPawnMeshComponent #219 - ModAddedHeads #281 - DLCAppendWeaponSockets #356 - TintMaterialConfigs #885 - DisplayMultiSlotItems #921 - OverrideWeaponScale","title":"Pawns"},{"location":"pawns/#pawns","text":"In the context of XCOM 2, Pawns are the Unreal-3D representation of units and weapons. These Pawns define the 3D meshes and materials, their attachments, animations, and state. A pawn always has an archetype that is usually specified in the template. When a unit or weapon is spawned, a clone of the archetype is created and placed in the 3D world. This leaves mods that want to make modifications with two options: Modify the archetype: The archetype can be dynamically loaded ( RequestGameArchetype / DynamicLoadObject ) by mods for modification. This can, especially with many mods, take a fair while as some mods would have to load every archetype they want to modify. It also interacts badly with the garbage collector, as unused archetypes will be removed from memory and have their changes reverted. Additionally, these changes are static; all future instances will be affected the same and different instances cannot receive individual changes. Modify the instance: The mod finds a way to modify the instance that was just created as a clone. This allows mods to change things that are considered properties of the archetype on a per-instance basis. However, it is difficult to reliably receive a notification when an archetype is cloned and a new instance is created. The Highlander can help with this by triggering events and calling DLC hooks whenever mods may need to change instance properties. This page contains a list of features that can help with pawn modification on a per-instance basis. #169 - UpdateHumanPawnMeshMaterial #216 - UpdateHumanPawnMeshComponent #219 - ModAddedHeads #281 - DLCAppendWeaponSockets #356 - TintMaterialConfigs #885 - DisplayMultiSlotItems #921 - OverrideWeaponScale","title":"Pawns"},{"location":"ui/","text":"User Interface The XCOM 2 user interface is mostly built in flash, but offers custom components that can be used to produce quite sophisticated screens and UI elements. For documentation on base game features, see XCOM 2 War of the Chosen SDK/Documentation/Tech/XCOM2Mods_UserInterface.pdf . However, extending existing UI screens can prove quite difficult, as UI screens do not expose any hooks for extending input handling or navigation help additions. The following features can help with making UI more extensible. #106 - DynamicSoldierClassDisplay #110 - OnGetPCSImage #198 - SubscribeToOnInput #365 - Geoscape_ResInfoButtonVisible #365 - UIStrategyPolicy_ShowCovertActionsOnClose #368 - UIAvengerShortcuts_ShowCQResistanceOrders #391 - GetCovertActionEvents_Settings #408 - DynamicSoldierRankDisplay #440 - UIStrategyPolicy_ScreenInit #483 - UIScanButtonOnMouseEvent #491 - OverrideImageForItemAvaliable #501 - SubscribeToOnInputForScreen #579 - UseMinDamageForUnitFlagPreview #600 - OverridePromotionBlueprintTagPrefix #600 - OverridePromotionUIClass #635 - OverrideMissionImage #663 - UIResistanceReport_ShowCouncil #875 - OverrideCanTakeFacilityMission #932 - StrategyMap_NavHelpUpdated #986 - UIStrategyPolicy_MiscEvents #1081 - PositiveTraitUI #1134 - OverrideStackedClassIcon #1218 - OverrideStrategyCostString","title":"User Interface"},{"location":"ui/#user-interface","text":"The XCOM 2 user interface is mostly built in flash, but offers custom components that can be used to produce quite sophisticated screens and UI elements. For documentation on base game features, see XCOM 2 War of the Chosen SDK/Documentation/Tech/XCOM2Mods_UserInterface.pdf . However, extending existing UI screens can prove quite difficult, as UI screens do not expose any hooks for extending input handling or navigation help additions. The following features can help with making UI more extensible. #106 - DynamicSoldierClassDisplay #110 - OnGetPCSImage #198 - SubscribeToOnInput #365 - Geoscape_ResInfoButtonVisible #365 - UIStrategyPolicy_ShowCovertActionsOnClose #368 - UIAvengerShortcuts_ShowCQResistanceOrders #391 - GetCovertActionEvents_Settings #408 - DynamicSoldierRankDisplay #440 - UIStrategyPolicy_ScreenInit #483 - UIScanButtonOnMouseEvent #491 - OverrideImageForItemAvaliable #501 - SubscribeToOnInputForScreen #579 - UseMinDamageForUnitFlagPreview #600 - OverridePromotionBlueprintTagPrefix #600 - OverridePromotionUIClass #635 - OverrideMissionImage #663 - UIResistanceReport_ShowCouncil #875 - OverrideCanTakeFacilityMission #932 - StrategyMap_NavHelpUpdated #986 - UIStrategyPolicy_MiscEvents #1081 - PositiveTraitUI #1134 - OverrideStackedClassIcon #1218 - OverrideStrategyCostString","title":"User Interface"},{"location":"misc/AdjustPositionOfWeaponPawn/","text":"AdjustPositionOfWeaponPawn Tracking Issue: #832 Tags: customization When a weapon pawn is displayed in the weapon upgrade view it sets the position to the root bone of the mesh at the center of the screen. Some weapon models simply do not fit correctly on the screen and obscure the UI. This fix aims to adjust that. It moves the position of the created pawn by specified offset values from a config entry in the XComUI.ini . x is left/right with moving left being positive y is fore/aft with moving aft being positive (zoom level) z is up/down with moving up being positive Use this feature by creating the following lines in XComUI.ini : [XComGame.UIArmory_WeaponUpgrade] ;template ;+WeaponViewOffsets=(Template=, offset_x=0.0, offset_y=0.0, offset_z=0.0) ;example that shifts the sniper rifles to the left, up a little and slightly smaller +WeaponViewOffsets=(Template=SniperRifle_CV, offset_x=20, offset_y=10, offset_z=10) +WeaponViewOffsets=(Template=SniperRifle_MG, offset_x=20, offset_y=10, offset_z=10) +WeaponViewOffsets=(Template=SniperRifle_BM, offset_x=20, offset_y=10, offset_z=10) Source code references UIArmory_WeaponUpgrade.uc:1201-1218","title":"AdjustPositionOfWeaponPawn"},{"location":"misc/AdjustPositionOfWeaponPawn/#adjustpositionofweaponpawn","text":"Tracking Issue: #832 Tags: customization When a weapon pawn is displayed in the weapon upgrade view it sets the position to the root bone of the mesh at the center of the screen. Some weapon models simply do not fit correctly on the screen and obscure the UI. This fix aims to adjust that. It moves the position of the created pawn by specified offset values from a config entry in the XComUI.ini . x is left/right with moving left being positive y is fore/aft with moving aft being positive (zoom level) z is up/down with moving up being positive Use this feature by creating the following lines in XComUI.ini : [XComGame.UIArmory_WeaponUpgrade] ;template ;+WeaponViewOffsets=(Template=, offset_x=0.0, offset_y=0.0, offset_z=0.0) ;example that shifts the sniper rifles to the left, up a little and slightly smaller +WeaponViewOffsets=(Template=SniperRifle_CV, offset_x=20, offset_y=10, offset_z=10) +WeaponViewOffsets=(Template=SniperRifle_MG, offset_x=20, offset_y=10, offset_z=10) +WeaponViewOffsets=(Template=SniperRifle_BM, offset_x=20, offset_y=10, offset_z=10)","title":"AdjustPositionOfWeaponPawn"},{"location":"misc/AdjustPositionOfWeaponPawn/#source-code-references","text":"UIArmory_WeaponUpgrade.uc:1201-1218","title":"Source code references"},{"location":"misc/ArmorEquipRollDLCPartChance/","text":"ArmorEquipRollDLCPartChance Tracking Issue: #155 Tags: customization , compatibility When a unit equips new armor, the game rolls from all customization options, even the ones where the slider for the DLCName is set to 0 . The HL change fixes this. Compatibility If your custom armor only has customization options with a DLCName set, the game may discard that DLCName (default: in 85% of cases) which results in soldiers without torsos. If you want to keep having DLCName -only armor (for example to display mod icons in UICustomize ), you must disable that behavior by creating the following lines in XComGame.ini : [XComGame.CHHelpers] +CosmeticDLCNamesUnaffectedByRoll=MyDLCName Source code references XComGameState_Unit.uc:8143-8157 XComGame.ini:32","title":"ArmorEquipRollDLCPartChance"},{"location":"misc/ArmorEquipRollDLCPartChance/#armorequiprolldlcpartchance","text":"Tracking Issue: #155 Tags: customization , compatibility When a unit equips new armor, the game rolls from all customization options, even the ones where the slider for the DLCName is set to 0 . The HL change fixes this.","title":"ArmorEquipRollDLCPartChance"},{"location":"misc/ArmorEquipRollDLCPartChance/#compatibility","text":"If your custom armor only has customization options with a DLCName set, the game may discard that DLCName (default: in 85% of cases) which results in soldiers without torsos. If you want to keep having DLCName -only armor (for example to display mod icons in UICustomize ), you must disable that behavior by creating the following lines in XComGame.ini : [XComGame.CHHelpers] +CosmeticDLCNamesUnaffectedByRoll=MyDLCName","title":"Compatibility"},{"location":"misc/ArmorEquipRollDLCPartChance/#source-code-references","text":"XComGameState_Unit.uc:8143-8157 XComGame.ini:32","title":"Source code references"},{"location":"misc/BetaStrikeEndTacticalHeal/","text":"BetaStrikeEndTacticalHeal Tracking Issue: #917 With Beta Strike enabled, soldiers are normally immediately healed for 50% of their missing HP after a mission. Uncomment this to disable this behavior. Source code references XComGameState_Unit.uc:2653 XComGame.ini:263-264","title":"BetaStrikeEndTacticalHeal"},{"location":"misc/BetaStrikeEndTacticalHeal/#betastrikeendtacticalheal","text":"Tracking Issue: #917 With Beta Strike enabled, soldiers are normally immediately healed for 50% of their missing HP after a mission. Uncomment this to disable this behavior.","title":"BetaStrikeEndTacticalHeal"},{"location":"misc/BetaStrikeEndTacticalHeal/#source-code-references","text":"XComGameState_Unit.uc:2653 XComGame.ini:263-264","title":"Source code references"},{"location":"misc/BodyPartTemplateNames/","text":"BodyPartTemplateNames Tracking Issue: #328 Tags: customization Allows Torso, Arms and Legs customization pieces to be uniquely localized. For templates, localization (i.e. providing strings for in-game display like names or descriptions) is handled using the object name that is the same as the template name. For example, given a template name of 'Female_LongStraight' , the template is created by giving the X2BodyPartTemplate that name: // Object name -------vvvvvvvvvvvvvvvvvvv Template = new(None, \"Female_LongStraight\") class'X2BodyPartTemplate'; Template.SetTemplateName('Female_LongStraight'); // Template name ---------^^^^^^^^^^^^^^^^^^^ On the localization side, the object name is used to localize the DisplayName : ;vvvvvvvvvvvvvvvvvvv--- Object name [Female_LongStraight X2BodyPartTemplate] DisplayName=\"Long Straight\" Body part templates are different from normal templates in that templates for different customization categories are allowed to have the same name. In vanilla, there are collisions for Torso , Arms and Legs so there is a Conventional Medium Male Torso, an Arms piece, and a Legs piece with the name CnvMed_Std_A_M . However, in order for localization to work, there must be no object name collisions. As a result, the game opts to not assign any object name to Torsos, Arms, and Legs, and instead simply shows them as \"Torso 1\", \"Torso 2\" and so on. Because mods may want to localize their pieces, this Highlander change gives all armor pieces a unique object name. This happens using the following algorithm for every BodyPartTemplateConfig entry: If the PartType is not \"Torso\" , \"Arms\" , \"Legs\" , the object name and the template name are taken from TemplateName in the config entry (vanilla behavior). If the PartType is \"Torso\" , \"Arms\" , or \"Legs\" : If TemplateName contains that part type, then the object name and the template name are taken from TemplateName in the config entry. If TemplateName does not contain that part type, then the template name is taken from TemplateName , and the object name is created by appending an underscore and the part type to the template name. Additionally, the UI is changed to use the DisplayName for Torso/Arms/Legs, and fall back to numbered vanilla display if no DisplayName is provided. A table with some examples: Config PartType Config TemplateName Resulting Template Name Resulting Object Name \"Torso\" \"CnvMed_Std_A_M\" 'CnvMed_Std_A_M' \"CnvMed_Std_A_M_Torso\" \"Helmets\" \"Reaper_Hood_A_M\" 'Reaper_Hood_A_M' \"Reaper_Hood_A_M\" \"Torso\" \"DLC_30_Torso_M\" 'DLC_30_Torso_M' \"DLC_30_Torso_M\" Source code references X2BodyPartTemplateManager.uc:65-117 XComCharacterCustomization.uc:1114","title":"BodyPartTemplateNames"},{"location":"misc/BodyPartTemplateNames/#bodyparttemplatenames","text":"Tracking Issue: #328 Tags: customization Allows Torso, Arms and Legs customization pieces to be uniquely localized. For templates, localization (i.e. providing strings for in-game display like names or descriptions) is handled using the object name that is the same as the template name. For example, given a template name of 'Female_LongStraight' , the template is created by giving the X2BodyPartTemplate that name: // Object name -------vvvvvvvvvvvvvvvvvvv Template = new(None, \"Female_LongStraight\") class'X2BodyPartTemplate'; Template.SetTemplateName('Female_LongStraight'); // Template name ---------^^^^^^^^^^^^^^^^^^^ On the localization side, the object name is used to localize the DisplayName : ;vvvvvvvvvvvvvvvvvvv--- Object name [Female_LongStraight X2BodyPartTemplate] DisplayName=\"Long Straight\" Body part templates are different from normal templates in that templates for different customization categories are allowed to have the same name. In vanilla, there are collisions for Torso , Arms and Legs so there is a Conventional Medium Male Torso, an Arms piece, and a Legs piece with the name CnvMed_Std_A_M . However, in order for localization to work, there must be no object name collisions. As a result, the game opts to not assign any object name to Torsos, Arms, and Legs, and instead simply shows them as \"Torso 1\", \"Torso 2\" and so on. Because mods may want to localize their pieces, this Highlander change gives all armor pieces a unique object name. This happens using the following algorithm for every BodyPartTemplateConfig entry: If the PartType is not \"Torso\" , \"Arms\" , \"Legs\" , the object name and the template name are taken from TemplateName in the config entry (vanilla behavior). If the PartType is \"Torso\" , \"Arms\" , or \"Legs\" : If TemplateName contains that part type, then the object name and the template name are taken from TemplateName in the config entry. If TemplateName does not contain that part type, then the template name is taken from TemplateName , and the object name is created by appending an underscore and the part type to the template name. Additionally, the UI is changed to use the DisplayName for Torso/Arms/Legs, and fall back to numbered vanilla display if no DisplayName is provided. A table with some examples: Config PartType Config TemplateName Resulting Template Name Resulting Object Name \"Torso\" \"CnvMed_Std_A_M\" 'CnvMed_Std_A_M' \"CnvMed_Std_A_M_Torso\" \"Helmets\" \"Reaper_Hood_A_M\" 'Reaper_Hood_A_M' \"Reaper_Hood_A_M\" \"Torso\" \"DLC_30_Torso_M\" 'DLC_30_Torso_M' \"DLC_30_Torso_M\"","title":"BodyPartTemplateNames"},{"location":"misc/BodyPartTemplateNames/#source-code-references","text":"X2BodyPartTemplateManager.uc:65-117 XComCharacterCustomization.uc:1114","title":"Source code references"},{"location":"misc/CHDLCHookManager/","text":"CHDLCHookManager Tracking Issue: #212 The CHDLCHookManager class is an internal component of CHL that allows us to retrieve only DLCs (X2DownloadableContentInfo classes) that override a specific function or event by method name. It was introduced to optimize the number of calls made on X2DownloadableContentInfo classes. Instead of CHL calling X2DLCI methods on every known DLC class (which can grow large), it uses `DLCHOOKMGR.GetDLCInfos('MethodName') to fetch only the DLCs that actually override a method with that name. Any base classes (except X2DownloadableContentInfo itself) that override a method with that name are also returned. One very noticeable example is the UpdateHumanPawnMeshComponent/Material hook. UpdateHumanPawnMeshComponent has a default implementation that always loops through the materials of the mesh component, performs some type checking, and then forwards the call to the UpdateHumanPawnMeshMaterial method for backward compatibility, which has an empty default implementation. The unfortunate side effect of this, with large mod lists and calling UpdateHumanPawnMeshComponent on all DLC classes, is that it does a lot of work for nothing. Moreover, this method is actually called twice in a single frame due to the logic of XGunitNativeBase.ResetWeaponsToDefaultSockets, amplifying the effect even further. Profiling using a large mod list has shown significantly reduced frame times in places where these methods were called, especially the ones which have a default implementation. Special care must be taken by CHL developers when making changes to the X2DownloadableContentInfo class, as they might need supporting changes to the CHDLCHookManager class. This is especially important when introducing new versions of existing hooks; follow the comments in the source of CHDLCHookManager.uc Source code references CHDLCHookManager.uc:1-32","title":"CHDLCHookManager"},{"location":"misc/CHDLCHookManager/#chdlchookmanager","text":"Tracking Issue: #212 The CHDLCHookManager class is an internal component of CHL that allows us to retrieve only DLCs (X2DownloadableContentInfo classes) that override a specific function or event by method name. It was introduced to optimize the number of calls made on X2DownloadableContentInfo classes. Instead of CHL calling X2DLCI methods on every known DLC class (which can grow large), it uses `DLCHOOKMGR.GetDLCInfos('MethodName') to fetch only the DLCs that actually override a method with that name. Any base classes (except X2DownloadableContentInfo itself) that override a method with that name are also returned. One very noticeable example is the UpdateHumanPawnMeshComponent/Material hook. UpdateHumanPawnMeshComponent has a default implementation that always loops through the materials of the mesh component, performs some type checking, and then forwards the call to the UpdateHumanPawnMeshMaterial method for backward compatibility, which has an empty default implementation. The unfortunate side effect of this, with large mod lists and calling UpdateHumanPawnMeshComponent on all DLC classes, is that it does a lot of work for nothing. Moreover, this method is actually called twice in a single frame due to the logic of XGunitNativeBase.ResetWeaponsToDefaultSockets, amplifying the effect even further. Profiling using a large mod list has shown significantly reduced frame times in places where these methods were called, especially the ones which have a default implementation. Special care must be taken by CHL developers when making changes to the X2DownloadableContentInfo class, as they might need supporting changes to the CHDLCHookManager class. This is especially important when introducing new versions of existing hooks; follow the comments in the source of CHDLCHookManager.uc","title":"CHDLCHookManager"},{"location":"misc/CHDLCHookManager/#source-code-references","text":"CHDLCHookManager.uc:1-32","title":"Source code references"},{"location":"misc/CHEventListenerTemplate/","text":"CHEventListenerTemplate Tracking Issue: #4 Tags: events Allows mods to set up Event Listener classes with specified Deferral and Priority, similar to X2AbilityTrigger_EventListener. The AddCHEvent function accepts up to four arguments: Name of the Event to listen for. EventFn to run when the event is triggered. Optional: Deferral (default deferral is ELD_OnStateSubmitted). Visit the r/xcom2mods wiki for info on Deferrals. Optional: Priority (default priority is 50). Event listeners with the larger priority number are executed first. Example use: class X2EventListener_YourEventListener extends X2EventListener; static function array<X2DataTemplate> CreateTemplates() { local array<X2DataTemplate> Templates; // You can create any number of Event Listener templates within one X2EventListener class. Templates.AddItem(CreateListenerTemplate_YourListener()); return Templates; } static function CHEventListenerTemplate CreateListenerTemplate_OnBestGearLoadoutApplied() { local CHEventListenerTemplate Template; `CREATE_X2TEMPLATE(class'CHEventListenerTemplate', Template, 'Your_Custom_BestGearApplied_Listener'); // Whether this Listener should be active during tactical missions. Template.RegisterInTactical = true; // Whether this Listener should be active on the strategic layer (while on Avenger) Template.RegisterInStrategy = true; Template.AddCHEvent('EventName', YourEventFn_Listener, ELD_Immediate, 50); return Template; } static function EventListenerReturn YourEventFn_Listener(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { if (GameState.GetContext().InterruptionStatus == eInterruptionStatus_Interrupt) { // Perform actions if the event was triggered during interruption stage. } else { // Perform actions outside interruption stage (after an ability was successfully activated, for example) } return ELR_NoInterrupt; } Source code references CHEventListenerTemplate.uc:2-55","title":"CHEventListenerTemplate"},{"location":"misc/CHEventListenerTemplate/#cheventlistenertemplate","text":"Tracking Issue: #4 Tags: events Allows mods to set up Event Listener classes with specified Deferral and Priority, similar to X2AbilityTrigger_EventListener. The AddCHEvent function accepts up to four arguments: Name of the Event to listen for. EventFn to run when the event is triggered. Optional: Deferral (default deferral is ELD_OnStateSubmitted). Visit the r/xcom2mods wiki for info on Deferrals. Optional: Priority (default priority is 50). Event listeners with the larger priority number are executed first. Example use: class X2EventListener_YourEventListener extends X2EventListener; static function array<X2DataTemplate> CreateTemplates() { local array<X2DataTemplate> Templates; // You can create any number of Event Listener templates within one X2EventListener class. Templates.AddItem(CreateListenerTemplate_YourListener()); return Templates; } static function CHEventListenerTemplate CreateListenerTemplate_OnBestGearLoadoutApplied() { local CHEventListenerTemplate Template; `CREATE_X2TEMPLATE(class'CHEventListenerTemplate', Template, 'Your_Custom_BestGearApplied_Listener'); // Whether this Listener should be active during tactical missions. Template.RegisterInTactical = true; // Whether this Listener should be active on the strategic layer (while on Avenger) Template.RegisterInStrategy = true; Template.AddCHEvent('EventName', YourEventFn_Listener, ELD_Immediate, 50); return Template; } static function EventListenerReturn YourEventFn_Listener(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { if (GameState.GetContext().InterruptionStatus == eInterruptionStatus_Interrupt) { // Perform actions if the event was triggered during interruption stage. } else { // Perform actions outside interruption stage (after an ability was successfully activated, for example) } return ELR_NoInterrupt; }","title":"CHEventListenerTemplate"},{"location":"misc/CHEventListenerTemplate/#source-code-references","text":"CHEventListenerTemplate.uc:2-55","title":"Source code references"},{"location":"misc/CanAddItemToInventory/","text":"CanAddItemToInventory Tracking Issue: #114 Tags: loadoutslots This DLC hook can be used to override the game's default behavior when it comes to whether a particular unit should be able to equip a particular item into a particular inventory slot. Using this hook can be complicated, and since it runs every time any unit attempts to equip any item, it must be handled with extreme care to avoid unintentional changes to inventory item restrictions, and to reduce the performance impact as much as possible. (1) To disallow equipping an item that normally can be equipped, set bCanAddItem = 0; provide a localized DisabledReason and return CheckGameState != none; (2) To allow equipping an item that normally cannot be equipped, do the following: DisabledReason = \"\"; if (CheckGameState != none && UnitState.GetItemInSlot(Slot, CheckGameState) == none) { bCanAddItem = 1; } `return CheckGameState != none; The GetItemInSlot() == none check is critically important for non-multi-item slots, it is necessary to make sure the unit does not end up equipping an item into a slot that already has another item in it. (3) If you do not wish to override game's default behavior in this instance, return CheckGameState == none; Example use: static function bool CanAddItemToInventory_CH_Improved(out int bCanAddItem, const EInventorySlot Slot, const X2ItemTemplate ItemTemplate, int Quantity, XComGameState_Unit UnitState, optional XComGameState CheckGameState, optional out string DisabledReason, optional XComGameState_Item ItemState) { local X2ArmorTemplate ArmorTemplate; local X2WeaponTemplate WeaponTemplate; local bool OverrideNormalBehavior; local bool DoNotOverrideNormalBehavior; // Prepare return values to make it easier for us to read the code. OverrideNormalBehavior = CheckGameState != none; DoNotOverrideNormalBehavior = CheckGameState == none; if (Slot == eInvSlot_Armor) { ArmorTemplate = X2ArmorTemplate(ItemTemplate); if (ArmorTemplate != none && ArmorTemplate.ArmorCat == 'CyborgArmor' && !UnitState.HasSoldierAbility('CyborgUnlockAbility')) { // If the unit does not have the Cyborg Ability, disallow equipping Cyborg Armor. DisabledReason = mStr_CyborgOnly; bCanAddItem = 0; return OverrideNormalBehavior; } } else if (Slot == eInvSlot_PrimaryWeapon) { WeaponTemplate = X2WeaponTemplate(ItemTemplate); if (WeaponTemplate != none && WeaponTemplate.WeaponCat == 'sparkrifle' && UnitState.HasSoldierAbility('CyborgUnlockAbility')) { // If the unit has Cyborg Ability, allow equipping SPARK Weapons. DisabledReason = \"\"; if (CheckGameState != none && UnitState.GetItemInSlot(Slot, CheckGameState) == none) { bCanAddItem = 1; } return OverrideNormalBehavior; } } return DoNotOverrideNormalBehavior; } Source code references X2DownloadableContentInfo.uc:300-367","title":"CanAddItemToInventory"},{"location":"misc/CanAddItemToInventory/#canadditemtoinventory","text":"Tracking Issue: #114 Tags: loadoutslots This DLC hook can be used to override the game's default behavior when it comes to whether a particular unit should be able to equip a particular item into a particular inventory slot. Using this hook can be complicated, and since it runs every time any unit attempts to equip any item, it must be handled with extreme care to avoid unintentional changes to inventory item restrictions, and to reduce the performance impact as much as possible. (1) To disallow equipping an item that normally can be equipped, set bCanAddItem = 0; provide a localized DisabledReason and return CheckGameState != none; (2) To allow equipping an item that normally cannot be equipped, do the following: DisabledReason = \"\"; if (CheckGameState != none && UnitState.GetItemInSlot(Slot, CheckGameState) == none) { bCanAddItem = 1; } `return CheckGameState != none; The GetItemInSlot() == none check is critically important for non-multi-item slots, it is necessary to make sure the unit does not end up equipping an item into a slot that already has another item in it. (3) If you do not wish to override game's default behavior in this instance, return CheckGameState == none; Example use: static function bool CanAddItemToInventory_CH_Improved(out int bCanAddItem, const EInventorySlot Slot, const X2ItemTemplate ItemTemplate, int Quantity, XComGameState_Unit UnitState, optional XComGameState CheckGameState, optional out string DisabledReason, optional XComGameState_Item ItemState) { local X2ArmorTemplate ArmorTemplate; local X2WeaponTemplate WeaponTemplate; local bool OverrideNormalBehavior; local bool DoNotOverrideNormalBehavior; // Prepare return values to make it easier for us to read the code. OverrideNormalBehavior = CheckGameState != none; DoNotOverrideNormalBehavior = CheckGameState == none; if (Slot == eInvSlot_Armor) { ArmorTemplate = X2ArmorTemplate(ItemTemplate); if (ArmorTemplate != none && ArmorTemplate.ArmorCat == 'CyborgArmor' && !UnitState.HasSoldierAbility('CyborgUnlockAbility')) { // If the unit does not have the Cyborg Ability, disallow equipping Cyborg Armor. DisabledReason = mStr_CyborgOnly; bCanAddItem = 0; return OverrideNormalBehavior; } } else if (Slot == eInvSlot_PrimaryWeapon) { WeaponTemplate = X2WeaponTemplate(ItemTemplate); if (WeaponTemplate != none && WeaponTemplate.WeaponCat == 'sparkrifle' && UnitState.HasSoldierAbility('CyborgUnlockAbility')) { // If the unit has Cyborg Ability, allow equipping SPARK Weapons. DisabledReason = \"\"; if (CheckGameState != none && UnitState.GetItemInSlot(Slot, CheckGameState) == none) { bCanAddItem = 1; } return OverrideNormalBehavior; } } return DoNotOverrideNormalBehavior; }","title":"CanAddItemToInventory"},{"location":"misc/CanAddItemToInventory/#source-code-references","text":"X2DownloadableContentInfo.uc:300-367","title":"Source code references"},{"location":"misc/ChangeDefaultWeaponColor/","text":"ChangeDefaultWeaponColor Tracking Issue: #397 Tags: customization Soldiers with randomly generated appearance get the beige weapon color by default (color number 20). This change moves the default weapon color number to XComContent.ini , where it can be changed by mods or by the player manually. [XComGame.XGCharacterGenerator] iDefaultWeaponTint = 20 Source code references XGCharacterGenerator.uc:903-910","title":"ChangeDefaultWeaponColor"},{"location":"misc/ChangeDefaultWeaponColor/#changedefaultweaponcolor","text":"Tracking Issue: #397 Tags: customization Soldiers with randomly generated appearance get the beige weapon color by default (color number 20). This change moves the default weapon color number to XComContent.ini , where it can be changed by mods or by the player manually. [XComGame.XGCharacterGenerator] iDefaultWeaponTint = 20","title":"ChangeDefaultWeaponColor"},{"location":"misc/ChangeDefaultWeaponColor/#source-code-references","text":"XGCharacterGenerator.uc:903-910","title":"Source code references"},{"location":"misc/ClassIsNative/","text":"ClassIsNative Tracking Issue: #767 To check whether a given class is native, use the static function CH_ClassIsNative . Example usage: CH_ClassIsNative(class'X2AbilityTarget_Single'); // True CH_ClassIsNative(UnitState.GetVisualizer().Class); // False because XGUnit is always non-native Source code references Object.uc:2411-2418","title":"ClassIsNative"},{"location":"misc/ClassIsNative/#classisnative","text":"Tracking Issue: #767 To check whether a given class is native, use the static function CH_ClassIsNative . Example usage: CH_ClassIsNative(class'X2AbilityTarget_Single'); // True CH_ClassIsNative(UnitState.GetVisualizer().Class); // False because XGUnit is always non-native","title":"ClassIsNative"},{"location":"misc/ClassIsNative/#source-code-references","text":"Object.uc:2411-2418","title":"Source code references"},{"location":"misc/ComponentVersions/","text":"ComponentVersions Tracking Issue: #765 Both the Highlander and mods using it may be interested in whether replacements for base game packages (\"components\") are installed, and if, which version. This can be used to Behave differently depending on whether a HL feature is available Provide more targeted error messages when a certain HL version is required For example, if you are interested in whether version 1.19.0 of the Highlander is correctly enabled, you can use the following: if (class'CHXComGameVersionTemplate' != none && (class'CHXComGameVersionTemplate'.default.MajorVersion > 1 || (class'CHXComGameVersionTemplate'.default.MajorVersion == 1 && class'CHXComGameVersionTemplate'.default.MinorVersion >= 19) ) ) { // Installed, do thing A } else { // Not installed or wrong version, do thing B } For other classes, see Source code references below. Note that you can employ feature-based detection if the feature can be distinguished by the presence of a certain function or property. For example, OverrideUnitFocusUI can be detected with the following trick: if (Function'XComGame.CHHelpers.GetFocusTuple' != none) { // Feature present } else { // Feature absent } Source code references CHXComGameVersionTemplate.uc:12-55 CHDLC2Version.uc:1 CHCoreVersion.uc:1 CHEngineVersion.uc:1 CHX2WOTCCHVersion.uc:1","title":"ComponentVersions"},{"location":"misc/ComponentVersions/#componentversions","text":"Tracking Issue: #765 Both the Highlander and mods using it may be interested in whether replacements for base game packages (\"components\") are installed, and if, which version. This can be used to Behave differently depending on whether a HL feature is available Provide more targeted error messages when a certain HL version is required For example, if you are interested in whether version 1.19.0 of the Highlander is correctly enabled, you can use the following: if (class'CHXComGameVersionTemplate' != none && (class'CHXComGameVersionTemplate'.default.MajorVersion > 1 || (class'CHXComGameVersionTemplate'.default.MajorVersion == 1 && class'CHXComGameVersionTemplate'.default.MinorVersion >= 19) ) ) { // Installed, do thing A } else { // Not installed or wrong version, do thing B } For other classes, see Source code references below. Note that you can employ feature-based detection if the feature can be distinguished by the presence of a certain function or property. For example, OverrideUnitFocusUI can be detected with the following trick: if (Function'XComGame.CHHelpers.GetFocusTuple' != none) { // Feature present } else { // Feature absent }","title":"ComponentVersions"},{"location":"misc/ComponentVersions/#source-code-references","text":"CHXComGameVersionTemplate.uc:12-55 CHDLC2Version.uc:1 CHCoreVersion.uc:1 CHEngineVersion.uc:1 CHX2WOTCCHVersion.uc:1","title":"Source code references"},{"location":"misc/CustomInventorySlots/","text":"CustomInventorySlots Tracking Issue: #118 Tags: loadoutslots This feature defines additional inventory slots in the Highlander for mods to use. Configuration is done via CHItemSlot . More docs to follow. enum EInventorySlot { eInvSlot_Unknown, eInvSlot_Armor, eInvSlot_PrimaryWeapon, eInvSlot_SecondaryWeapon, eInvSlot_HeavyWeapon, eInvSlot_Utility, eInvSlot_Mission, eInvSlot_Backpack, eInvSlot_Loot, eInvSlot_GrenadePocket, eInvSlot_CombatSim, eInvSlot_AmmoPocket, eInvSlot_TertiaryWeapon, eInvSlot_QuaternaryWeapon, eInvSlot_QuinaryWeapon, eInvSlot_SenaryWeapon, eInvSlot_SeptenaryWeapon, // Add a marker slot, and buffer in case Firaxis adds more in the future // ALL MARKER SLOTS SHOULD NOT BE USED IN CODE OTHER THAN XCOMGAME // CHItemSlotTemplate has static helper functions for this purpose! // Since enums are compile-time constants, mods may have old values // that don't apply anymore for markers. eInvSlot_END_VANILLA_SLOTS, eInvSlot_Buffer018, eInvSlot_Buffer019, eInvSlot_Buffer020, eInvSlot_Buffer021, eInvSlot_Buffer022, eInvSlot_Buffer023, eInvSlot_Buffer024, eInvSlot_Buffer025, eInvSlot_Buffer026, eInvSlot_Buffer027, eInvSlot_Buffer028, eInvSlot_Buffer029, eInvSlot_Buffer030, eInvSlot_Buffer031, // again, don't use in mod code eInvSlot_BEGIN_TEMPLATED_SLOTS, // Custom slots begin here. We have space for ~220 slots, should be enough! // These slots can be used in Mod code and config values eInvSlot_Vest, eInvSlot_AugmentationHead, eInvSlot_AugmentationTorso, eInvSlot_AugmentationArms, eInvSlot_AugmentationLegs, eInvSlot_CombatDrugs, eInvSlot_Decorations, eInvSlot_PsiAmp, eInvSlot_Plating, eInvSlot_SparkLauncher, eInvSlot_ExtraSecondary, eInvSlot_PrimaryPayload, eInvSlot_SecondaryPayload, eInvSlot_ExtraRocket1, eInvSlot_ExtraRocket2, eInvSlot_ExtraRocket3, eInvSlot_ExtraRocket4, eInvSlot_Pistol, eInvSlot_Wings, eInvSlot_ExtraBackpack, eInvSlot_SparkGrenadePocket, eInvSlot_AuxiliaryWeapon, eInvSlot_AModMedical, eInvSlot_ArmorMod, eInvSlot_TacticalGadget, eInvSlot_MZAux, eInvSlot_TemplateMaster, eInvSlot_ViperMAW, eInvSlot_SparkComputer, eInvSlot_SparkActuator, eInvSlot_SparkModule, eInvSlot_ExtraGrenadePocket, eInvSlot_ExtraLandMine, // Marker slot, don't use eInvSlot_END_TEMPLATED_SLOTS, }; If you need additional enum entries, request them in the tracking issue. Source code references X2TacticalGameRulesetDataStructures.uc:38-124 CHItemSlot.uc:13","title":"CustomInventorySlots"},{"location":"misc/CustomInventorySlots/#custominventoryslots","text":"Tracking Issue: #118 Tags: loadoutslots This feature defines additional inventory slots in the Highlander for mods to use. Configuration is done via CHItemSlot . More docs to follow. enum EInventorySlot { eInvSlot_Unknown, eInvSlot_Armor, eInvSlot_PrimaryWeapon, eInvSlot_SecondaryWeapon, eInvSlot_HeavyWeapon, eInvSlot_Utility, eInvSlot_Mission, eInvSlot_Backpack, eInvSlot_Loot, eInvSlot_GrenadePocket, eInvSlot_CombatSim, eInvSlot_AmmoPocket, eInvSlot_TertiaryWeapon, eInvSlot_QuaternaryWeapon, eInvSlot_QuinaryWeapon, eInvSlot_SenaryWeapon, eInvSlot_SeptenaryWeapon, // Add a marker slot, and buffer in case Firaxis adds more in the future // ALL MARKER SLOTS SHOULD NOT BE USED IN CODE OTHER THAN XCOMGAME // CHItemSlotTemplate has static helper functions for this purpose! // Since enums are compile-time constants, mods may have old values // that don't apply anymore for markers. eInvSlot_END_VANILLA_SLOTS, eInvSlot_Buffer018, eInvSlot_Buffer019, eInvSlot_Buffer020, eInvSlot_Buffer021, eInvSlot_Buffer022, eInvSlot_Buffer023, eInvSlot_Buffer024, eInvSlot_Buffer025, eInvSlot_Buffer026, eInvSlot_Buffer027, eInvSlot_Buffer028, eInvSlot_Buffer029, eInvSlot_Buffer030, eInvSlot_Buffer031, // again, don't use in mod code eInvSlot_BEGIN_TEMPLATED_SLOTS, // Custom slots begin here. We have space for ~220 slots, should be enough! // These slots can be used in Mod code and config values eInvSlot_Vest, eInvSlot_AugmentationHead, eInvSlot_AugmentationTorso, eInvSlot_AugmentationArms, eInvSlot_AugmentationLegs, eInvSlot_CombatDrugs, eInvSlot_Decorations, eInvSlot_PsiAmp, eInvSlot_Plating, eInvSlot_SparkLauncher, eInvSlot_ExtraSecondary, eInvSlot_PrimaryPayload, eInvSlot_SecondaryPayload, eInvSlot_ExtraRocket1, eInvSlot_ExtraRocket2, eInvSlot_ExtraRocket3, eInvSlot_ExtraRocket4, eInvSlot_Pistol, eInvSlot_Wings, eInvSlot_ExtraBackpack, eInvSlot_SparkGrenadePocket, eInvSlot_AuxiliaryWeapon, eInvSlot_AModMedical, eInvSlot_ArmorMod, eInvSlot_TacticalGadget, eInvSlot_MZAux, eInvSlot_TemplateMaster, eInvSlot_ViperMAW, eInvSlot_SparkComputer, eInvSlot_SparkActuator, eInvSlot_SparkModule, eInvSlot_ExtraGrenadePocket, eInvSlot_ExtraLandMine, // Marker slot, don't use eInvSlot_END_TEMPLATED_SLOTS, }; If you need additional enum entries, request them in the tracking issue.","title":"CustomInventorySlots"},{"location":"misc/CustomInventorySlots/#source-code-references","text":"X2TacticalGameRulesetDataStructures.uc:38-124 CHItemSlot.uc:13","title":"Source code references"},{"location":"misc/DLCAppendWeaponSockets/","text":"DLCAppendWeaponSockets Tracking Issue: #281 Tags: pawns Allows mods to add, move and rescale sockets on the skeletal mesh of any weapon, which can be used to position visual weapon attachments, using different position/scale of the same attachment's skeletal mesh for different weapons. Example use: static function DLCAppendWeaponSockets(out array<SkeletalMeshSocket> NewSockets, XComWeapon Weapon, XComGameState_Item ItemState) { local SkeletalMeshSocket Socket; local vector RelativeLocation; local rotator RelativeRotation; local vector RelativeScale; if (ItemState != none) { Socket = new class'SkeletalMeshSocket'; Socket.SocketName = 'NewSocket'; Socket.BoneName = 'root'; // Location offsets are in Unreal Units; 1 unit is roughly equal to a centimeter. RelativeLocation.X = 5; RelativeLocation.Y = 10; RelativeLocation.Z = 15; Socket.RelativeLocation = RelativeLocation; // Socket rotation is recorded as an int value [-65535; 65535], which corresponds with [-360 degrees; 360 degrees] // If we want to specify the rotation in degrees, the value must be converted using DegToUnrRot, a const in the Object class. RelativeRotation.Pitch = 5 * DegToUnrRot; // Pitch of five degrees. RelativeRotation.Yaw = 10 * DegToUnrRot; RelativeRotation.Roll = 15 * DegToUnrRot; Socket.RelativeRotation = RelativeRotation; // Scaling a socket will scale any mesh attached to it. RelativeScale.X = 0.25f; RelativeScale.Y = 0.5f; RelativeScale.Z = 1.0f; Socket.RelativeScale = RelativeScale; NewSockets.AddItem(Socket); } } Sockets that have the name of an existing socket will replace the original socket. This can be used to move, rotate, and rescale existing sockets. Source code references X2DownloadableContentInfo.uc:650-693","title":"DLCAppendWeaponSockets"},{"location":"misc/DLCAppendWeaponSockets/#dlcappendweaponsockets","text":"Tracking Issue: #281 Tags: pawns Allows mods to add, move and rescale sockets on the skeletal mesh of any weapon, which can be used to position visual weapon attachments, using different position/scale of the same attachment's skeletal mesh for different weapons. Example use: static function DLCAppendWeaponSockets(out array<SkeletalMeshSocket> NewSockets, XComWeapon Weapon, XComGameState_Item ItemState) { local SkeletalMeshSocket Socket; local vector RelativeLocation; local rotator RelativeRotation; local vector RelativeScale; if (ItemState != none) { Socket = new class'SkeletalMeshSocket'; Socket.SocketName = 'NewSocket'; Socket.BoneName = 'root'; // Location offsets are in Unreal Units; 1 unit is roughly equal to a centimeter. RelativeLocation.X = 5; RelativeLocation.Y = 10; RelativeLocation.Z = 15; Socket.RelativeLocation = RelativeLocation; // Socket rotation is recorded as an int value [-65535; 65535], which corresponds with [-360 degrees; 360 degrees] // If we want to specify the rotation in degrees, the value must be converted using DegToUnrRot, a const in the Object class. RelativeRotation.Pitch = 5 * DegToUnrRot; // Pitch of five degrees. RelativeRotation.Yaw = 10 * DegToUnrRot; RelativeRotation.Roll = 15 * DegToUnrRot; Socket.RelativeRotation = RelativeRotation; // Scaling a socket will scale any mesh attached to it. RelativeScale.X = 0.25f; RelativeScale.Y = 0.5f; RelativeScale.Z = 1.0f; Socket.RelativeScale = RelativeScale; NewSockets.AddItem(Socket); } } Sockets that have the name of an existing socket will replace the original socket. This can be used to move, rotate, and rescale existing sockets.","title":"DLCAppendWeaponSockets"},{"location":"misc/DLCAppendWeaponSockets/#source-code-references","text":"X2DownloadableContentInfo.uc:650-693","title":"Source code references"},{"location":"misc/DLCRunOrder/","text":"DLCRunOrder Tracking Issue: #511 Tags: compatibility The base game and Highlander have many \"DLC hooks\": Overridable functions in X2DownloadableContentInfo that the game calls for all mods in some order so that mods can do something. The most ubiquitous hook is OnPostTemplatesCreated , which allows mods to modify templates. Unfortunately, the order in which the DLC hooks of mods are executed (\"run order\") depends on load order, which is not guaranteed . However, run order can matter a lot. Consider a mod that creates copies of guns with different visuals: This mod really wants to run after mods that make changes to specific guns (e.g. stat changes) so that the changes translate to the copies. The CHL Run Order system provides two ways for mods to specify their position within the run order. This information is relayed to the Highlander using configuration entries (XComGame.ini): [zzzWeaponSkinReplacer.X2DownloadableContentInfo_WeaponSkinReplacer] DLCIdentifier=\"zzzWeaponSkinReplacer\" [zzzWeaponSkinReplacer CHDLCRunOrder] +RunAfter=PrimarySecondaries +RunAfter=XCOM2RPGOverhaul +RunBefore=WOTCUnderbarrelAttachments RunPriorityGroup=RUN_LAST Since this system is all about DLC Hooks, the important identifier here is the DLCIdentifier corresponding to a X2DownloadableContentInfo class, of which a mod may have zero, one or more. The DLCIdentifier is case-sensitive . Run Order is about DLCInfos, not individual mods, and a mod may have an X2DLCInfo that runs before a certain other X2DLCInfo and another that runs after that other one. Coarse (RunPriorityGroup) RunPriorityGroup is a coarse way for DLCInfos to control when they run. RunPriorityGroup can have three different values: RUN_STANDARD , RUN_FIRST and RUN_LAST . RUN_STANDARD is the default. All DLCInfos with RUN_FIRST always run before all RUN_STANDARD ones, and all DLCInfos with RUN_LAST always run after all RUN_STANDARD ones. A DLCInfo with RunPriorityGroup=RUN_LAST already runs after the vast majority of other DLCInfos. Fine (RunBefore/RunAfter) Within these groups, DLCInfos can specify which other DLCInfos they run before and after. [A] +RunBefore=\"B\" is equivalent to specifying [B] +RunAfter=\"A\" . If A and B were in a different RunPriorityGroup , their relative RunBefore / RunAfter lines would be ignored. Errors The Highlander catches some potential configuration errors and writes them to the log. Warnings and errors are printed to the log, errors are shown to the user in combination with a list of DLCIdentifiers whose authors they should report the error to. It is a warning for a DLCInfo B to RunAfter a DLCInfo A, or A to RunBefore B, if A is in an earlier RunPriorityGroup than B, since these config lines are redundant and always fulfilled. It is an error for a DLCInfo B to RunAfter a DLCInfo A, or A to RunBefore B, if A is in a later RunPriorityGroup than B, since these config lines are contradictions and never fulfilled. It is an error for any number of DLCInfos to cause a cycle, since cycles have no solution that fulfills all requirements. The console command CHLDumpRunOrderInternals can be used to print all the information the CHL has about X2DownloadableContentInfo classes to the log, for debugging purposes. One configuration error that can't be caught is a missing DLCIdentifier . If your X2DownloadableContentInfo subclass specifies a custom config file via config(CustomConfig) , then the DLCIdentifier needs to go in XComCustomConfig.ini , while the CHDLCRunOrder still goes in XComGame.ini . Splitting DLCInfo Sometimes it can be useful to split your DLC Infos into two different classes, one containing all changes that can run whenever ( RUN_STANDARD ) and one that needs to make its changes last. You can simply create more subclasses and specify run order for any of them: X2DownloadableContentInfo_NormalChanges.uc class X2DownloadableContentInfo_NormalChanges extends X2DownloadableContentInfo; static event OnPostTemplatesCreated() { // Make regular changes here } X2DownloadableContentInfo_LastChanges.uc class X2DownloadableContentInfo_LastChanges extends X2DownloadableContentInfo; static event OnPostTemplatesCreated() { // Make last changes here } XComGame.ini [MyMod.X2DownloadableContentInfo_NormalChanges] DLCIdentifier=\"MyModNormal\" [MyMod.X2DownloadableContentInfo_LastChanges] DLCIdentifier=\"MyModLast\" [MyModLast CHDLCRunOrder] RunPriorityGroup=RUN_LAST This combats the trend of mods to move all their changes to RUN_LAST because they contain only one change that actually needs to run last. This trend can be problematic because it requires explicit RunAfter annotations in other mods if they want to run after your normal changes. Splitting DLCInfos can help mods that use RUN_LAST do the right thing by default. Source code references CHDLCRunOrder.uc:1-126 CHOnlineEventMgr.uc:2 XLocalizedData.uc:237","title":"DLCRunOrder"},{"location":"misc/DLCRunOrder/#dlcrunorder","text":"Tracking Issue: #511 Tags: compatibility The base game and Highlander have many \"DLC hooks\": Overridable functions in X2DownloadableContentInfo that the game calls for all mods in some order so that mods can do something. The most ubiquitous hook is OnPostTemplatesCreated , which allows mods to modify templates. Unfortunately, the order in which the DLC hooks of mods are executed (\"run order\") depends on load order, which is not guaranteed . However, run order can matter a lot. Consider a mod that creates copies of guns with different visuals: This mod really wants to run after mods that make changes to specific guns (e.g. stat changes) so that the changes translate to the copies. The CHL Run Order system provides two ways for mods to specify their position within the run order. This information is relayed to the Highlander using configuration entries (XComGame.ini): [zzzWeaponSkinReplacer.X2DownloadableContentInfo_WeaponSkinReplacer] DLCIdentifier=\"zzzWeaponSkinReplacer\" [zzzWeaponSkinReplacer CHDLCRunOrder] +RunAfter=PrimarySecondaries +RunAfter=XCOM2RPGOverhaul +RunBefore=WOTCUnderbarrelAttachments RunPriorityGroup=RUN_LAST Since this system is all about DLC Hooks, the important identifier here is the DLCIdentifier corresponding to a X2DownloadableContentInfo class, of which a mod may have zero, one or more. The DLCIdentifier is case-sensitive . Run Order is about DLCInfos, not individual mods, and a mod may have an X2DLCInfo that runs before a certain other X2DLCInfo and another that runs after that other one.","title":"DLCRunOrder"},{"location":"misc/DLCRunOrder/#coarse-runprioritygroup","text":"RunPriorityGroup is a coarse way for DLCInfos to control when they run. RunPriorityGroup can have three different values: RUN_STANDARD , RUN_FIRST and RUN_LAST . RUN_STANDARD is the default. All DLCInfos with RUN_FIRST always run before all RUN_STANDARD ones, and all DLCInfos with RUN_LAST always run after all RUN_STANDARD ones. A DLCInfo with RunPriorityGroup=RUN_LAST already runs after the vast majority of other DLCInfos.","title":"Coarse (RunPriorityGroup)"},{"location":"misc/DLCRunOrder/#fine-runbeforerunafter","text":"Within these groups, DLCInfos can specify which other DLCInfos they run before and after. [A] +RunBefore=\"B\" is equivalent to specifying [B] +RunAfter=\"A\" . If A and B were in a different RunPriorityGroup , their relative RunBefore / RunAfter lines would be ignored.","title":"Fine (RunBefore/RunAfter)"},{"location":"misc/DLCRunOrder/#errors","text":"The Highlander catches some potential configuration errors and writes them to the log. Warnings and errors are printed to the log, errors are shown to the user in combination with a list of DLCIdentifiers whose authors they should report the error to. It is a warning for a DLCInfo B to RunAfter a DLCInfo A, or A to RunBefore B, if A is in an earlier RunPriorityGroup than B, since these config lines are redundant and always fulfilled. It is an error for a DLCInfo B to RunAfter a DLCInfo A, or A to RunBefore B, if A is in a later RunPriorityGroup than B, since these config lines are contradictions and never fulfilled. It is an error for any number of DLCInfos to cause a cycle, since cycles have no solution that fulfills all requirements. The console command CHLDumpRunOrderInternals can be used to print all the information the CHL has about X2DownloadableContentInfo classes to the log, for debugging purposes. One configuration error that can't be caught is a missing DLCIdentifier . If your X2DownloadableContentInfo subclass specifies a custom config file via config(CustomConfig) , then the DLCIdentifier needs to go in XComCustomConfig.ini , while the CHDLCRunOrder still goes in XComGame.ini .","title":"Errors"},{"location":"misc/DLCRunOrder/#splitting-dlcinfo","text":"Sometimes it can be useful to split your DLC Infos into two different classes, one containing all changes that can run whenever ( RUN_STANDARD ) and one that needs to make its changes last. You can simply create more subclasses and specify run order for any of them: X2DownloadableContentInfo_NormalChanges.uc class X2DownloadableContentInfo_NormalChanges extends X2DownloadableContentInfo; static event OnPostTemplatesCreated() { // Make regular changes here } X2DownloadableContentInfo_LastChanges.uc class X2DownloadableContentInfo_LastChanges extends X2DownloadableContentInfo; static event OnPostTemplatesCreated() { // Make last changes here } XComGame.ini [MyMod.X2DownloadableContentInfo_NormalChanges] DLCIdentifier=\"MyModNormal\" [MyMod.X2DownloadableContentInfo_LastChanges] DLCIdentifier=\"MyModLast\" [MyModLast CHDLCRunOrder] RunPriorityGroup=RUN_LAST This combats the trend of mods to move all their changes to RUN_LAST because they contain only one change that actually needs to run last. This trend can be problematic because it requires explicit RunAfter annotations in other mods if they want to run after your normal changes. Splitting DLCInfos can help mods that use RUN_LAST do the right thing by default.","title":"Splitting DLCInfo"},{"location":"misc/DLCRunOrder/#source-code-references","text":"CHDLCRunOrder.uc:1-126 CHOnlineEventMgr.uc:2 XLocalizedData.uc:237","title":"Source code references"},{"location":"misc/DateAndTimeFormattingChanges/","text":"DateAndTimeFormattingChanges Tracking Issue: #1400 Allow forcing the 24h clock independently of locale and add an option to display leading zeroes for military-style time - e.g. 03:41 instead of 3:41 Source code references X2StrategyGameRulesetDataStructures.uc:1570-1571","title":"DateAndTimeFormattingChanges"},{"location":"misc/DateAndTimeFormattingChanges/#dateandtimeformattingchanges","text":"Tracking Issue: #1400 Allow forcing the 24h clock independently of locale and add an option to display leading zeroes for military-style time - e.g. 03:41 instead of 3:41","title":"DateAndTimeFormattingChanges"},{"location":"misc/DateAndTimeFormattingChanges/#source-code-references","text":"X2StrategyGameRulesetDataStructures.uc:1570-1571","title":"Source code references"},{"location":"misc/DebugStartSecondWave/","text":"DebugStartSecondWave Tracking Issue: #197 A debug strategy start by default uses Beta Strike and no other second wave options. This change disables Beta Strike by default and makes the list configurable. XComGameData.ini : [XComGame.XGStrategy] ; uncomment for Beta Strike ;+DEBUG_SecondWaveOptions=\"BetaStrike\" Source code references XGStrategy.uc:760-762 XComGameData.ini:1-8","title":"DebugStartSecondWave"},{"location":"misc/DebugStartSecondWave/#debugstartsecondwave","text":"Tracking Issue: #197 A debug strategy start by default uses Beta Strike and no other second wave options. This change disables Beta Strike by default and makes the list configurable. XComGameData.ini : [XComGame.XGStrategy] ; uncomment for Beta Strike ;+DEBUG_SecondWaveOptions=\"BetaStrike\"","title":"DebugStartSecondWave"},{"location":"misc/DebugStartSecondWave/#source-code-references","text":"XGStrategy.uc:760-762 XComGameData.ini:1-8","title":"Source code references"},{"location":"misc/DisableAutoPhotos/","text":"DisableAutoPhotos Tracking Issue: #1453 Several places in the game (UIAfterAction, XComHQPresentationLayer, UISoldierBondConfirmScree and UIMissionSummary) request the auto-generation of photos for the photobooth. Such photos are coded to be taken when the user doesn't take a photo manually at the end of a mission, when a soldier above Sergeant rank dies, when a soldier is promoted to Sergeant or Major rank and when two soldiers are bonded. The auto-photos are usually of poor quality and the ability to disable them is a useful feature for modders. Source code references UIAfterAction.uc:116-121 XComGame.ini:301","title":"DisableAutoPhotos"},{"location":"misc/DisableAutoPhotos/#disableautophotos","text":"Tracking Issue: #1453 Several places in the game (UIAfterAction, XComHQPresentationLayer, UISoldierBondConfirmScree and UIMissionSummary) request the auto-generation of photos for the photobooth. Such photos are coded to be taken when the user doesn't take a photo manually at the end of a mission, when a soldier above Sergeant rank dies, when a soldier is promoted to Sergeant or Major rank and when two soldiers are bonded. The auto-photos are usually of poor quality and the ability to disable them is a useful feature for modders.","title":"DisableAutoPhotos"},{"location":"misc/DisableAutoPhotos/#source-code-references","text":"UIAfterAction.uc:116-121 XComGame.ini:301","title":"Source code references"},{"location":"misc/DisplayMultiSlotItems/","text":"DisplayMultiSlotItems Tracking Issue: #885 Tags: pawns This feature allows mods to make items equipped in multi-item inventory slots visible on soldiers' bodies. The vanilla behavior is that only the first item in the Utility Slot is visible on the soldier's body, and only in Tactical, but not in the Armory. With this feature it's possible to conditionally show all items in all multi-slots, including Highlander-templated slots. Highlander-templated slots, in addition to this feature, also need to have NeedsPresEquip = true to display in Tactical, and ShowOnCinematicPawns = true to display in the Armory and Squad Select. How to use Implement the following code in your X2DownloadableContentInfo class: static event OnPostTemplatesCreated() { local CHHelpers CHHelpersObj; CHHelpersObj = class'CHHelpers'.static.GetCDO(); CHHelpersObj.AddShouldDisplayMultiSlotItemInStrategyCallback(ShouldDisplayMultiSlotItemInStrategy); CHHelpersObj.AddShouldDisplayMultiSlotItemInTacticalCallback(ShouldDisplayMultiSlotItemInTactical); } // To avoid crashes associated with garbage collection failure when transitioning between Tactical and Strategy, // these functions must be bound to the ClassDefaultObject of your class. Having these functions in a class that // `extends X2DownloadableContentInfo` is the easiest way to ensure that. // Determines whether the specified item should be visible on specified unit in the Armory, Squad Select and Post Mission Sequence. static private function EHLDelegateReturn ShouldDisplayMultiSlotItemInStrategy(XComGameState_Unit UnitState, XComGameState_Item ItemState, out int bDisplayItem, XComUnitPawn UnitPawn, optional XComGameState CheckGameState) { // Optionally modify bDisplayItem here. If `bDisplayItem` is `1`, the item will be visible. // If `bDisplayItem` is `0` it will not be visible. // Return EHLDR_NoInterrupt or EHLDR_InterruptDelegates depending on // if you want to allow other delegates to run after yours // and potentially modify bHasHeightAdvantage further. return EHLDR_NoInterrupt; } // Determines whether the specified item should be visible on specified unit in Tactical. static private function bool ShouldDisplayMultiSlotItemInTactical(XComGameState_Unit UnitState, XComGameState_Item ItemState, out int bDisplayItem, XGUnit UnitVisualizer, optional XComGameState CheckGameState) { // Optionally modify bDisplayItem here. return EHLDR_NoInterrupt; } You can get the template name of the item in question from the provided ItemState by doing ItemState.GetMyTemplateName() , and access its Inventory Slot as ItemState.InventorySlot . Both delegates may or may not provide you with an XComGameState that can be used to access accompanying state objects, for example: if (CheckGameState != none) { MyState = CheckGameState.GetGameStateForObjectID(ObjectID); } if (MyState == none) { MyState = `XCOMHISTORY.GetGameStateForObjectID(ObjectID); } // Alternatively, for items in a unit's inventory: ItemState = UnitState.GetItemGameState(ItemRef, CheckGameState); ItemState = UnitState.GetItemInSlot(eInvSlot_PrimaryWeapon, CheckGameState); ItemStates = UnitState.GetAllItemsInSlot(eInvSlot_Utility, CheckGameState); This is mostly relevant for multiplayer, as the pre-game setup doesn't have a History. Delegate Priority When adding a delegate, you can optionally specify Priority. CHHelpersObj.AddShouldDisplayMultiSlotItemInStrategyCallback(ShouldDisplayMultiSlotItemInStrategy, 45); Delegates with higher Priority value are executed first. Delegates with the same Priority are executed in the order they were added to CHHelpers, which would normally is the same as DLCRunOrder . The \"Add...Callback functions return true if the delegate was successfully registered. Removing Delegates If necessary, it's possible to remove a delegate. CHHelpersObj.RemoveShouldDisplayMultiSlotItemInStrategyCallback(ShouldDisplayMultiSlotItemInStrategy); CHHelpersObj.RemoveShouldDisplayMultiSlotItemInTacticalCallback(ShouldDisplayMultiSlotItemInTactical); Remove...Callback functions will return true if the Callback was successfully deleted, return false otherwise. Source code references CHHelpers.uc:695-763 CHHelpers.uc:765-774 CHHelpers.uc:814-821","title":"DisplayMultiSlotItems"},{"location":"misc/DisplayMultiSlotItems/#displaymultislotitems","text":"Tracking Issue: #885 Tags: pawns This feature allows mods to make items equipped in multi-item inventory slots visible on soldiers' bodies. The vanilla behavior is that only the first item in the Utility Slot is visible on the soldier's body, and only in Tactical, but not in the Armory. With this feature it's possible to conditionally show all items in all multi-slots, including Highlander-templated slots. Highlander-templated slots, in addition to this feature, also need to have NeedsPresEquip = true to display in Tactical, and ShowOnCinematicPawns = true to display in the Armory and Squad Select.","title":"DisplayMultiSlotItems"},{"location":"misc/DisplayMultiSlotItems/#how-to-use","text":"Implement the following code in your X2DownloadableContentInfo class: static event OnPostTemplatesCreated() { local CHHelpers CHHelpersObj; CHHelpersObj = class'CHHelpers'.static.GetCDO(); CHHelpersObj.AddShouldDisplayMultiSlotItemInStrategyCallback(ShouldDisplayMultiSlotItemInStrategy); CHHelpersObj.AddShouldDisplayMultiSlotItemInTacticalCallback(ShouldDisplayMultiSlotItemInTactical); } // To avoid crashes associated with garbage collection failure when transitioning between Tactical and Strategy, // these functions must be bound to the ClassDefaultObject of your class. Having these functions in a class that // `extends X2DownloadableContentInfo` is the easiest way to ensure that. // Determines whether the specified item should be visible on specified unit in the Armory, Squad Select and Post Mission Sequence. static private function EHLDelegateReturn ShouldDisplayMultiSlotItemInStrategy(XComGameState_Unit UnitState, XComGameState_Item ItemState, out int bDisplayItem, XComUnitPawn UnitPawn, optional XComGameState CheckGameState) { // Optionally modify bDisplayItem here. If `bDisplayItem` is `1`, the item will be visible. // If `bDisplayItem` is `0` it will not be visible. // Return EHLDR_NoInterrupt or EHLDR_InterruptDelegates depending on // if you want to allow other delegates to run after yours // and potentially modify bHasHeightAdvantage further. return EHLDR_NoInterrupt; } // Determines whether the specified item should be visible on specified unit in Tactical. static private function bool ShouldDisplayMultiSlotItemInTactical(XComGameState_Unit UnitState, XComGameState_Item ItemState, out int bDisplayItem, XGUnit UnitVisualizer, optional XComGameState CheckGameState) { // Optionally modify bDisplayItem here. return EHLDR_NoInterrupt; } You can get the template name of the item in question from the provided ItemState by doing ItemState.GetMyTemplateName() , and access its Inventory Slot as ItemState.InventorySlot . Both delegates may or may not provide you with an XComGameState that can be used to access accompanying state objects, for example: if (CheckGameState != none) { MyState = CheckGameState.GetGameStateForObjectID(ObjectID); } if (MyState == none) { MyState = `XCOMHISTORY.GetGameStateForObjectID(ObjectID); } // Alternatively, for items in a unit's inventory: ItemState = UnitState.GetItemGameState(ItemRef, CheckGameState); ItemState = UnitState.GetItemInSlot(eInvSlot_PrimaryWeapon, CheckGameState); ItemStates = UnitState.GetAllItemsInSlot(eInvSlot_Utility, CheckGameState); This is mostly relevant for multiplayer, as the pre-game setup doesn't have a History.","title":"How to use"},{"location":"misc/DisplayMultiSlotItems/#delegate-priority","text":"When adding a delegate, you can optionally specify Priority. CHHelpersObj.AddShouldDisplayMultiSlotItemInStrategyCallback(ShouldDisplayMultiSlotItemInStrategy, 45); Delegates with higher Priority value are executed first. Delegates with the same Priority are executed in the order they were added to CHHelpers, which would normally is the same as DLCRunOrder . The \"Add...Callback functions return true if the delegate was successfully registered.","title":"Delegate Priority"},{"location":"misc/DisplayMultiSlotItems/#removing-delegates","text":"If necessary, it's possible to remove a delegate. CHHelpersObj.RemoveShouldDisplayMultiSlotItemInStrategyCallback(ShouldDisplayMultiSlotItemInStrategy); CHHelpersObj.RemoveShouldDisplayMultiSlotItemInTacticalCallback(ShouldDisplayMultiSlotItemInTactical); Remove...Callback functions will return true if the Callback was successfully deleted, return false otherwise.","title":"Removing Delegates"},{"location":"misc/DisplayMultiSlotItems/#source-code-references","text":"CHHelpers.uc:695-763 CHHelpers.uc:765-774 CHHelpers.uc:814-821","title":"Source code references"},{"location":"misc/EuroDateOverride/","text":"EuroDateOverride Tracking Issue: #1191 Add config option to force Euro date style with INT localisation Source code references X2StrategyGameRulesetDataStructures.uc:1658-1659 XComGame.ini:268","title":"EuroDateOverride"},{"location":"misc/EuroDateOverride/#eurodateoverride","text":"Tracking Issue: #1191 Add config option to force Euro date style with INT localisation","title":"EuroDateOverride"},{"location":"misc/EuroDateOverride/#source-code-references","text":"X2StrategyGameRulesetDataStructures.uc:1658-1659 XComGame.ini:268","title":"Source code references"},{"location":"misc/GetCrossClassAbilities_CH/","text":"GetCrossClassAbilities_CH Tracking Issue: #62 The CH variant of GetCrossClassAbilities compared to vanilla does two things differently: - Adds a check to ensure that the ability to be added to the CrossClassAbilities list isn't already in the soldiers default ability tree. - This variant supersedes issue #30 by checking against the actual abilities in the current soldiers tree, instead of comparing against all the potential abilities the soldier could have had available. This is especially important when classes uses the RandomAbilityDecks, since otherwise in the worst case scenario, you could end up with no available cross class abilities. The old function is kept in case mods call it, but is otherwise ignored throughout the XComGame codebase Source code references X2SoldierClassTemplateManager.uc:100-110","title":"GetCrossClassAbilities_CH"},{"location":"misc/GetCrossClassAbilities_CH/#getcrossclassabilities_ch","text":"Tracking Issue: #62 The CH variant of GetCrossClassAbilities compared to vanilla does two things differently: - Adds a check to ensure that the ability to be added to the CrossClassAbilities list isn't already in the soldiers default ability tree. - This variant supersedes issue #30 by checking against the actual abilities in the current soldiers tree, instead of comparing against all the potential abilities the soldier could have had available. This is especially important when classes uses the RandomAbilityDecks, since otherwise in the worst case scenario, you could end up with no available cross class abilities. The old function is kept in case mods call it, but is otherwise ignored throughout the XComGame codebase","title":"GetCrossClassAbilities_CH"},{"location":"misc/GetCrossClassAbilities_CH/#source-code-references","text":"X2SoldierClassTemplateManager.uc:100-110","title":"Source code references"},{"location":"misc/GetLocalizedItemCategory/","text":"GetLocalizedItemCategory Tracking Issue: #1112 Tags: events Triggers GetLocalizedItemCategory event that can be used by mods to localize their new item categories. GetLocalizedItemCategory event Param Value EventID GetLocalizedItemCategory EventData XComLWTuple EventSource X2ItemTemplate NewGameState none Tuple contents Index Name Type Direction 0 CategoryLocale string out Listener template static function EventListenerReturn OnGetLocalizedItemCategory(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local X2ItemTemplate ItemTemplate; local XComLWTuple Tuple; local string CategoryLocale; ItemTemplate = X2ItemTemplate(EventSource); Tuple = XComLWTuple(EventData); // Your code here Tuple.Data[0].s = CategoryLocale; return ELR_NoInterrupt; } Source code references X2ItemTemplate.uc:341-352","title":"GetLocalizedItemCategory"},{"location":"misc/GetLocalizedItemCategory/#getlocalizeditemcategory","text":"Tracking Issue: #1112 Tags: events Triggers GetLocalizedItemCategory event that can be used by mods to localize their new item categories.","title":"GetLocalizedItemCategory"},{"location":"misc/GetLocalizedItemCategory/#getlocalizeditemcategory-event","text":"Param Value EventID GetLocalizedItemCategory EventData XComLWTuple EventSource X2ItemTemplate NewGameState none","title":"GetLocalizedItemCategory event"},{"location":"misc/GetLocalizedItemCategory/#tuple-contents","text":"Index Name Type Direction 0 CategoryLocale string out","title":"Tuple contents"},{"location":"misc/GetLocalizedItemCategory/#listener-template","text":"static function EventListenerReturn OnGetLocalizedItemCategory(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local X2ItemTemplate ItemTemplate; local XComLWTuple Tuple; local string CategoryLocale; ItemTemplate = X2ItemTemplate(EventSource); Tuple = XComLWTuple(EventData); // Your code here Tuple.Data[0].s = CategoryLocale; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"misc/GetLocalizedItemCategory/#source-code-references","text":"X2ItemTemplate.uc:341-352","title":"Source code references"},{"location":"misc/ItemAddedOrRemovedToSlot/","text":"ItemAddedOrRemovedToSlot Tracking Issue: #694 Tags: events Triggers ItemAddedToSlot event when a unit adds an item to their inventory. Triggers ItemRemovedFromSlot event when a unit removes an item from their inventory. These events are perfect when relying on X2ItemTemplate::OnEquippedFn and X2ItemTemplate::OnUnequippedFn is not an option, such as when you need to execute arbitrary code whenever any unit adds any item to their inventory. ItemAddedToSlot event Param Value EventID ItemAddedToSlot EventData XComGameState_Item EventSource XComGameState_Unit NewGameState yes Listener template static function EventListenerReturn OnItemAddedToSlot(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { // Your code here return ELR_NoInterrupt; } ItemRemovedFromSlot event Param Value EventID ItemRemovedFromSlot EventData XComGameState_Item EventSource XComGameState_Unit NewGameState maybe Listener template static function EventListenerReturn OnItemRemovedFromSlot(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { // Your code here return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:8271-8282 XComGameState_Unit.uc:8660-8666","title":"ItemAddedOrRemovedToSlot"},{"location":"misc/ItemAddedOrRemovedToSlot/#itemaddedorremovedtoslot","text":"Tracking Issue: #694 Tags: events Triggers ItemAddedToSlot event when a unit adds an item to their inventory. Triggers ItemRemovedFromSlot event when a unit removes an item from their inventory. These events are perfect when relying on X2ItemTemplate::OnEquippedFn and X2ItemTemplate::OnUnequippedFn is not an option, such as when you need to execute arbitrary code whenever any unit adds any item to their inventory.","title":"ItemAddedOrRemovedToSlot"},{"location":"misc/ItemAddedOrRemovedToSlot/#itemaddedtoslot-event","text":"Param Value EventID ItemAddedToSlot EventData XComGameState_Item EventSource XComGameState_Unit NewGameState yes","title":"ItemAddedToSlot event"},{"location":"misc/ItemAddedOrRemovedToSlot/#listener-template","text":"static function EventListenerReturn OnItemAddedToSlot(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"misc/ItemAddedOrRemovedToSlot/#itemremovedfromslot-event","text":"Param Value EventID ItemRemovedFromSlot EventData XComGameState_Item EventSource XComGameState_Unit NewGameState maybe","title":"ItemRemovedFromSlot event"},{"location":"misc/ItemAddedOrRemovedToSlot/#listener-template_1","text":"static function EventListenerReturn OnItemRemovedFromSlot(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"misc/ItemAddedOrRemovedToSlot/#source-code-references","text":"XComGameState_Unit.uc:8271-8282 XComGameState_Unit.uc:8660-8666","title":"Source code references"},{"location":"misc/MixedCharacterPoolChance/","text":"MixedCharacterPoolChance Tracking Issue: #599 Allows to alter the chance of using a Character Pool character when Character Pool is in Mixed mode. Source code references CharacterPoolManager.uc:304-305 XComGame.ini:276","title":"MixedCharacterPoolChance"},{"location":"misc/MixedCharacterPoolChance/#mixedcharacterpoolchance","text":"Tracking Issue: #599 Allows to alter the chance of using a Character Pool character when Character Pool is in Mixed mode.","title":"MixedCharacterPoolChance"},{"location":"misc/MixedCharacterPoolChance/#source-code-references","text":"CharacterPoolManager.uc:304-305 XComGame.ini:276","title":"Source code references"},{"location":"misc/ModAddedHeads/","text":"ModAddedHeads Tracking Issue: #219 Tags: customization , pawns Allows Human Pawns to freely switch between default head and separate skeletal mesh heads without resorting to invisible head hacks and helmets. +BodyPartTemplateConfig=(PartType=\"Head\", TemplateName=\"Augmentations_Head_AFR\", ArchetypeName=\"MusashiAndroidHeads.ARC_Head_Afr_M\", Gender=eGender_Male, Race=eRace_African, bCanUseOnCivilian=false, SpecializedType=false, DLCName=\"Augmentations\") Base-game behavior There are two kinds of Human Pawns in the game: Pawns that share their head mesh with their pawn mesh, and pawns that don't. Note that the pawn mesh itself never has any geometry except for a possible head. In more concrete terms, the standard human pawn meshes have their head included, and the head archetypes reference the same mesh. The Human Pawn recognizes this and doesn't actually attach a head, and instead aliases the head component to the pawn component so that all changes to the head customization apply to the mesh. Sparks on the other hand have the option to switch between different head meshes, and the head mesh never references the pawn mesh. The pawn mesh is entirely void of geometry. The Human Pawn recognizes this and uses a separate mesh component for the head. Where it all goes wrong is when those two types of heads are being mixed. The Human Pawn first aliases the head to the pawn, and when a custom head is being used, it changes the head mesh -- and, due to the alias, also the base pawn mesh. Even worse, it tries to attach the pawn to the pawn itself instead of the head to the pawn. This generally crashes the game. The fix We handle the case where we go from a standard head to a custom head correctly and don't crash We apply an invisible material to the entire pawn mesh when a custom head is being used For Sparks, this causes no change in behavior because the Spark pawn has no geometry For Humans, this is desired because otherwise, the base head clips with any custom head An invisible material is used because outright hiding the pawn turns off parts of the animation system =) Additional nice-to-have Some mod-added heads don't work well with certain customization categories. For example, the Augmentations mod adds Cyborg heads, which generally don't have facial hair (but other facial props are okay!) This change allows custom head archetypes to suppress certain facial customization categories. Example from Augmentations: XComContent.ini : [XComGame.X2BodyPartTemplateManager] +BodyPartTemplateConfig=(PartType=\"Head\", TemplateName=\"Augmentations_Head_AFR\", ArchetypeName=\"MusashiAndroidHeads.ARC_Head_Afr_M\", Gender=eGender_Male, Race=eRace_African, bCanUseOnCivilian=false, SpecializedType=false, DLCName=\"Augmentations\") ; Object name ^^^^^^^^^^^^^^ [XComGame.CHHelpers] +HeadSuppressesHair=\"ARC_Head_Afr_M\" +HeadSuppressesBeard=\"ARC_Head_Afr_M\" The specified name is the object name of the archetype. Full list of arrays: HeadSuppressesHair HeadSuppressesLowerFaceProp HeadSuppressesUpperFaceProp HeadSuppressesHelmet HeadSuppressesBeard Source code references XComHumanPawn.uc:1265-1328 CHHelpers.uc:96","title":"ModAddedHeads"},{"location":"misc/ModAddedHeads/#modaddedheads","text":"Tracking Issue: #219 Tags: customization , pawns Allows Human Pawns to freely switch between default head and separate skeletal mesh heads without resorting to invisible head hacks and helmets. +BodyPartTemplateConfig=(PartType=\"Head\", TemplateName=\"Augmentations_Head_AFR\", ArchetypeName=\"MusashiAndroidHeads.ARC_Head_Afr_M\", Gender=eGender_Male, Race=eRace_African, bCanUseOnCivilian=false, SpecializedType=false, DLCName=\"Augmentations\")","title":"ModAddedHeads"},{"location":"misc/ModAddedHeads/#base-game-behavior","text":"There are two kinds of Human Pawns in the game: Pawns that share their head mesh with their pawn mesh, and pawns that don't. Note that the pawn mesh itself never has any geometry except for a possible head. In more concrete terms, the standard human pawn meshes have their head included, and the head archetypes reference the same mesh. The Human Pawn recognizes this and doesn't actually attach a head, and instead aliases the head component to the pawn component so that all changes to the head customization apply to the mesh. Sparks on the other hand have the option to switch between different head meshes, and the head mesh never references the pawn mesh. The pawn mesh is entirely void of geometry. The Human Pawn recognizes this and uses a separate mesh component for the head. Where it all goes wrong is when those two types of heads are being mixed. The Human Pawn first aliases the head to the pawn, and when a custom head is being used, it changes the head mesh -- and, due to the alias, also the base pawn mesh. Even worse, it tries to attach the pawn to the pawn itself instead of the head to the pawn. This generally crashes the game.","title":"Base-game behavior"},{"location":"misc/ModAddedHeads/#the-fix","text":"We handle the case where we go from a standard head to a custom head correctly and don't crash We apply an invisible material to the entire pawn mesh when a custom head is being used For Sparks, this causes no change in behavior because the Spark pawn has no geometry For Humans, this is desired because otherwise, the base head clips with any custom head An invisible material is used because outright hiding the pawn turns off parts of the animation system =)","title":"The fix"},{"location":"misc/ModAddedHeads/#additional-nice-to-have","text":"Some mod-added heads don't work well with certain customization categories. For example, the Augmentations mod adds Cyborg heads, which generally don't have facial hair (but other facial props are okay!) This change allows custom head archetypes to suppress certain facial customization categories. Example from Augmentations: XComContent.ini : [XComGame.X2BodyPartTemplateManager] +BodyPartTemplateConfig=(PartType=\"Head\", TemplateName=\"Augmentations_Head_AFR\", ArchetypeName=\"MusashiAndroidHeads.ARC_Head_Afr_M\", Gender=eGender_Male, Race=eRace_African, bCanUseOnCivilian=false, SpecializedType=false, DLCName=\"Augmentations\") ; Object name ^^^^^^^^^^^^^^ [XComGame.CHHelpers] +HeadSuppressesHair=\"ARC_Head_Afr_M\" +HeadSuppressesBeard=\"ARC_Head_Afr_M\" The specified name is the object name of the archetype. Full list of arrays: HeadSuppressesHair HeadSuppressesLowerFaceProp HeadSuppressesUpperFaceProp HeadSuppressesHelmet HeadSuppressesBeard","title":"Additional nice-to-have"},{"location":"misc/ModAddedHeads/#source-code-references","text":"XComHumanPawn.uc:1265-1328 CHHelpers.uc:96","title":"Source code references"},{"location":"misc/ModDependencyCheck/","text":"ModDependencyCheck Tracking Issue: #524 Tags: compatibility Allows mods to declare required and incompatible mods. The Highlander will show popups for missing requirements and detected incompatibilities. Terminology We'll need to distinguish a few identifiers in mod project setups to explain this feature, so here's a short rundown. DLCName is the actual ID of the mod. It's always the base name of the .XComMod file, so YetAnotherF1.XComMod has a DLCName of YetAnotherF1 . This is also the name that mod launchers specify in the ActiveMods list, and the way the game knows how to load that mod. Every mod has exactly one DLCName. Mods with the same DLCName can only be enabled or disabled together. The game stores the DLCName in the save file, and shows a warning upon attempting to load a save file when it had recorded a mod that's no longer enabled. DLCNames are case-insensitive. DLCIdentifier is an identifier corresponding to a X2DownloadableContentInfo class. Every mod has zero, one, or several X2DownloadableContentInfo classes, and the DLCIdentifier may be empty for any of them. This DLCIdentifier is used for some customization aspects (like part icons or slider names) and narrative content options (for the official DLCs). It's also used in CHL's Run Order since Run Order is all about X2DownloadableContentInfo classes. DLCIdentifiers are generally case-sensitive. In the default ModBuddy mod project, the mod has exactly one X2DownloadableContentInfo subclass with a DLCIdentifier identical to the DLCName. However, config-only mods have no X2DownloadableContentInfo at all, and some mods may have one but misconfigured the class so that the DLCIdentifier is empty. CHModDependency Now for the actual feature: Let's call the information about a mod provided to the dependency checker dependency info , or DepInfo . A mod declares dependency info through configuration entries for a class of type CHModDependency in XComGame.ini . Let's look at an example upfront (taken from Musashi's RPG Overhaul ): [XCOM2RPGOverhaul CHModDependency] DisplayName=\"Musashis RPG Overhaul\" +IncompatibleMods=\"NewPromotionScreenbyDefault\" +IncompatibleMods=\"DetailedSoldierListWOTC\" +IncompatibleMods=\"ABetterBarracksTLE\" +IncompatibleMods=\"ABetterBarracks\" +IncompatibleMods=\"ViewLockedSkillsWotc\" +IncompatibleMods=\"AddMintToMyChocolate\" +IncompatibleMods=\"RevisedWeaponUpgrades\" +RequiredMods=\"WOTC_LW2SecondaryWeapons\" +RequiredMods=\"PrimarySecondaries\" +RequiredMods=\"BetterSecondWaveSupport\" +IgnoreRequiredMods=\"NewPromotionScreenbyDefault\" +IgnoreRequiredMods=\"ViewLockedSkillsWotc\" +IgnoreRequiredMods=\"DetailedSoldierListWOTC\" CHModDependency is the class that contains our DepInfo. That class is perobjectconfig , so we can provide unique configuration for differently named instances of the class. In this case, since the DLCName of RPGO is XCOM2RPGOverhaul , we use that in the header. DisplayName is a human-readable name of the mod. This is used for the actual popup that says for example \"Musashis RPG Overhaul detected INCOMPATIBLE mods\". IncompatibleMods is a list of DLCNames that should not be enabled together with this mod. For every mod with an enabled incompatible mod, there will be a popup that lists all enabled incompatible mods. RequiredMods is a list of DLCNames that should be enabled together with this mod. For every mod with a missing required mod, there will be a popup that lists all missing requirements. IgnoreRequiredMods is a list of DLCNames that should be considered enabled if this mod is enabled. For example, RPGO integrates NewPromotionScreenbyDefault , so another mod should not consider NewPromotionScreenbyDefault missing if RPGO is enabled. There also is a IgnoreIncompatibleMods list of DLCNames that I am unfortunately not qualified to present a use case for. What +IgnoreIncompatibleMods=\"SomeDLCName\" does is silence any warning that a third mod would throw if it listed +IncompatibleMods=\"SomeDLCName\" . If you think this is useful in any way, please tell us about it in HL issue #967 . This is what the popup for missing requirements looks like: Since the missing requirements aren't enabled, we don't have any info about their DisplayName. How the dependency checker retrieves dependency info The dependency checker looks at the config objects from All currently enabled DLCNames All non-empty DLCIdentifiers from found X2DownloadableContentInfo classes while ignoring duplicates. Note that only DLCNames are supported for IncompatibleMods , RequiredMods etc., you cannot specify a requirement on or incompatibility with a given DLCIdentifier! This means that mods can easily provide dependency info for other mods -- the config object will be ignored if the corresponding DLCName isn't enabled. This also allows mods to add friendly names for other mods so that even if the mod isn't installed or doesn't set a DisplayName , the popup doesn't only show an internal ID. For example, AddMintToMyChocolate doesn't participate in the CHL depencency checker at all, but this DLCName is kind of confusing and a reported incompatibility would leave users unable to figure out what the actual conflict is. RPGO could add this to its XComGame.ini so that the name becomes clearer: [AddMintToMyChocolate CHModDependency] DisplayName=\"Classless XCOM: MINT\" and the popup would display that incompatibility as \"Classless XCOM: MINT (AddMintToMyChocolate)\". The same system can also be used to provide a DisplayName for requirements that may be missing and as such can't inform the dependency checker about their DisplayName. If the user presses \"Do not show me this again\", the Highlander will store the object name (DLCName or DLCIdentifier, depending on how the dependency checker found it in the first place) of the mod that provides this data in a user config file ( %USERPROFILE%/Documents/My Games/XCOM 2 War of the Chosen/XComGame/Config/X2WOTCCommunityHighlander_NullConfig.ini ) and won't show this popup again. Source code references CHModDependency.uc:1-122 X2WOTCCH_ModDependencies.uc:1","title":"ModDependencyCheck"},{"location":"misc/ModDependencyCheck/#moddependencycheck","text":"Tracking Issue: #524 Tags: compatibility Allows mods to declare required and incompatible mods. The Highlander will show popups for missing requirements and detected incompatibilities.","title":"ModDependencyCheck"},{"location":"misc/ModDependencyCheck/#terminology","text":"We'll need to distinguish a few identifiers in mod project setups to explain this feature, so here's a short rundown. DLCName is the actual ID of the mod. It's always the base name of the .XComMod file, so YetAnotherF1.XComMod has a DLCName of YetAnotherF1 . This is also the name that mod launchers specify in the ActiveMods list, and the way the game knows how to load that mod. Every mod has exactly one DLCName. Mods with the same DLCName can only be enabled or disabled together. The game stores the DLCName in the save file, and shows a warning upon attempting to load a save file when it had recorded a mod that's no longer enabled. DLCNames are case-insensitive. DLCIdentifier is an identifier corresponding to a X2DownloadableContentInfo class. Every mod has zero, one, or several X2DownloadableContentInfo classes, and the DLCIdentifier may be empty for any of them. This DLCIdentifier is used for some customization aspects (like part icons or slider names) and narrative content options (for the official DLCs). It's also used in CHL's Run Order since Run Order is all about X2DownloadableContentInfo classes. DLCIdentifiers are generally case-sensitive. In the default ModBuddy mod project, the mod has exactly one X2DownloadableContentInfo subclass with a DLCIdentifier identical to the DLCName. However, config-only mods have no X2DownloadableContentInfo at all, and some mods may have one but misconfigured the class so that the DLCIdentifier is empty.","title":"Terminology"},{"location":"misc/ModDependencyCheck/#chmoddependency","text":"Now for the actual feature: Let's call the information about a mod provided to the dependency checker dependency info , or DepInfo . A mod declares dependency info through configuration entries for a class of type CHModDependency in XComGame.ini . Let's look at an example upfront (taken from Musashi's RPG Overhaul ): [XCOM2RPGOverhaul CHModDependency] DisplayName=\"Musashis RPG Overhaul\" +IncompatibleMods=\"NewPromotionScreenbyDefault\" +IncompatibleMods=\"DetailedSoldierListWOTC\" +IncompatibleMods=\"ABetterBarracksTLE\" +IncompatibleMods=\"ABetterBarracks\" +IncompatibleMods=\"ViewLockedSkillsWotc\" +IncompatibleMods=\"AddMintToMyChocolate\" +IncompatibleMods=\"RevisedWeaponUpgrades\" +RequiredMods=\"WOTC_LW2SecondaryWeapons\" +RequiredMods=\"PrimarySecondaries\" +RequiredMods=\"BetterSecondWaveSupport\" +IgnoreRequiredMods=\"NewPromotionScreenbyDefault\" +IgnoreRequiredMods=\"ViewLockedSkillsWotc\" +IgnoreRequiredMods=\"DetailedSoldierListWOTC\" CHModDependency is the class that contains our DepInfo. That class is perobjectconfig , so we can provide unique configuration for differently named instances of the class. In this case, since the DLCName of RPGO is XCOM2RPGOverhaul , we use that in the header. DisplayName is a human-readable name of the mod. This is used for the actual popup that says for example \"Musashis RPG Overhaul detected INCOMPATIBLE mods\". IncompatibleMods is a list of DLCNames that should not be enabled together with this mod. For every mod with an enabled incompatible mod, there will be a popup that lists all enabled incompatible mods. RequiredMods is a list of DLCNames that should be enabled together with this mod. For every mod with a missing required mod, there will be a popup that lists all missing requirements. IgnoreRequiredMods is a list of DLCNames that should be considered enabled if this mod is enabled. For example, RPGO integrates NewPromotionScreenbyDefault , so another mod should not consider NewPromotionScreenbyDefault missing if RPGO is enabled. There also is a IgnoreIncompatibleMods list of DLCNames that I am unfortunately not qualified to present a use case for. What +IgnoreIncompatibleMods=\"SomeDLCName\" does is silence any warning that a third mod would throw if it listed +IncompatibleMods=\"SomeDLCName\" . If you think this is useful in any way, please tell us about it in HL issue #967 . This is what the popup for missing requirements looks like: Since the missing requirements aren't enabled, we don't have any info about their DisplayName.","title":"CHModDependency"},{"location":"misc/ModDependencyCheck/#how-the-dependency-checker-retrieves-dependency-info","text":"The dependency checker looks at the config objects from All currently enabled DLCNames All non-empty DLCIdentifiers from found X2DownloadableContentInfo classes while ignoring duplicates. Note that only DLCNames are supported for IncompatibleMods , RequiredMods etc., you cannot specify a requirement on or incompatibility with a given DLCIdentifier! This means that mods can easily provide dependency info for other mods -- the config object will be ignored if the corresponding DLCName isn't enabled. This also allows mods to add friendly names for other mods so that even if the mod isn't installed or doesn't set a DisplayName , the popup doesn't only show an internal ID. For example, AddMintToMyChocolate doesn't participate in the CHL depencency checker at all, but this DLCName is kind of confusing and a reported incompatibility would leave users unable to figure out what the actual conflict is. RPGO could add this to its XComGame.ini so that the name becomes clearer: [AddMintToMyChocolate CHModDependency] DisplayName=\"Classless XCOM: MINT\" and the popup would display that incompatibility as \"Classless XCOM: MINT (AddMintToMyChocolate)\". The same system can also be used to provide a DisplayName for requirements that may be missing and as such can't inform the dependency checker about their DisplayName. If the user presses \"Do not show me this again\", the Highlander will store the object name (DLCName or DLCIdentifier, depending on how the dependency checker found it in the first place) of the mod that provides this data in a user config file ( %USERPROFILE%/Documents/My Games/XCOM 2 War of the Chosen/XComGame/Config/X2WOTCCommunityHighlander_NullConfig.ini ) and won't show this popup again.","title":"How the dependency checker retrieves dependency info"},{"location":"misc/ModDependencyCheck/#source-code-references","text":"CHModDependency.uc:1-122 X2WOTCCH_ModDependencies.uc:1","title":"Source code references"},{"location":"misc/ModifyEarnedSoldierAbilities/","text":"ModifyEarnedSoldierAbilities Tracking Issue: #409 This allows mods to add to or otherwise modify earned abilities for units. For example, the Officer Pack can use this to attach learned officer abilities to the unit. Note: abilities added this way will not be picked up by XComGameState_Unit::HasSoldierAbility() Elements of the EarnedAbilities array are structs of type SoldierClassAbilityType . Each element has the following parameters: * AbilityName - template name of the ability that should be added to the unit. * ApplyToWeaponSlot - inventory slot of the item that this ability should be attached to. Being attached to the correct item is critical for abilities that rely on the source item, for example abilities that deal damage of the weapon they are attached to. * UtilityCat - used only if ApplyToWeaponSlot = eInvSlot_Utility . Optional. If specified, the ability will be initialized for the unit when they enter tactical combat only if they have a weapon with the specified weapon category in one of their utility slots. local SoldierClassAbilityType NewAbility; NewAbility.AbilityName = 'PrimaryWeapon_AbilityTemplateName'; NewAbility.ApplyToWeaponSlot = eInvSlot_Primary; EarnedAbilities.AddItem(NewAbility); NewAbility.AbilityName = 'UtilityItem_AbilityTemplateName'; NewAbility.ApplyToWeaponSlot = eInvSlot_Utility; NewAbility.UtilityCat = 'UtilityItemWeaponCategory'; EarnedAbilities.AddItem(NewAbility); Source code references X2DownloadableContentInfo.uc:724-753","title":"ModifyEarnedSoldierAbilities"},{"location":"misc/ModifyEarnedSoldierAbilities/#modifyearnedsoldierabilities","text":"Tracking Issue: #409 This allows mods to add to or otherwise modify earned abilities for units. For example, the Officer Pack can use this to attach learned officer abilities to the unit. Note: abilities added this way will not be picked up by XComGameState_Unit::HasSoldierAbility() Elements of the EarnedAbilities array are structs of type SoldierClassAbilityType . Each element has the following parameters: * AbilityName - template name of the ability that should be added to the unit. * ApplyToWeaponSlot - inventory slot of the item that this ability should be attached to. Being attached to the correct item is critical for abilities that rely on the source item, for example abilities that deal damage of the weapon they are attached to. * UtilityCat - used only if ApplyToWeaponSlot = eInvSlot_Utility . Optional. If specified, the ability will be initialized for the unit when they enter tactical combat only if they have a weapon with the specified weapon category in one of their utility slots. local SoldierClassAbilityType NewAbility; NewAbility.AbilityName = 'PrimaryWeapon_AbilityTemplateName'; NewAbility.ApplyToWeaponSlot = eInvSlot_Primary; EarnedAbilities.AddItem(NewAbility); NewAbility.AbilityName = 'UtilityItem_AbilityTemplateName'; NewAbility.ApplyToWeaponSlot = eInvSlot_Utility; NewAbility.UtilityCat = 'UtilityItemWeaponCategory'; EarnedAbilities.AddItem(NewAbility);","title":"ModifyEarnedSoldierAbilities"},{"location":"misc/ModifyEarnedSoldierAbilities/#source-code-references","text":"X2DownloadableContentInfo.uc:724-753","title":"Source code references"},{"location":"misc/ModifyGeneratedUnitAppearance/","text":"ModifyGeneratedUnitAppearance Tracking Issue: #783 Tags: customization , compatibility Usage This DLC hook allows mods to make arbitrary changes to unit appearance after it has been generated by XGCharacterGenerator::CreateTSoldier() . The generated appearance is stored in CharGen.kSoldier.kAppearance , which you can modify directly. Other arguments are provided to for reference, as they were given to the CreateTSoldier() function. The UnitState and the GameState will be passed to this hook only if the CreateTSoldier() function was called from CreateTSoldierFromUnit() , which normally happens only in the Shell code (TQL / Challenge Mode / Character Pool), and will be none otherwise. If you wish to \"redo\" some parts of the process of generating unit's appearance, you can call various methods in the Character Generator, but you must avoid calling the CreateTSoldier() and CreateTSoldierFromUnit() methods, as that will retrigger the hook, potentially causing an inception loop and crashing the game. Issue #1140 Addendum This hook is triggered twice for faction heroes. Reapers and Templars run this hook the first time after initial character generation, and the second time after their faction-specific country and class-specific nickname have been generated. Skirmishers additionally get their faction-specific name after the first time the hook is triggered. Compatibility Custom XGCharacterGenerator classes used by mods to generate appearance of custom units can potentially interfere with the normal operation of this hook for themselves. If the Character Generator implements a custom CreateTSoldier() function that does not call super.CreateTSoldier() , then this DLC hook will not be called for that class. If super.CreateTSoldier() is called, but the custom CreateTSoldier() function makes changes to the generated appearance afterwards, it can potentially override changes made by this hook. For best compatibility with this hook, mod-added XGCharacterGenerator classes should avoid making any appearance changes after calling super.CreateTSoldier() . Ideally, that function should not be overridden at all, and the Character Generator should rely on overriding other methods called by CreateTSoldier() as much as possible. Source code references X2DownloadableContentInfo.uc:800-839 XGCharacterGenerator.uc:419","title":"ModifyGeneratedUnitAppearance"},{"location":"misc/ModifyGeneratedUnitAppearance/#modifygeneratedunitappearance","text":"Tracking Issue: #783 Tags: customization , compatibility","title":"ModifyGeneratedUnitAppearance"},{"location":"misc/ModifyGeneratedUnitAppearance/#usage","text":"This DLC hook allows mods to make arbitrary changes to unit appearance after it has been generated by XGCharacterGenerator::CreateTSoldier() . The generated appearance is stored in CharGen.kSoldier.kAppearance , which you can modify directly. Other arguments are provided to for reference, as they were given to the CreateTSoldier() function. The UnitState and the GameState will be passed to this hook only if the CreateTSoldier() function was called from CreateTSoldierFromUnit() , which normally happens only in the Shell code (TQL / Challenge Mode / Character Pool), and will be none otherwise. If you wish to \"redo\" some parts of the process of generating unit's appearance, you can call various methods in the Character Generator, but you must avoid calling the CreateTSoldier() and CreateTSoldierFromUnit() methods, as that will retrigger the hook, potentially causing an inception loop and crashing the game.","title":"Usage"},{"location":"misc/ModifyGeneratedUnitAppearance/#issue-1140-addendum","text":"This hook is triggered twice for faction heroes. Reapers and Templars run this hook the first time after initial character generation, and the second time after their faction-specific country and class-specific nickname have been generated. Skirmishers additionally get their faction-specific name after the first time the hook is triggered.","title":"Issue #1140 Addendum"},{"location":"misc/ModifyGeneratedUnitAppearance/#compatibility","text":"Custom XGCharacterGenerator classes used by mods to generate appearance of custom units can potentially interfere with the normal operation of this hook for themselves. If the Character Generator implements a custom CreateTSoldier() function that does not call super.CreateTSoldier() , then this DLC hook will not be called for that class. If super.CreateTSoldier() is called, but the custom CreateTSoldier() function makes changes to the generated appearance afterwards, it can potentially override changes made by this hook. For best compatibility with this hook, mod-added XGCharacterGenerator classes should avoid making any appearance changes after calling super.CreateTSoldier() . Ideally, that function should not be overridden at all, and the Character Generator should rely on overriding other methods called by CreateTSoldier() as much as possible.","title":"Compatibility"},{"location":"misc/ModifyGeneratedUnitAppearance/#source-code-references","text":"X2DownloadableContentInfo.uc:800-839 XGCharacterGenerator.uc:419","title":"Source code references"},{"location":"misc/OnLoadedSavedGameWithDLCExisting/","text":"OnLoadedSavedGameWithDLCExisting Tracking Issue: #808 When loading a save the game makes a distinction between \"existing\" and \"new\" mods/DLCs. The list of the \"existing\" mods is stored inside the save and is used as \"source of truth\" during the loading process. First, the game checks if any of the \"existing\" mods are currently not active. If such exist, the player gets the \"missing mods\" popup. Then, the game checks whether any of the currently active mods are not listed as \"existing\". Such mods are considered \"new\" and the OnLoadedSavedGame hook is called on their DLCInfos. Finally, the \"new\" mods are marked as \"existing\" to prevent the previous step from occurring again the next time the same campaign is loaded and to facilitate the popup, should any of them be removed. The above process misses an important aspect - what happens if the mod is \"existing\" but wants to make state changes before the save is loaded? An example use case would be adjusting existing campaigns due to updates in the mod code. OnLoadedSavedGameWithDLCExisting fills that gap - it is called on the \"existing\" mods every time a save is loaded. Important note 1: OnLoadedSavedGameWithDLCExisting is exclusive with OnLoadedSavedGame . If the mod was just added (it is \"new\") then only OnLoadedSavedGame will be called. On subsequent loads of saves from that campaign (the mod is now \"existing\") only OnLoadedSavedGameWithDLCExisting will be called. Important note 2: this (and the base game OnLoadedSavedGame) is called before the ruleset of the save is initialized. This is great as any state changes done here will be picked up automatically (no need to refresh anything anywhere), however it imposes several limitations: You cannot use SubmitGameStateContext / SubmitGameState . Use XComGameStateHistory::AddGameStateToHistory instead Event listener templates should be assumed as not registered In fact, due to (1), only ELD_Immediate listeners (that are registered on state objects) will be triggered. Therefore, you are advised to not trigger any events at all. If the above is too limiting for your use case, consider using OnLoadedSavedGameToStrategy / OnLoadedSavedGameToTactical , which are called after the relevant listener templates are registered and most of the presentation has loaded. Important note 3: in case the save is loaded mid-tactical, some strategy state objects will be missing from the history. This is intended behaviour and you must account for it when using this hook. You can read more about it here: https://robojumper.github.io/too-real/history/#archived Important note 4: the list of \"existing\" mods is not cleared when the mod is removed (in order to facilitate the popup). This means that add -> save -> remove -> load -> save -> add -> load will trigger OnLoadedSavedGameWithDLCExisting as the mod will be considered \"existing\". However, any state objects which are instances of class(es) added by the mod will be gone as they will fail to deserialize when the save is loaded without the mod active. The only exception to this is the \"Remove Missing Mods\" mod which removes the missing mods from the list of the \"existing\" ones. In that case, the mod will be considered \"new\" (again). While any mod can potentially manipulate that list, the \"Remove Missing Mods\" mod is currently the only known way of removing entries from said list Important note 5: the decision to consider a mod either \"new\" or \"existing\" is made using its DLCName . See ModDependencyCheck for an explanation. Source code references X2DownloadableContentInfo.uc:846-895 XComOnlineEventMgr.uc:2801","title":"OnLoadedSavedGameWithDLCExisting"},{"location":"misc/OnLoadedSavedGameWithDLCExisting/#onloadedsavedgamewithdlcexisting","text":"Tracking Issue: #808 When loading a save the game makes a distinction between \"existing\" and \"new\" mods/DLCs. The list of the \"existing\" mods is stored inside the save and is used as \"source of truth\" during the loading process. First, the game checks if any of the \"existing\" mods are currently not active. If such exist, the player gets the \"missing mods\" popup. Then, the game checks whether any of the currently active mods are not listed as \"existing\". Such mods are considered \"new\" and the OnLoadedSavedGame hook is called on their DLCInfos. Finally, the \"new\" mods are marked as \"existing\" to prevent the previous step from occurring again the next time the same campaign is loaded and to facilitate the popup, should any of them be removed. The above process misses an important aspect - what happens if the mod is \"existing\" but wants to make state changes before the save is loaded? An example use case would be adjusting existing campaigns due to updates in the mod code. OnLoadedSavedGameWithDLCExisting fills that gap - it is called on the \"existing\" mods every time a save is loaded. Important note 1: OnLoadedSavedGameWithDLCExisting is exclusive with OnLoadedSavedGame . If the mod was just added (it is \"new\") then only OnLoadedSavedGame will be called. On subsequent loads of saves from that campaign (the mod is now \"existing\") only OnLoadedSavedGameWithDLCExisting will be called. Important note 2: this (and the base game OnLoadedSavedGame) is called before the ruleset of the save is initialized. This is great as any state changes done here will be picked up automatically (no need to refresh anything anywhere), however it imposes several limitations: You cannot use SubmitGameStateContext / SubmitGameState . Use XComGameStateHistory::AddGameStateToHistory instead Event listener templates should be assumed as not registered In fact, due to (1), only ELD_Immediate listeners (that are registered on state objects) will be triggered. Therefore, you are advised to not trigger any events at all. If the above is too limiting for your use case, consider using OnLoadedSavedGameToStrategy / OnLoadedSavedGameToTactical , which are called after the relevant listener templates are registered and most of the presentation has loaded. Important note 3: in case the save is loaded mid-tactical, some strategy state objects will be missing from the history. This is intended behaviour and you must account for it when using this hook. You can read more about it here: https://robojumper.github.io/too-real/history/#archived Important note 4: the list of \"existing\" mods is not cleared when the mod is removed (in order to facilitate the popup). This means that add -> save -> remove -> load -> save -> add -> load will trigger OnLoadedSavedGameWithDLCExisting as the mod will be considered \"existing\". However, any state objects which are instances of class(es) added by the mod will be gone as they will fail to deserialize when the save is loaded without the mod active. The only exception to this is the \"Remove Missing Mods\" mod which removes the missing mods from the list of the \"existing\" ones. In that case, the mod will be considered \"new\" (again). While any mod can potentially manipulate that list, the \"Remove Missing Mods\" mod is currently the only known way of removing entries from said list Important note 5: the decision to consider a mod either \"new\" or \"existing\" is made using its DLCName . See ModDependencyCheck for an explanation.","title":"OnLoadedSavedGameWithDLCExisting"},{"location":"misc/OnLoadedSavedGameWithDLCExisting/#source-code-references","text":"X2DownloadableContentInfo.uc:846-895 XComOnlineEventMgr.uc:2801","title":"Source code references"},{"location":"misc/OverrideItemImage_Improved/","text":"OverrideItemImage_Improved Tracking Issue: #962 The OverrideItemImage_Improved X2DLCInfo method is called from XComGameState_Item::GetWeaponPanelImages() . It allows mods to conditionally override item's inventory image. It can be used to replace the original image entirely or to overlay an additional icon on top of it to mark the specific item. To do so replace the contents of the imagePath array or add more image paths to it. Source code references X2DownloadableContentInfo.uc:402-407 XComGameState_Item.uc:1349","title":"OverrideItemImage_Improved"},{"location":"misc/OverrideItemImage_Improved/#overrideitemimage_improved","text":"Tracking Issue: #962 The OverrideItemImage_Improved X2DLCInfo method is called from XComGameState_Item::GetWeaponPanelImages() . It allows mods to conditionally override item's inventory image. It can be used to replace the original image entirely or to overlay an additional icon on top of it to mark the specific item. To do so replace the contents of the imagePath array or add more image paths to it.","title":"OverrideItemImage_Improved"},{"location":"misc/OverrideItemImage_Improved/#source-code-references","text":"X2DownloadableContentInfo.uc:402-407 XComGameState_Item.uc:1349","title":"Source code references"},{"location":"misc/OverrideStackedClassIcon/","text":"OverrideStackedClassIcon Tracking Issue: #1134 Tags: ui , events Function to return the current unit's stacked class icon. Stacked class icons are generated for faction hero units by default. Mods may want to manipulate the way a soldier's stacked class icon is displayed in more dynamic ways, or even add a stacked icon to a non-hero class. For example, when using custom hero classes such as the Skirmisher Heavy, it would be nice to see a custom class image in the soldier list, promotion screen, and in the tactical UI. There is one event: OverrideStackedClassIcon event Param Value EventID OverrideStackedClassIcon EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 Images array<string> inout 1 bInvertImage bool inout Listener template static function EventListenerReturn OnOverrideStackedClassIcon(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local array<string> Images; local bool bInvertImage; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); Images = Tuple.Data[0].as; bInvertImage = Tuple.Data[1].b; // Your code here Tuple.Data[0].as = Images; Tuple.Data[1].b = bInvertImage; return ELR_NoInterrupt; } Due to the irregularities of how StackedUIIconData is consumed, strings applied to the Images array should not start with img:/// . Source code references XComGameState_Unit.uc:15791-15812","title":"OverrideStackedClassIcon"},{"location":"misc/OverrideStackedClassIcon/#overridestackedclassicon","text":"Tracking Issue: #1134 Tags: ui , events Function to return the current unit's stacked class icon. Stacked class icons are generated for faction hero units by default. Mods may want to manipulate the way a soldier's stacked class icon is displayed in more dynamic ways, or even add a stacked icon to a non-hero class. For example, when using custom hero classes such as the Skirmisher Heavy, it would be nice to see a custom class image in the soldier list, promotion screen, and in the tactical UI. There is one event:","title":"OverrideStackedClassIcon"},{"location":"misc/OverrideStackedClassIcon/#overridestackedclassicon-event","text":"Param Value EventID OverrideStackedClassIcon EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"OverrideStackedClassIcon event"},{"location":"misc/OverrideStackedClassIcon/#tuple-contents","text":"Index Name Type Direction 0 Images array<string> inout 1 bInvertImage bool inout","title":"Tuple contents"},{"location":"misc/OverrideStackedClassIcon/#listener-template","text":"static function EventListenerReturn OnOverrideStackedClassIcon(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local array<string> Images; local bool bInvertImage; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); Images = Tuple.Data[0].as; bInvertImage = Tuple.Data[1].b; // Your code here Tuple.Data[0].as = Images; Tuple.Data[1].b = bInvertImage; return ELR_NoInterrupt; } Due to the irregularities of how StackedUIIconData is consumed, strings applied to the Images array should not start with img:/// .","title":"Listener template"},{"location":"misc/OverrideStackedClassIcon/#source-code-references","text":"XComGameState_Unit.uc:15791-15812","title":"Source code references"},{"location":"misc/OverrideWeaponScale/","text":"OverrideWeaponScale Tracking Issue: #921 Tags: pawns , events The OverrideWeaponScale event allows mods to rescale weapons for unit pawns. This event is triggered from two places: 1) XComUnitPawn::EquipWeapon() is used by items in weapon slots, as well as for utility items that use the Display Multi Slot Items functionality. 2) XComUnitPawn::AttachItem() is used for utility items by default. In this case, the ItemState component of the Tuple will be none . OverrideWeaponScale event Param Value EventID OverrideWeaponScale EventData XComLWTuple EventSource XComUnitPawn NewGameState none Tuple contents Index Name Type Direction 0 bOverride bool out 1 fOverrideWeaponScale float inout 2 ItemState XComGameState_Item in Listener template static function EventListenerReturn OnOverrideWeaponScale(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComUnitPawn UnitPawn; local XComLWTuple Tuple; local bool bOverride; local float fOverrideWeaponScale; local XComGameState_Item ItemState; UnitPawn = XComUnitPawn(EventSource); Tuple = XComLWTuple(EventData); fOverrideWeaponScale = Tuple.Data[1].f; ItemState = XComGameState_Item(Tuple.Data[2].o); // Your code here Tuple.Data[0].b = bOverride; Tuple.Data[1].f = fOverrideWeaponScale; return ELR_NoInterrupt; } Source code references XComUnitPawn.uc:2235-2249","title":"OverrideWeaponScale"},{"location":"misc/OverrideWeaponScale/#overrideweaponscale","text":"Tracking Issue: #921 Tags: pawns , events The OverrideWeaponScale event allows mods to rescale weapons for unit pawns. This event is triggered from two places: 1) XComUnitPawn::EquipWeapon() is used by items in weapon slots, as well as for utility items that use the Display Multi Slot Items functionality. 2) XComUnitPawn::AttachItem() is used for utility items by default. In this case, the ItemState component of the Tuple will be none .","title":"OverrideWeaponScale"},{"location":"misc/OverrideWeaponScale/#overrideweaponscale-event","text":"Param Value EventID OverrideWeaponScale EventData XComLWTuple EventSource XComUnitPawn NewGameState none","title":"OverrideWeaponScale event"},{"location":"misc/OverrideWeaponScale/#tuple-contents","text":"Index Name Type Direction 0 bOverride bool out 1 fOverrideWeaponScale float inout 2 ItemState XComGameState_Item in","title":"Tuple contents"},{"location":"misc/OverrideWeaponScale/#listener-template","text":"static function EventListenerReturn OnOverrideWeaponScale(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComUnitPawn UnitPawn; local XComLWTuple Tuple; local bool bOverride; local float fOverrideWeaponScale; local XComGameState_Item ItemState; UnitPawn = XComUnitPawn(EventSource); Tuple = XComLWTuple(EventData); fOverrideWeaponScale = Tuple.Data[1].f; ItemState = XComGameState_Item(Tuple.Data[2].o); // Your code here Tuple.Data[0].b = bOverride; Tuple.Data[1].f = fOverrideWeaponScale; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"misc/OverrideWeaponScale/#source-code-references","text":"XComUnitPawn.uc:2235-2249","title":"Source code references"},{"location":"misc/RequiredHighlanderVersion/","text":"RequiredHighlanderVersion Tracking Issue: #909 Tags: compatibility Mods can specify the required Highlander version in the mod's XComGame.ini , e.g.: [DLCName CHModDependency] RequiredHighlanderVersion = (MajorVersion = 1, MinorVersion = 22, PatchVersion = 0) If the mod user has an older version of the Highlander installed, they will see a popup warning when they start the game. Note: this feature is disabled if the game is started without the -review launch argument. Source code references CHModDependency.uc:133-142","title":"RequiredHighlanderVersion"},{"location":"misc/RequiredHighlanderVersion/#requiredhighlanderversion","text":"Tracking Issue: #909 Tags: compatibility Mods can specify the required Highlander version in the mod's XComGame.ini , e.g.: [DLCName CHModDependency] RequiredHighlanderVersion = (MajorVersion = 1, MinorVersion = 22, PatchVersion = 0) If the mod user has an older version of the Highlander installed, they will see a popup warning when they start the game. Note: this feature is disabled if the game is started without the -review launch argument.","title":"RequiredHighlanderVersion"},{"location":"misc/RequiredHighlanderVersion/#source-code-references","text":"CHModDependency.uc:133-142","title":"Source code references"},{"location":"misc/ScreenStackSubClasses/","text":"ScreenStackSubClasses Tracking Issue: #290 Tags: compatibility A number of functions in UIScreenStack operate on classes, but fail to consider subclasses. This causes subtle bugs in base game and mod code that fails to consider the possibility that a given class can be subclassed/overridden. For example, UIArmory does something like this: // Don't allow jumping to the geoscape from the armory when coming from squad select if (!`ScreenStack.IsInStack(class'UISquadSelect')) { NavHelp.AddGeoscapeButton(); } However, if UISquadSelect is being overridden or replaced, this can cause the campaign to permanently deadlock because UIArmory fails to find the changed squad select screen. The proper fix would be using HasInstanceOf , but this error is extremely common in base game and mod code. As a result, it was decided that the best fix is to change all functions in UIScreenStack to always consider subclasses. A full list of affected functions: GetScreen IsCurrentClass IsInStack IsNotInStack Compatibility If you legitimately want to not consider subclasses, you can use the functions function UIScreen GetScreen_CH(class<UIScreen> ScreenClass, bool IncludeSubTypes); function bool IsCurrentClass_CH(class<UIScreen> ScreenClass, bool IncludeSubTypes); and rewrite IsInStack / IsNotInStack in terms of GetScreen_CH(...) !=/== none . Source code references UIScreenStack.uc:640-675","title":"ScreenStackSubClasses"},{"location":"misc/ScreenStackSubClasses/#screenstacksubclasses","text":"Tracking Issue: #290 Tags: compatibility A number of functions in UIScreenStack operate on classes, but fail to consider subclasses. This causes subtle bugs in base game and mod code that fails to consider the possibility that a given class can be subclassed/overridden. For example, UIArmory does something like this: // Don't allow jumping to the geoscape from the armory when coming from squad select if (!`ScreenStack.IsInStack(class'UISquadSelect')) { NavHelp.AddGeoscapeButton(); } However, if UISquadSelect is being overridden or replaced, this can cause the campaign to permanently deadlock because UIArmory fails to find the changed squad select screen. The proper fix would be using HasInstanceOf , but this error is extremely common in base game and mod code. As a result, it was decided that the best fix is to change all functions in UIScreenStack to always consider subclasses. A full list of affected functions: GetScreen IsCurrentClass IsInStack IsNotInStack","title":"ScreenStackSubClasses"},{"location":"misc/ScreenStackSubClasses/#compatibility","text":"If you legitimately want to not consider subclasses, you can use the functions function UIScreen GetScreen_CH(class<UIScreen> ScreenClass, bool IncludeSubTypes); function bool IsCurrentClass_CH(class<UIScreen> ScreenClass, bool IncludeSubTypes); and rewrite IsInStack / IsNotInStack in terms of GetScreen_CH(...) !=/== none .","title":"Compatibility"},{"location":"misc/ScreenStackSubClasses/#source-code-references","text":"UIScreenStack.uc:640-675","title":"Source code references"},{"location":"misc/SoundCueNarrativeMoments/","text":"SoundCueNarrativeMoments Tracking Issue: #66 Allows mods to add their own voiceover using narrative moments (top-right corner comms box). Narrative moments in the base game are realized using the WWise middleware. The middleware runs in a background thread, so if audio (spuriously) fails to play, the middleware may take a few frames to figure this out. If audio does fail to play, there must be a callback in order to not deadlock the entire narrative moment system due to the audio never successfully finishing. However, mods have to use SoundCue sounds instead, and the system considers every SoundCue as failed to play. This ends every mod-added narrative moment prematurely after about three seconds. This fix simply triggers the callback only when WWise is involved and silently eats the callback if a SoundCue is involved. Mini-tutorial on mod VO This isn't strictly Highlander-related, but this is the best place to put it. Create a Speaker template (see X2Character_DefaultCharacters.uc ) Templates.AddItem(CreateSpeakerTemplate('Firebrand', \"Firebrand\", \"img:///UILibrary_Common.Head_Firebrand\", eGender_Female)); Compile the mod Import the SoundNodeWave Create a SoundCue , and create an XComConversationNode between the speaker and the SoundNodeWave Set the SpokenText and choose the SpeakerTemplate in the SoundNodeWave Create an XComNarrativeMoment archetype and reference the SoundCue in its Conversations Source code references AudioComponent.uc:252-277","title":"SoundCueNarrativeMoments"},{"location":"misc/SoundCueNarrativeMoments/#soundcuenarrativemoments","text":"Tracking Issue: #66 Allows mods to add their own voiceover using narrative moments (top-right corner comms box). Narrative moments in the base game are realized using the WWise middleware. The middleware runs in a background thread, so if audio (spuriously) fails to play, the middleware may take a few frames to figure this out. If audio does fail to play, there must be a callback in order to not deadlock the entire narrative moment system due to the audio never successfully finishing. However, mods have to use SoundCue sounds instead, and the system considers every SoundCue as failed to play. This ends every mod-added narrative moment prematurely after about three seconds. This fix simply triggers the callback only when WWise is involved and silently eats the callback if a SoundCue is involved.","title":"SoundCueNarrativeMoments"},{"location":"misc/SoundCueNarrativeMoments/#mini-tutorial-on-mod-vo","text":"This isn't strictly Highlander-related, but this is the best place to put it. Create a Speaker template (see X2Character_DefaultCharacters.uc ) Templates.AddItem(CreateSpeakerTemplate('Firebrand', \"Firebrand\", \"img:///UILibrary_Common.Head_Firebrand\", eGender_Female)); Compile the mod Import the SoundNodeWave Create a SoundCue , and create an XComConversationNode between the speaker and the SoundNodeWave Set the SpokenText and choose the SpeakerTemplate in the SoundNodeWave Create an XComNarrativeMoment archetype and reference the SoundCue in its Conversations","title":"Mini-tutorial on mod VO"},{"location":"misc/SoundCueNarrativeMoments/#source-code-references","text":"AudioComponent.uc:252-277","title":"Source code references"},{"location":"misc/SubscribeToOnInput/","text":"SubscribeToOnInput Tracking Issue: #198 Tags: ui Mods may want to intercept mouse/keyboard/controller input and instead run their own code. For most purposes, this feature should be considered superseded by SubscribeToOnInputForScreen , which is more ergonomic to use and harder to misuse. Read that documentation page for a general overview. This feature does not allow receiving the notification only for a specific screen, which is usually what you want. Additionally, it is required to manually unsubscribe at some point, lest you invoke the wrath of the garbage collector and crash everyone's games. delegate bool CHOnInputDelegate(int iInput, int ActionMask); function SubscribeToOnInput(delegate<CHOnInputDelegate> callback); function UnsubscribeFromOnInput(delegate<CHOnInputDelegate> callback); Again, it is recommended to instead use SubscribeToOnInputForScreen . The documentation for that feature has examples. Source code references UIScreenStack.uc:810-826","title":"SubscribeToOnInput"},{"location":"misc/SubscribeToOnInput/#subscribetooninput","text":"Tracking Issue: #198 Tags: ui Mods may want to intercept mouse/keyboard/controller input and instead run their own code. For most purposes, this feature should be considered superseded by SubscribeToOnInputForScreen , which is more ergonomic to use and harder to misuse. Read that documentation page for a general overview. This feature does not allow receiving the notification only for a specific screen, which is usually what you want. Additionally, it is required to manually unsubscribe at some point, lest you invoke the wrath of the garbage collector and crash everyone's games. delegate bool CHOnInputDelegate(int iInput, int ActionMask); function SubscribeToOnInput(delegate<CHOnInputDelegate> callback); function UnsubscribeFromOnInput(delegate<CHOnInputDelegate> callback); Again, it is recommended to instead use SubscribeToOnInputForScreen . The documentation for that feature has examples.","title":"SubscribeToOnInput"},{"location":"misc/SubscribeToOnInput/#source-code-references","text":"UIScreenStack.uc:810-826","title":"Source code references"},{"location":"misc/SubscribeToOnInputForScreen/","text":"SubscribeToOnInputForScreen Tracking Issue: #501 Tags: ui Mods may want to intercept mouse/keyboard/controller input on certain screens and instead run their own code. For example, the Highlander adds a text to the main menu that has small pop-up accessible by pressing the right controller stick. The API consists of a delegate definition and two functions: delegate bool CHOnInputDelegateImproved(UIScreen Screen, int iInput, int ActionMask); function SubscribeToOnInputForScreen(UIScreen Screen, delegate<CHOnInputDelegateImproved> Callback); function UnsubscribeFromOnInputForScreen(UIScreen Screen, delegate<CHOnInputDelegateImproved> Callback); In a nutshell, with SubscribeToOnInputForScreen you ask the UIScreenStack \"when screen Screen would receive input, ask me first\". The CHOnInputDelegateImproved delegate defines the signature of the callback function called when the targeted screen would receive input. Your function will be called with three arguments: The screen that would have received the input ( Screen ), the button that was pressed ( iInput ), and the action that occured ( ActionMask , button press/release). The button and action are numeric values that correspond to constants in UIUtilities_Input.uc . If your function returns true, the ScreenStack will consider the input handled and immediately stop processing the input event. If your function returns false, the ScreenStack will continue calling other subscribers and, if unhandled, will finally notify the screen itself. You can manually unsubscribe from receiving input, but this is generally not necessary as your callback will only be called when the screen would have received input and will automatically be unsubscribed upon removal of the targeted screen. The following simplified example is taken from Covert Infiltration : class UIListener_Mission extends UIScreenListener; event OnInit (UIScreen Screen) { local UIMission MissionScreen; MissionScreen = UIMission(Screen); if (MissionScreen == none) return; // This is a UIMission screen, register MissionScreen.Movie.Stack.SubscribeToOnInputForScreen(MissionScreen, OnMissionScreenInput); } simulated protected function bool OnMissionScreenInput (UIScreen Screen, int iInput, int ActionMask) { if (!Screen.CheckInputIsReleaseOrDirectionRepeat(iInput, ActionMask)) { return false; } switch (iInput) { case class'UIUtilities_Input'.const.FXS_BUTTON_RTRIGGER: // The right controller trigger was just released, show custom screen // ... // Tell the ScreenStack that this input was handled return true; break; } return false; } CheckInputIsReleaseOrDirectionRepeat ensures that the button was just released (or, if directional button, held for a long time), making input behavior more consistent with base game screens. Although all mouse events can be inspected, Flash usually provides its own handlers that run even if the callback indicates to the ScreenStack that the input was handled. As a result, the only mouse event that can reliably be stopped with SubscribeToOnInputForScreen is the already navigation-relevant right click. This feature is a more convenient version of SubscribeToOnInput , which receives events for any screen and has to be manually unsubscribed. SubscribeToOnInput offers lower-level interaction with the input system at the cost of ergonomics. Source code references UIScreenStack.uc:868-944","title":"SubscribeToOnInputForScreen"},{"location":"misc/SubscribeToOnInputForScreen/#subscribetooninputforscreen","text":"Tracking Issue: #501 Tags: ui Mods may want to intercept mouse/keyboard/controller input on certain screens and instead run their own code. For example, the Highlander adds a text to the main menu that has small pop-up accessible by pressing the right controller stick. The API consists of a delegate definition and two functions: delegate bool CHOnInputDelegateImproved(UIScreen Screen, int iInput, int ActionMask); function SubscribeToOnInputForScreen(UIScreen Screen, delegate<CHOnInputDelegateImproved> Callback); function UnsubscribeFromOnInputForScreen(UIScreen Screen, delegate<CHOnInputDelegateImproved> Callback); In a nutshell, with SubscribeToOnInputForScreen you ask the UIScreenStack \"when screen Screen would receive input, ask me first\". The CHOnInputDelegateImproved delegate defines the signature of the callback function called when the targeted screen would receive input. Your function will be called with three arguments: The screen that would have received the input ( Screen ), the button that was pressed ( iInput ), and the action that occured ( ActionMask , button press/release). The button and action are numeric values that correspond to constants in UIUtilities_Input.uc . If your function returns true, the ScreenStack will consider the input handled and immediately stop processing the input event. If your function returns false, the ScreenStack will continue calling other subscribers and, if unhandled, will finally notify the screen itself. You can manually unsubscribe from receiving input, but this is generally not necessary as your callback will only be called when the screen would have received input and will automatically be unsubscribed upon removal of the targeted screen. The following simplified example is taken from Covert Infiltration : class UIListener_Mission extends UIScreenListener; event OnInit (UIScreen Screen) { local UIMission MissionScreen; MissionScreen = UIMission(Screen); if (MissionScreen == none) return; // This is a UIMission screen, register MissionScreen.Movie.Stack.SubscribeToOnInputForScreen(MissionScreen, OnMissionScreenInput); } simulated protected function bool OnMissionScreenInput (UIScreen Screen, int iInput, int ActionMask) { if (!Screen.CheckInputIsReleaseOrDirectionRepeat(iInput, ActionMask)) { return false; } switch (iInput) { case class'UIUtilities_Input'.const.FXS_BUTTON_RTRIGGER: // The right controller trigger was just released, show custom screen // ... // Tell the ScreenStack that this input was handled return true; break; } return false; } CheckInputIsReleaseOrDirectionRepeat ensures that the button was just released (or, if directional button, held for a long time), making input behavior more consistent with base game screens. Although all mouse events can be inspected, Flash usually provides its own handlers that run even if the callback indicates to the ScreenStack that the input was handled. As a result, the only mouse event that can reliably be stopped with SubscribeToOnInputForScreen is the already navigation-relevant right click. This feature is a more convenient version of SubscribeToOnInput , which receives events for any screen and has to be manually unsubscribed. SubscribeToOnInput offers lower-level interaction with the input system at the cost of ergonomics.","title":"SubscribeToOnInputForScreen"},{"location":"misc/SubscribeToOnInputForScreen/#source-code-references","text":"UIScreenStack.uc:868-944","title":"Source code references"},{"location":"misc/TintMaterialConfigs/","text":"TintMaterialConfigs Tracking Issue: #356 Tags: customization , pawns When determining which values to pass to the material using which parameter names, the game matches against a hardcoded list of material names. As a result, mods need to confusingly name their modified materials exactly the same as base-game materials. This change moves these hardcoded names to config lists: var config(Content) array<name> HairMaterial; var config(Content) array<name> SkinMaterial; var config(Content) array<name> ArmorMaterial; var config(Content) array<name> WepAsArmorMaterial; var config(Content) array<name> EyeMaterial; var config(Content) array<name> FlagMaterial; You can add your own materials by creating the following lines in XComContent.ini : [XComGame.CHHelpers] +EyeMaterial=\"MyCustomEyesCustomizable_TC\" Source code references CHHelpers.uc:114-132 XComContent.ini:31 XComHumanPawn.uc:932","title":"TintMaterialConfigs"},{"location":"misc/TintMaterialConfigs/#tintmaterialconfigs","text":"Tracking Issue: #356 Tags: customization , pawns When determining which values to pass to the material using which parameter names, the game matches against a hardcoded list of material names. As a result, mods need to confusingly name their modified materials exactly the same as base-game materials. This change moves these hardcoded names to config lists: var config(Content) array<name> HairMaterial; var config(Content) array<name> SkinMaterial; var config(Content) array<name> ArmorMaterial; var config(Content) array<name> WepAsArmorMaterial; var config(Content) array<name> EyeMaterial; var config(Content) array<name> FlagMaterial; You can add your own materials by creating the following lines in XComContent.ini : [XComGame.CHHelpers] +EyeMaterial=\"MyCustomEyesCustomizable_TC\"","title":"TintMaterialConfigs"},{"location":"misc/TintMaterialConfigs/#source-code-references","text":"CHHelpers.uc:114-132 XComContent.ini:31 XComHumanPawn.uc:932","title":"Source code references"},{"location":"misc/UpdateHumanPawnMeshComponent/","text":"UpdateHumanPawnMeshComponent Tracking Issue: #216 Tags: customization , pawns Adds a DLC hook to update a given human pawn mesh component's materials. static function UpdateHumanPawnMeshComponent(XComGameState_Unit UnitState, XComHumanPawn Pawn, MeshComponent MeshComp); This can be used to apply custom materials to meshes, or set custom parameters. If not overridden, this calls UpdateHumanPawnMeshMaterial for every MaterialInstanceConstant. Call super.UpdateHumanPawnMeshComponent(UnitState, Pawn, MeshComp); if you rely on both hooks. Source code references X2DownloadableContentInfo.uc:551-562 XComHumanPawn.uc:972","title":"UpdateHumanPawnMeshComponent"},{"location":"misc/UpdateHumanPawnMeshComponent/#updatehumanpawnmeshcomponent","text":"Tracking Issue: #216 Tags: customization , pawns Adds a DLC hook to update a given human pawn mesh component's materials. static function UpdateHumanPawnMeshComponent(XComGameState_Unit UnitState, XComHumanPawn Pawn, MeshComponent MeshComp); This can be used to apply custom materials to meshes, or set custom parameters. If not overridden, this calls UpdateHumanPawnMeshMaterial for every MaterialInstanceConstant. Call super.UpdateHumanPawnMeshComponent(UnitState, Pawn, MeshComp); if you rely on both hooks.","title":"UpdateHumanPawnMeshComponent"},{"location":"misc/UpdateHumanPawnMeshComponent/#source-code-references","text":"X2DownloadableContentInfo.uc:551-562 XComHumanPawn.uc:972","title":"Source code references"},{"location":"misc/UpdateHumanPawnMeshMaterial/","text":"UpdateHumanPawnMeshMaterial Tracking Issue: #169 Tags: customization , pawns Adds a DLC hook to update a given material applied to a human pawn mesh component that can be used to set custom parameters on materials. static function UpdateHumanPawnMeshMaterial(XComGameState_Unit UnitState, XComHumanPawn Pawn, MeshComponent MeshComp, name ParentMaterialName, MaterialInstanceConstant MIC); This is called by UpdateHumanPawnMeshComponent if not overridden. UpdateHumanPawnMeshComponent allows more control over the materials, like being able to use MaterialInstanceTimeVarying or outright replacing materials. The following simplified example is taken from the Warhammer 40,000: Armours of the Imperium mod. Its armor uses custom material names and requires that the eye color is passed to the material using EmissiveColor instead of EyeColor : static function UpdateHumanPawnMeshMaterial(XComGameState_Unit UnitState, XComHumanPawn Pawn, MeshComponent MeshComp, name ParentMaterialName, MaterialInstanceConstant MIC) { local XComLinearColorPalette Palette; local LinearColor ParamColor; if (MaterialInstanceConstant(MIC.Parent).Name == 'Mat_SpaceMarine_Eyes') { Palette = `CONTENT.GetColorPalette(ePalette_EyeColor); ParamColor = Palette.Entries[Pawn.m_kAppearance.iEyeColor].Primary; MIC.SetVectorParameterValue('EmissiveColor', ParamColor); } } Note that a subset of this functionality (specifically if the material parameter names match) can be implemented with config only (no code) using the TintMaterialConfigs feature. Source code references X2DownloadableContentInfo.uc:505-538","title":"UpdateHumanPawnMeshMaterial"},{"location":"misc/UpdateHumanPawnMeshMaterial/#updatehumanpawnmeshmaterial","text":"Tracking Issue: #169 Tags: customization , pawns Adds a DLC hook to update a given material applied to a human pawn mesh component that can be used to set custom parameters on materials. static function UpdateHumanPawnMeshMaterial(XComGameState_Unit UnitState, XComHumanPawn Pawn, MeshComponent MeshComp, name ParentMaterialName, MaterialInstanceConstant MIC); This is called by UpdateHumanPawnMeshComponent if not overridden. UpdateHumanPawnMeshComponent allows more control over the materials, like being able to use MaterialInstanceTimeVarying or outright replacing materials. The following simplified example is taken from the Warhammer 40,000: Armours of the Imperium mod. Its armor uses custom material names and requires that the eye color is passed to the material using EmissiveColor instead of EyeColor : static function UpdateHumanPawnMeshMaterial(XComGameState_Unit UnitState, XComHumanPawn Pawn, MeshComponent MeshComp, name ParentMaterialName, MaterialInstanceConstant MIC) { local XComLinearColorPalette Palette; local LinearColor ParamColor; if (MaterialInstanceConstant(MIC.Parent).Name == 'Mat_SpaceMarine_Eyes') { Palette = `CONTENT.GetColorPalette(ePalette_EyeColor); ParamColor = Palette.Entries[Pawn.m_kAppearance.iEyeColor].Primary; MIC.SetVectorParameterValue('EmissiveColor', ParamColor); } } Note that a subset of this functionality (specifically if the material parameter names match) can be implemented with config only (no code) using the TintMaterialConfigs feature.","title":"UpdateHumanPawnMeshMaterial"},{"location":"misc/UpdateHumanPawnMeshMaterial/#source-code-references","text":"X2DownloadableContentInfo.uc:505-538","title":"Source code references"},{"location":"misc/XComLWTuple/","text":"XComLWTuple Tracking Issue: #754 Tags: events XComLWTuple is based on the original LWTuple that many other mods package themselves, but it cannot be used interchangeably with that class. That means you have to use XComLWTuple for community highlander hooks that rely on it. LWTuple can be used to pass information between two mods without those mods needing to share any additional class types. Typically this information is passed using the XCOM2 event system: an event trigger passes an LWTuple as the EventData, and the listeners can retrieve this LWTuple. Data can be passed in both directions through this system, and the only type they both need to know about is LWTuple. LWTuples contain an id (a name) and an array of LWTValue values. The name is arbitrary and can be used to allow the sender and receiver to validate they are working with the tuple they are expecting. The data array holds the actual data to pass. LWTValue values are a union-like structure, similar to the ASValue struct used by the Scaleform system. A value can hold a bool, int, float, string, name, or object. Values are used by setting the field corresponding to the type you wish to store (e.g. i for int) and setting the kind field to the corresponding enum value (LWTVInt in this case). Readers should read only the field corresponding to the kind set in the value. To use a tuple with the event system, the code firing the event should \"new\" a LWTuple, set its ID field to an appropriate name, optionally fill in any information needed by the event listeners, and pass it as the EventData for the event. Listeners should cast the EventData back to a LWTuple, validate that the result is not none, that its ID is the one they are expecting, and that any contents are as expected. They can then store any new data needed into the tuple by adding to the data array before returning from the listener. These listeners should typically use ELDImmediate as their deferral mode so that the results are immediately processed and passed back to the caller, although mods may advertise longer-lived tuples that can be processed with other deferral strategies. Note that since multiple mods can all be listening on the same event there may be multiple mods receiving the same tuple. If more than one mod needs to return data in a tuple that was not intended to receive data from more than one mod a conflict occurs and these mods may be incompatible. List of data types The kind of data stored in a XComLWTValue. Find the corresponding struct property names in XComLWTuple.uc (see Source code references ) enum XComLWTValueKind { XComLWTVBool, XComLWTVInt, XComLWTVFloat, XComLWTVString, XComLWTVName, XComLWTVObject, XComLWTVVector, XComLWTVRotator, XComLWTVTile, XComLWTVArrayObjects, XComLWTVArrayInts, XComLWTVArrayFloats, XComLWTVArrayStrings, XComLWTVArrayNames, XComLWTVArrayVectors, XComLWTVArrayRotators, XComLWTVArrayTiles }; Source code references XComLWTuple.uc:6-43 XComLWTuple.uc:47-73","title":"XComLWTuple"},{"location":"misc/XComLWTuple/#xcomlwtuple","text":"Tracking Issue: #754 Tags: events XComLWTuple is based on the original LWTuple that many other mods package themselves, but it cannot be used interchangeably with that class. That means you have to use XComLWTuple for community highlander hooks that rely on it. LWTuple can be used to pass information between two mods without those mods needing to share any additional class types. Typically this information is passed using the XCOM2 event system: an event trigger passes an LWTuple as the EventData, and the listeners can retrieve this LWTuple. Data can be passed in both directions through this system, and the only type they both need to know about is LWTuple. LWTuples contain an id (a name) and an array of LWTValue values. The name is arbitrary and can be used to allow the sender and receiver to validate they are working with the tuple they are expecting. The data array holds the actual data to pass. LWTValue values are a union-like structure, similar to the ASValue struct used by the Scaleform system. A value can hold a bool, int, float, string, name, or object. Values are used by setting the field corresponding to the type you wish to store (e.g. i for int) and setting the kind field to the corresponding enum value (LWTVInt in this case). Readers should read only the field corresponding to the kind set in the value. To use a tuple with the event system, the code firing the event should \"new\" a LWTuple, set its ID field to an appropriate name, optionally fill in any information needed by the event listeners, and pass it as the EventData for the event. Listeners should cast the EventData back to a LWTuple, validate that the result is not none, that its ID is the one they are expecting, and that any contents are as expected. They can then store any new data needed into the tuple by adding to the data array before returning from the listener. These listeners should typically use ELDImmediate as their deferral mode so that the results are immediately processed and passed back to the caller, although mods may advertise longer-lived tuples that can be processed with other deferral strategies. Note that since multiple mods can all be listening on the same event there may be multiple mods receiving the same tuple. If more than one mod needs to return data in a tuple that was not intended to receive data from more than one mod a conflict occurs and these mods may be incompatible.","title":"XComLWTuple"},{"location":"misc/XComLWTuple/#list-of-data-types","text":"The kind of data stored in a XComLWTValue. Find the corresponding struct property names in XComLWTuple.uc (see Source code references ) enum XComLWTValueKind { XComLWTVBool, XComLWTVInt, XComLWTVFloat, XComLWTVString, XComLWTVName, XComLWTVObject, XComLWTVVector, XComLWTVRotator, XComLWTVTile, XComLWTVArrayObjects, XComLWTVArrayInts, XComLWTVArrayFloats, XComLWTVArrayStrings, XComLWTVArrayNames, XComLWTVArrayVectors, XComLWTVArrayRotators, XComLWTVArrayTiles };","title":"List of data types"},{"location":"misc/XComLWTuple/#source-code-references","text":"XComLWTuple.uc:6-43 XComLWTuple.uc:47-73","title":"Source code references"},{"location":"strategy/AfterActionModifyRecoveredLoot/","text":"AfterActionModifyRecoveredLoot Tracking Issue: #736 The event is triggered after the cache items were unpacked but before any loot is shown in the UI. Part of the post-mission sequence. Inspect XComGameState_HeadquartersXCom.LootRecovered for the pending loot EventID: AfterActionModifyRecoveredLoot EventSource: UIInventory_LootRecovered (self) No game state is passed, so make sure to use ELD_Immediate Source code references UIInventory_LootRecovered.uc:92-101","title":"AfterActionModifyRecoveredLoot"},{"location":"strategy/AfterActionModifyRecoveredLoot/#afteractionmodifyrecoveredloot","text":"Tracking Issue: #736 The event is triggered after the cache items were unpacked but before any loot is shown in the UI. Part of the post-mission sequence. Inspect XComGameState_HeadquartersXCom.LootRecovered for the pending loot EventID: AfterActionModifyRecoveredLoot EventSource: UIInventory_LootRecovered (self) No game state is passed, so make sure to use ELD_Immediate","title":"AfterActionModifyRecoveredLoot"},{"location":"strategy/AfterActionModifyRecoveredLoot/#source-code-references","text":"UIInventory_LootRecovered.uc:92-101","title":"Source code references"},{"location":"strategy/AllowNoSquadSizeUpgradeAchievement/","text":"AllowNoSquadSizeUpgradeAchievement Tracking Issue: #994 Tags: events The achievement \"The Few and the Proud\" requires the player to defeat the aliens on Commander or Legend difficulty without increasing their squad size. The default logic checks specifically for the GTS upgrades SquadSizeIUnlock and SquadSizeIIUnlock and rewards the achievement if the player has neither upgrade purchased. The event AllowNoSquadSizeUpgradeAchievement is triggered after the player finishes the final mission, in X2AchievementTracker. It resides in a static function, so there is no EventSource nor XComGameState passed. The EventData that is passed contains a LWTuple with a single boolean value. The value is initially set to the result of the default logic described above. Modders should check whatever they need to check and return the tuple value as true if the achievement should be awarded, or false otherwise. AllowNoSquadSizeUpgradeAchievement event Param Value EventID AllowNoSquadSizeUpgradeAchievement EventData XComLWTuple EventSource none NewGameState none Tuple contents Index Name Type Direction 0 AllowAchievement bool inout Listener template static function EventListenerReturn OnAllowNoSquadSizeUpgradeAchievement(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local bool AllowAchievement; Tuple = XComLWTuple(EventData); AllowAchievement = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = AllowAchievement; return ELR_NoInterrupt; } Source code references X2AchievementTracker.uc:831-851 X2AchievementTracker.uc:759","title":"AllowNoSquadSizeUpgradeAchievement"},{"location":"strategy/AllowNoSquadSizeUpgradeAchievement/#allownosquadsizeupgradeachievement","text":"Tracking Issue: #994 Tags: events The achievement \"The Few and the Proud\" requires the player to defeat the aliens on Commander or Legend difficulty without increasing their squad size. The default logic checks specifically for the GTS upgrades SquadSizeIUnlock and SquadSizeIIUnlock and rewards the achievement if the player has neither upgrade purchased. The event AllowNoSquadSizeUpgradeAchievement is triggered after the player finishes the final mission, in X2AchievementTracker. It resides in a static function, so there is no EventSource nor XComGameState passed. The EventData that is passed contains a LWTuple with a single boolean value. The value is initially set to the result of the default logic described above. Modders should check whatever they need to check and return the tuple value as true if the achievement should be awarded, or false otherwise.","title":"AllowNoSquadSizeUpgradeAchievement"},{"location":"strategy/AllowNoSquadSizeUpgradeAchievement/#allownosquadsizeupgradeachievement-event","text":"Param Value EventID AllowNoSquadSizeUpgradeAchievement EventData XComLWTuple EventSource none NewGameState none","title":"AllowNoSquadSizeUpgradeAchievement event"},{"location":"strategy/AllowNoSquadSizeUpgradeAchievement/#tuple-contents","text":"Index Name Type Direction 0 AllowAchievement bool inout","title":"Tuple contents"},{"location":"strategy/AllowNoSquadSizeUpgradeAchievement/#listener-template","text":"static function EventListenerReturn OnAllowNoSquadSizeUpgradeAchievement(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local bool AllowAchievement; Tuple = XComLWTuple(EventData); AllowAchievement = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = AllowAchievement; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/AllowNoSquadSizeUpgradeAchievement/#source-code-references","text":"X2AchievementTracker.uc:831-851 X2AchievementTracker.uc:759","title":"Source code references"},{"location":"strategy/AllowOnCovertActionCompleteAnalytics/","text":"AllowOnCovertActionCompleteAnalytics Tracking Issue: #752 Tags: events Allows mods to prevent CA completion from counting towards campaign stats. This event is triggered from AnalyticsManager::OnCoverActionComplete and passes all original listener arguments in the tuple. AllowOnCovertActionCompleteAnalytics event Param Value EventID AllowOnCovertActionCompleteAnalytics EventData XComLWTuple EventSource none NewGameState none Tuple contents Index Name Type Direction 0 bAllow bool inout 1 OriginalEventData Object in 2 OriginalEventSource Object in 3 OriginalGameState XComGameState in 4 OriginalEvent name in 5 OriginalCallbackData Object in Listener template static function EventListenerReturn OnAllowOnCovertActionCompleteAnalytics(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local bool bAllow; local Object OriginalEventData; local Object OriginalEventSource; local XComGameState OriginalGameState; local name OriginalEvent; local Object OriginalCallbackData; Tuple = XComLWTuple(EventData); bAllow = Tuple.Data[0].b; OriginalEventData = Tuple.Data[1].o; OriginalEventSource = Tuple.Data[2].o; OriginalGameState = XComGameState(Tuple.Data[3].o); OriginalEvent = Tuple.Data[4].n; OriginalCallbackData = Tuple.Data[5].o; // Your code here Tuple.Data[0].b = bAllow; return ELR_NoInterrupt; } Note 1: The OriginalEventSource should be the XComGameState_CovertAction that was just completed, although the AnalyticsManager code does not validate that. Note 2: you must subscribe with ELD_Immediate deferral to modify bAllow Source code references AnalyticsManager.uc:919-942","title":"AllowOnCovertActionCompleteAnalytics"},{"location":"strategy/AllowOnCovertActionCompleteAnalytics/#allowoncovertactioncompleteanalytics","text":"Tracking Issue: #752 Tags: events Allows mods to prevent CA completion from counting towards campaign stats. This event is triggered from AnalyticsManager::OnCoverActionComplete and passes all original listener arguments in the tuple.","title":"AllowOnCovertActionCompleteAnalytics"},{"location":"strategy/AllowOnCovertActionCompleteAnalytics/#allowoncovertactioncompleteanalytics-event","text":"Param Value EventID AllowOnCovertActionCompleteAnalytics EventData XComLWTuple EventSource none NewGameState none","title":"AllowOnCovertActionCompleteAnalytics event"},{"location":"strategy/AllowOnCovertActionCompleteAnalytics/#tuple-contents","text":"Index Name Type Direction 0 bAllow bool inout 1 OriginalEventData Object in 2 OriginalEventSource Object in 3 OriginalGameState XComGameState in 4 OriginalEvent name in 5 OriginalCallbackData Object in","title":"Tuple contents"},{"location":"strategy/AllowOnCovertActionCompleteAnalytics/#listener-template","text":"static function EventListenerReturn OnAllowOnCovertActionCompleteAnalytics(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local bool bAllow; local Object OriginalEventData; local Object OriginalEventSource; local XComGameState OriginalGameState; local name OriginalEvent; local Object OriginalCallbackData; Tuple = XComLWTuple(EventData); bAllow = Tuple.Data[0].b; OriginalEventData = Tuple.Data[1].o; OriginalEventSource = Tuple.Data[2].o; OriginalGameState = XComGameState(Tuple.Data[3].o); OriginalEvent = Tuple.Data[4].n; OriginalCallbackData = Tuple.Data[5].o; // Your code here Tuple.Data[0].b = bAllow; return ELR_NoInterrupt; } Note 1: The OriginalEventSource should be the XComGameState_CovertAction that was just completed, although the AnalyticsManager code does not validate that. Note 2: you must subscribe with ELD_Immediate deferral to modify bAllow","title":"Listener template"},{"location":"strategy/AllowOnCovertActionCompleteAnalytics/#source-code-references","text":"AnalyticsManager.uc:919-942","title":"Source code references"},{"location":"strategy/AllowRulerOnMission/","text":"AllowRulerOnMission Tracking Issue: #791 Tags: dlc2 , events Allows listeners to forbid a particular (or all) rulers from a particular XComGameState_MissionSite . Be aware that the AlienRulerLocations system completely bypasses this check (doesn't trigger this event). AllowRulerOnMission event Param Value EventID AllowRulerOnMission EventData XComLWTuple EventSource XComGameState_MissionSite NewGameState yes Tuple contents Index Name Type Direction 0 bAllowRuler bool inout 1 RulerObjectID int in Listener template static function EventListenerReturn OnAllowRulerOnMission(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_MissionSite MissionState; local XComLWTuple Tuple; local bool bAllowRuler; local int RulerObjectID; MissionState = XComGameState_MissionSite(EventSource); Tuple = XComLWTuple(EventData); bAllowRuler = Tuple.Data[0].b; RulerObjectID = Tuple.Data[1].i; // Your code here Tuple.Data[0].b = bAllowRuler; return ELR_NoInterrupt; } Source code references XComGameState_AlienRulerManager.uc:487-500 XComGameState_AlienRulerManager.uc:467","title":"AllowRulerOnMission"},{"location":"strategy/AllowRulerOnMission/#allowruleronmission","text":"Tracking Issue: #791 Tags: dlc2 , events Allows listeners to forbid a particular (or all) rulers from a particular XComGameState_MissionSite . Be aware that the AlienRulerLocations system completely bypasses this check (doesn't trigger this event).","title":"AllowRulerOnMission"},{"location":"strategy/AllowRulerOnMission/#allowruleronmission-event","text":"Param Value EventID AllowRulerOnMission EventData XComLWTuple EventSource XComGameState_MissionSite NewGameState yes","title":"AllowRulerOnMission event"},{"location":"strategy/AllowRulerOnMission/#tuple-contents","text":"Index Name Type Direction 0 bAllowRuler bool inout 1 RulerObjectID int in","title":"Tuple contents"},{"location":"strategy/AllowRulerOnMission/#listener-template","text":"static function EventListenerReturn OnAllowRulerOnMission(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_MissionSite MissionState; local XComLWTuple Tuple; local bool bAllowRuler; local int RulerObjectID; MissionState = XComGameState_MissionSite(EventSource); Tuple = XComLWTuple(EventData); bAllowRuler = Tuple.Data[0].b; RulerObjectID = Tuple.Data[1].i; // Your code here Tuple.Data[0].b = bAllowRuler; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/AllowRulerOnMission/#source-code-references","text":"XComGameState_AlienRulerManager.uc:487-500 XComGameState_AlienRulerManager.uc:467","title":"Source code references"},{"location":"strategy/CanNeverBeRookieCovertAction/","text":"CanNeverBeRookieCovertAction Tracking Issue: #695 The game has a concept of \"Rookie Covert Actions\", which are meant to be always available to the player. Any Covert Action without soldier rank requirements is deemed to be a \"rookie\" Covert Action, and any of its spawn requirements will be ignored under certain conditions. Mods that intend to add Covert Actions without soldier rank requirements but with spawn requirements should set bCanNeverBeRookie to true so that the game actually takes their spawn requirements into account. Source code references X2CovertActionTemplate.uc:29-35 XComGameState_HeadquartersResistance.uc:1650","title":"CanNeverBeRookieCovertAction"},{"location":"strategy/CanNeverBeRookieCovertAction/#canneverberookiecovertaction","text":"Tracking Issue: #695 The game has a concept of \"Rookie Covert Actions\", which are meant to be always available to the player. Any Covert Action without soldier rank requirements is deemed to be a \"rookie\" Covert Action, and any of its spawn requirements will be ignored under certain conditions. Mods that intend to add Covert Actions without soldier rank requirements but with spawn requirements should set bCanNeverBeRookie to true so that the game actually takes their spawn requirements into account.","title":"CanNeverBeRookieCovertAction"},{"location":"strategy/CanNeverBeRookieCovertAction/#source-code-references","text":"X2CovertActionTemplate.uc:29-35 XComGameState_HeadquartersResistance.uc:1650","title":"Source code references"},{"location":"strategy/CanTechBeInspired/","text":"CanTechBeInspired Tracking Issue: #633 Tags: events The CanTechBeInspired event allows mods to forbid a tech from being inspired. This provides an important lever for balancing the strategy game. It's particularly important for repeatable techs, which the inspiration mechanic doesn't seem to handle very well (the techs remain inspired even after the first inspired research of them is complete). CanTechBeInspired event Param Value EventID CanTechBeInspired EventData XComLWTuple EventSource XComGameState_Tech NewGameState yes Tuple contents Index Name Type Direction 0 bCanTechBeInspired bool inout Listener template static function EventListenerReturn OnCanTechBeInspired(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Tech TechState; local XComLWTuple Tuple; local bool bCanTechBeInspired; TechState = XComGameState_Tech(EventSource); Tuple = XComLWTuple(EventData); bCanTechBeInspired = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bCanTechBeInspired; return ELR_NoInterrupt; } Source code references XComGameState_HeadquartersXCom.uc:7016-7027","title":"CanTechBeInspired"},{"location":"strategy/CanTechBeInspired/#cantechbeinspired","text":"Tracking Issue: #633 Tags: events The CanTechBeInspired event allows mods to forbid a tech from being inspired. This provides an important lever for balancing the strategy game. It's particularly important for repeatable techs, which the inspiration mechanic doesn't seem to handle very well (the techs remain inspired even after the first inspired research of them is complete).","title":"CanTechBeInspired"},{"location":"strategy/CanTechBeInspired/#cantechbeinspired-event","text":"Param Value EventID CanTechBeInspired EventData XComLWTuple EventSource XComGameState_Tech NewGameState yes","title":"CanTechBeInspired event"},{"location":"strategy/CanTechBeInspired/#tuple-contents","text":"Index Name Type Direction 0 bCanTechBeInspired bool inout","title":"Tuple contents"},{"location":"strategy/CanTechBeInspired/#listener-template","text":"static function EventListenerReturn OnCanTechBeInspired(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Tech TechState; local XComLWTuple Tuple; local bool bCanTechBeInspired; TechState = XComGameState_Tech(EventSource); Tuple = XComLWTuple(EventData); bCanTechBeInspired = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bCanTechBeInspired; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/CanTechBeInspired/#source-code-references","text":"XComGameState_HeadquartersXCom.uc:7016-7027","title":"Source code references"},{"location":"strategy/CanWeaponApplyUpgrade/","text":"CanWeaponApplyUpgrade Tracking Issue: #260 This function will be used to cycle through DLCInfos that will allow mods to check generally whether or not a weapon is compatible with an upgrade. X2WeaponUpgradeTemplate::CanApplyUpgradeToWeapon still exists as the \"can this upgrade be applied to this weapon RIGHT NOW?\" The best use case for this is to bar your weapon from applying upgrades that don't meet your criteria, without having to edit those upgrades directly. Note that this check is /in addition to/, and not /in lieu of/, CanApplyUpgradeToWeapon. This means you cannot use it to override that function's return value. Source code references XComGameState_Item.uc:2485-2493","title":"CanWeaponApplyUpgrade"},{"location":"strategy/CanWeaponApplyUpgrade/#canweaponapplyupgrade","text":"Tracking Issue: #260 This function will be used to cycle through DLCInfos that will allow mods to check generally whether or not a weapon is compatible with an upgrade. X2WeaponUpgradeTemplate::CanApplyUpgradeToWeapon still exists as the \"can this upgrade be applied to this weapon RIGHT NOW?\" The best use case for this is to bar your weapon from applying upgrades that don't meet your criteria, without having to edit those upgrades directly. Note that this check is /in addition to/, and not /in lieu of/, CanApplyUpgradeToWeapon. This means you cannot use it to override that function's return value.","title":"CanWeaponApplyUpgrade"},{"location":"strategy/CanWeaponApplyUpgrade/#source-code-references","text":"XComGameState_Item.uc:2485-2493","title":"Source code references"},{"location":"strategy/CovertAction_OverrideCostScalar/","text":"CovertAction_OverrideCostScalar Tracking Issue: #807 Tags: events Allows listeners to override the multiplier covert actions use to determine how many resources an optional cost requires. The game uses 0.5 by default, which means CAs need half the supplies/intel/etc. you would get from a POI as the cost to mitigate a risk. CovertAction_OverrideCostScalar event Param Value EventID CovertAction_OverrideCostScalar EventData XComLWTuple EventSource XComGameState_CovertAction NewGameState none Tuple contents Index Name Type Direction 0 DefaultCostScalar float inout 1 RewardState XComGameState_Reward in Listener template static function EventListenerReturn OnCovertAction_OverrideCostScalar(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_CovertAction ActionState; local XComLWTuple Tuple; local float DefaultCostScalar; local XComGameState_Reward RewardState; ActionState = XComGameState_CovertAction(EventSource); Tuple = XComLWTuple(EventData); DefaultCostScalar = Tuple.Data[0].f; RewardState = XComGameState_Reward(Tuple.Data[1].o); // Your code here Tuple.Data[0].f = DefaultCostScalar; return ELR_NoInterrupt; } Source code references XComGameState_CovertAction.uc:589-603","title":"CovertAction_OverrideCostScalar"},{"location":"strategy/CovertAction_OverrideCostScalar/#covertaction_overridecostscalar","text":"Tracking Issue: #807 Tags: events Allows listeners to override the multiplier covert actions use to determine how many resources an optional cost requires. The game uses 0.5 by default, which means CAs need half the supplies/intel/etc. you would get from a POI as the cost to mitigate a risk.","title":"CovertAction_OverrideCostScalar"},{"location":"strategy/CovertAction_OverrideCostScalar/#covertaction_overridecostscalar-event","text":"Param Value EventID CovertAction_OverrideCostScalar EventData XComLWTuple EventSource XComGameState_CovertAction NewGameState none","title":"CovertAction_OverrideCostScalar event"},{"location":"strategy/CovertAction_OverrideCostScalar/#tuple-contents","text":"Index Name Type Direction 0 DefaultCostScalar float inout 1 RewardState XComGameState_Reward in","title":"Tuple contents"},{"location":"strategy/CovertAction_OverrideCostScalar/#listener-template","text":"static function EventListenerReturn OnCovertAction_OverrideCostScalar(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_CovertAction ActionState; local XComLWTuple Tuple; local float DefaultCostScalar; local XComGameState_Reward RewardState; ActionState = XComGameState_CovertAction(EventSource); Tuple = XComLWTuple(EventData); DefaultCostScalar = Tuple.Data[0].f; RewardState = XComGameState_Reward(Tuple.Data[1].o); // Your code here Tuple.Data[0].f = DefaultCostScalar; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/CovertAction_OverrideCostScalar/#source-code-references","text":"XComGameState_CovertAction.uc:589-603","title":"Source code references"},{"location":"strategy/CovertAction_OverrideRewardScalar/","text":"CovertAction_OverrideRewardScalar Tracking Issue: #807 Tags: events Allows listeners to override the multiplier covert actions use to determine how many resources to award. The game uses 0.5 by default, which means CAs award half the supplies/intel/etc. you would get from a POI. CovertAction_OverrideRewardScalar event Param Value EventID CovertAction_OverrideRewardScalar EventData XComLWTuple EventSource XComGameState_CovertAction NewGameState none Tuple contents Index Name Type Direction 0 DefaultRewardScalar float inout 1 RewardState XComGameState_Reward in Listener template static function EventListenerReturn OnCovertAction_OverrideRewardScalar(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_CovertAction ActionState; local XComLWTuple Tuple; local float DefaultRewardScalar; local XComGameState_Reward RewardState; ActionState = XComGameState_CovertAction(EventSource); Tuple = XComLWTuple(EventData); DefaultRewardScalar = Tuple.Data[0].f; RewardState = XComGameState_Reward(Tuple.Data[1].o); // Your code here Tuple.Data[0].f = DefaultRewardScalar; return ELR_NoInterrupt; } Source code references XComGameState_CovertAction.uc:621-634","title":"CovertAction_OverrideRewardScalar"},{"location":"strategy/CovertAction_OverrideRewardScalar/#covertaction_overriderewardscalar","text":"Tracking Issue: #807 Tags: events Allows listeners to override the multiplier covert actions use to determine how many resources to award. The game uses 0.5 by default, which means CAs award half the supplies/intel/etc. you would get from a POI.","title":"CovertAction_OverrideRewardScalar"},{"location":"strategy/CovertAction_OverrideRewardScalar/#covertaction_overriderewardscalar-event","text":"Param Value EventID CovertAction_OverrideRewardScalar EventData XComLWTuple EventSource XComGameState_CovertAction NewGameState none","title":"CovertAction_OverrideRewardScalar event"},{"location":"strategy/CovertAction_OverrideRewardScalar/#tuple-contents","text":"Index Name Type Direction 0 DefaultRewardScalar float inout 1 RewardState XComGameState_Reward in","title":"Tuple contents"},{"location":"strategy/CovertAction_OverrideRewardScalar/#listener-template","text":"static function EventListenerReturn OnCovertAction_OverrideRewardScalar(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_CovertAction ActionState; local XComLWTuple Tuple; local float DefaultRewardScalar; local XComGameState_Reward RewardState; ActionState = XComGameState_CovertAction(EventSource); Tuple = XComLWTuple(EventData); DefaultRewardScalar = Tuple.Data[0].f; RewardState = XComGameState_Reward(Tuple.Data[1].o); // Your code here Tuple.Data[0].f = DefaultRewardScalar; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/CovertAction_OverrideRewardScalar/#source-code-references","text":"XComGameState_CovertAction.uc:621-634","title":"Source code references"},{"location":"strategy/CovertAction_OverrideRiskStrings/","text":"CovertAction_OverrideRiskStrings Tracking Issue: #779 Allows listeners to override how risk chances are displayed in the covert actions screen (UICovertActions). The names of each risk and the texts displayed to represent the chance of each one occurring are passed in the event as two separate arrays of strings. Note that the two arrays are in the same order, i.e. the first element of each array corresponds to the first risk, the second element to the second risk, and so on. Source code references XComGameState_CovertAction.uc:1422-1430","title":"CovertAction_OverrideRiskStrings"},{"location":"strategy/CovertAction_OverrideRiskStrings/#covertaction_overrideriskstrings","text":"Tracking Issue: #779 Allows listeners to override how risk chances are displayed in the covert actions screen (UICovertActions). The names of each risk and the texts displayed to represent the chance of each one occurring are passed in the event as two separate arrays of strings. Note that the two arrays are in the same order, i.e. the first element of each array corresponds to the first risk, the second element to the second risk, and so on.","title":"CovertAction_OverrideRiskStrings"},{"location":"strategy/CovertAction_OverrideRiskStrings/#source-code-references","text":"XComGameState_CovertAction.uc:1422-1430","title":"Source code references"},{"location":"strategy/CovertAction_PreventGiveRewards/","text":"CovertAction_PreventGiveRewards Tracking Issue: #438 Tags: events Fires an event that allows listeners to prevent the covert action from awarding the action's rewards to the player. Note that if the PreventGiveRewards boolean is true then not only are the rewards not given, but the soldiers on the covert action get no XP or cohesion. The results are saved and are used to adjust UI later. CovertAction_PreventGiveRewards event Param Value EventID CovertAction_PreventGiveRewards EventData XComLWTuple EventSource XComGameState_CovertAction NewGameState none Tuple contents Index Name Type Direction 0 PreventGiveRewards bool inout Listener template static function EventListenerReturn OnCovertAction_PreventGiveRewards(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_CovertAction CAState; local XComLWTuple Tuple; local bool PreventGiveRewards; CAState = XComGameState_CovertAction(EventSource); Tuple = XComLWTuple(EventData); PreventGiveRewards = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = PreventGiveRewards; return ELR_NoInterrupt; } Source code references XComGameState_CovertAction.uc:715-726 UICovertActionStaffSlot.uc:177 XComGameState_CovertAction.uc:2346","title":"CovertAction_PreventGiveRewards"},{"location":"strategy/CovertAction_PreventGiveRewards/#covertaction_preventgiverewards","text":"Tracking Issue: #438 Tags: events Fires an event that allows listeners to prevent the covert action from awarding the action's rewards to the player. Note that if the PreventGiveRewards boolean is true then not only are the rewards not given, but the soldiers on the covert action get no XP or cohesion. The results are saved and are used to adjust UI later.","title":"CovertAction_PreventGiveRewards"},{"location":"strategy/CovertAction_PreventGiveRewards/#covertaction_preventgiverewards-event","text":"Param Value EventID CovertAction_PreventGiveRewards EventData XComLWTuple EventSource XComGameState_CovertAction NewGameState none","title":"CovertAction_PreventGiveRewards event"},{"location":"strategy/CovertAction_PreventGiveRewards/#tuple-contents","text":"Index Name Type Direction 0 PreventGiveRewards bool inout","title":"Tuple contents"},{"location":"strategy/CovertAction_PreventGiveRewards/#listener-template","text":"static function EventListenerReturn OnCovertAction_PreventGiveRewards(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_CovertAction CAState; local XComLWTuple Tuple; local bool PreventGiveRewards; CAState = XComGameState_CovertAction(EventSource); Tuple = XComLWTuple(EventData); PreventGiveRewards = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = PreventGiveRewards; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/CovertAction_PreventGiveRewards/#source-code-references","text":"XComGameState_CovertAction.uc:715-726 UICovertActionStaffSlot.uc:177 XComGameState_CovertAction.uc:2346","title":"Source code references"},{"location":"strategy/DynamicSoldierClassDisplay/","text":"DynamicSoldierClassDisplay Tracking Issue: #106 Tags: ui , events Mods may want to manipulate the way a soldier's class is displayed (in terms of icon/name/description) in more dynamic ways. For example, RPGOverhaul has a single soldier class and the way it is displayed depends on selected skills and loadouts. There are three events with mostly self-explanatory names: SoldierClassIcon event Param Value EventID SoldierClassIcon EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 IconImagePath string inout Listener template static function EventListenerReturn OnSoldierClassIcon(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local string IconImagePath; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); IconImagePath = Tuple.Data[0].s; // Your code here Tuple.Data[0].s = IconImagePath; return ELR_NoInterrupt; } SoldierClassDisplayName event Param Value EventID SoldierClassDisplayName EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 DisplayName string inout Listener template static function EventListenerReturn OnSoldierClassDisplayName(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local string DisplayName; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); DisplayName = Tuple.Data[0].s; // Your code here Tuple.Data[0].s = DisplayName; return ELR_NoInterrupt; } SoldierClassSummary event Param Value EventID SoldierClassSummary EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 DisplaySummary string inout Listener template static function EventListenerReturn OnSoldierClassSummary(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local string DisplaySummary; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); DisplaySummary = Tuple.Data[0].s; // Your code here Tuple.Data[0].s = DisplaySummary; return ELR_NoInterrupt; } There is a sister feature DynamicSoldierRankDisplay that extends this to rank icon/name. Source code references XComGameState_Unit.uc:15588-15615","title":"DynamicSoldierClassDisplay"},{"location":"strategy/DynamicSoldierClassDisplay/#dynamicsoldierclassdisplay","text":"Tracking Issue: #106 Tags: ui , events Mods may want to manipulate the way a soldier's class is displayed (in terms of icon/name/description) in more dynamic ways. For example, RPGOverhaul has a single soldier class and the way it is displayed depends on selected skills and loadouts. There are three events with mostly self-explanatory names:","title":"DynamicSoldierClassDisplay"},{"location":"strategy/DynamicSoldierClassDisplay/#soldierclassicon-event","text":"Param Value EventID SoldierClassIcon EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"SoldierClassIcon event"},{"location":"strategy/DynamicSoldierClassDisplay/#tuple-contents","text":"Index Name Type Direction 0 IconImagePath string inout","title":"Tuple contents"},{"location":"strategy/DynamicSoldierClassDisplay/#listener-template","text":"static function EventListenerReturn OnSoldierClassIcon(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local string IconImagePath; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); IconImagePath = Tuple.Data[0].s; // Your code here Tuple.Data[0].s = IconImagePath; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/DynamicSoldierClassDisplay/#soldierclassdisplayname-event","text":"Param Value EventID SoldierClassDisplayName EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"SoldierClassDisplayName event"},{"location":"strategy/DynamicSoldierClassDisplay/#tuple-contents_1","text":"Index Name Type Direction 0 DisplayName string inout","title":"Tuple contents"},{"location":"strategy/DynamicSoldierClassDisplay/#listener-template_1","text":"static function EventListenerReturn OnSoldierClassDisplayName(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local string DisplayName; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); DisplayName = Tuple.Data[0].s; // Your code here Tuple.Data[0].s = DisplayName; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/DynamicSoldierClassDisplay/#soldierclasssummary-event","text":"Param Value EventID SoldierClassSummary EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"SoldierClassSummary event"},{"location":"strategy/DynamicSoldierClassDisplay/#tuple-contents_2","text":"Index Name Type Direction 0 DisplaySummary string inout","title":"Tuple contents"},{"location":"strategy/DynamicSoldierClassDisplay/#listener-template_2","text":"static function EventListenerReturn OnSoldierClassSummary(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local string DisplaySummary; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); DisplaySummary = Tuple.Data[0].s; // Your code here Tuple.Data[0].s = DisplaySummary; return ELR_NoInterrupt; } There is a sister feature DynamicSoldierRankDisplay that extends this to rank icon/name.","title":"Listener template"},{"location":"strategy/DynamicSoldierClassDisplay/#source-code-references","text":"XComGameState_Unit.uc:15588-15615","title":"Source code references"},{"location":"strategy/DynamicSoldierRankDisplay/","text":"DynamicSoldierRankDisplay Tracking Issue: #408 Tags: ui , events Mods may want to manipulate the way a soldier's rank is displayed (in terms of icon/name/description) in more dynamic ways. For example, LWOTC shows officer ranks for units with special officer abilities. There are three events with mostly self-explanatory names: SoldierRankName event Param Value EventID SoldierRankName EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 Rank int in 1 DisplayRankName string inout Listener template static function EventListenerReturn OnSoldierRankName(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local int Rank; local string DisplayRankName; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); Rank = Tuple.Data[0].i; DisplayRankName = Tuple.Data[1].s; // Your code here Tuple.Data[1].s = DisplayRankName; return ELR_NoInterrupt; } SoldierShortRankName event Param Value EventID SoldierShortRankName EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 Rank int in 1 DisplayShortRankName string inout Listener template static function EventListenerReturn OnSoldierShortRankName(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local int Rank; local string DisplayShortRankName; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); Rank = Tuple.Data[0].i; DisplayShortRankName = Tuple.Data[1].s; // Your code here Tuple.Data[1].s = DisplayShortRankName; return ELR_NoInterrupt; } SoldierRankIcon event Param Value EventID SoldierRankIcon EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 Rank int in 1 IconImagePath string inout Listener template static function EventListenerReturn OnSoldierRankIcon(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local int Rank; local string IconImagePath; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); Rank = Tuple.Data[0].i; IconImagePath = Tuple.Data[1].s; // Your code here Tuple.Data[1].s = IconImagePath; return ELR_NoInterrupt; } There is a sister feature DynamicSoldierClassDisplay that extends this to class icon/name. Source code references XComGameState_Unit.uc:15680-15708","title":"DynamicSoldierRankDisplay"},{"location":"strategy/DynamicSoldierRankDisplay/#dynamicsoldierrankdisplay","text":"Tracking Issue: #408 Tags: ui , events Mods may want to manipulate the way a soldier's rank is displayed (in terms of icon/name/description) in more dynamic ways. For example, LWOTC shows officer ranks for units with special officer abilities. There are three events with mostly self-explanatory names:","title":"DynamicSoldierRankDisplay"},{"location":"strategy/DynamicSoldierRankDisplay/#soldierrankname-event","text":"Param Value EventID SoldierRankName EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"SoldierRankName event"},{"location":"strategy/DynamicSoldierRankDisplay/#tuple-contents","text":"Index Name Type Direction 0 Rank int in 1 DisplayRankName string inout","title":"Tuple contents"},{"location":"strategy/DynamicSoldierRankDisplay/#listener-template","text":"static function EventListenerReturn OnSoldierRankName(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local int Rank; local string DisplayRankName; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); Rank = Tuple.Data[0].i; DisplayRankName = Tuple.Data[1].s; // Your code here Tuple.Data[1].s = DisplayRankName; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/DynamicSoldierRankDisplay/#soldiershortrankname-event","text":"Param Value EventID SoldierShortRankName EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"SoldierShortRankName event"},{"location":"strategy/DynamicSoldierRankDisplay/#tuple-contents_1","text":"Index Name Type Direction 0 Rank int in 1 DisplayShortRankName string inout","title":"Tuple contents"},{"location":"strategy/DynamicSoldierRankDisplay/#listener-template_1","text":"static function EventListenerReturn OnSoldierShortRankName(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local int Rank; local string DisplayShortRankName; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); Rank = Tuple.Data[0].i; DisplayShortRankName = Tuple.Data[1].s; // Your code here Tuple.Data[1].s = DisplayShortRankName; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/DynamicSoldierRankDisplay/#soldierrankicon-event","text":"Param Value EventID SoldierRankIcon EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"SoldierRankIcon event"},{"location":"strategy/DynamicSoldierRankDisplay/#tuple-contents_2","text":"Index Name Type Direction 0 Rank int in 1 IconImagePath string inout","title":"Tuple contents"},{"location":"strategy/DynamicSoldierRankDisplay/#listener-template_2","text":"static function EventListenerReturn OnSoldierRankIcon(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local int Rank; local string IconImagePath; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); Rank = Tuple.Data[0].i; IconImagePath = Tuple.Data[1].s; // Your code here Tuple.Data[1].s = IconImagePath; return ELR_NoInterrupt; } There is a sister feature DynamicSoldierClassDisplay that extends this to class icon/name.","title":"Listener template"},{"location":"strategy/DynamicSoldierRankDisplay/#source-code-references","text":"XComGameState_Unit.uc:15680-15708","title":"Source code references"},{"location":"strategy/ExtendHasHeavyWeapon/","text":"ExtendHasHeavyWeapon Tracking Issue: #881 Tags: loadoutslots Extends the ability check in HasHeavyWeapon() for the config array AbilityUnlocksHeavyWeapon ( XComGameData.ini ) to item granted abilities and abilities granted by the character template. Source code references XComGameState_Unit.uc:4238-4240","title":"ExtendHasHeavyWeapon"},{"location":"strategy/ExtendHasHeavyWeapon/#extendhasheavyweapon","text":"Tracking Issue: #881 Tags: loadoutslots Extends the ability check in HasHeavyWeapon() for the config array AbilityUnlocksHeavyWeapon ( XComGameData.ini ) to item granted abilities and abilities granted by the character template.","title":"ExtendHasHeavyWeapon"},{"location":"strategy/ExtendHasHeavyWeapon/#source-code-references","text":"XComGameState_Unit.uc:4238-4240","title":"Source code references"},{"location":"strategy/FirstPromotionOverrideClass/","text":"FirstPromotionOverrideClass Tracking Issue: #801 Tags: events The XComGameState_Unit::RankUpSoldier triggers a FirstPromotionOverrideClass event, allowing mods to override the soldier class template name that will be assigned to this unit, making it possible to set a class for the soldier based on arbitrary conditions. It is necessary to listen to this event using ELD_Immediate deferral in order for your changes to take effect in time. If the RankUpSoldier function was called with a soldier class template name already specified, it means the game wanted to promote this soldier to a specific class (e.g. GTS rookie training, Psi Operative training or Commander's Choice). In that case, you can set up your Event Listener to not have an effect on such a soldier. FirstPromotionOverrideClass event Param Value EventID FirstPromotionOverrideClass EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes Tuple contents Index Name Type Direction 0 SoldierClassTemplateName name inout Listener template static function EventListenerReturn OnFirstPromotionOverrideClass(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit FirstSquaddie; local XComLWTuple Tuple; local name SoldierClassTemplateName; FirstSquaddie = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); SoldierClassTemplateName = Tuple.Data[0].n; // Your code here Tuple.Data[0].n = SoldierClassTemplateName; return ELR_NoInterrupt; } Example of an Event Listener Function: static function EventListenerReturn ListenerEventFunction(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { local XComLWTuple Tuple; local XComGameState_Unit UnitState; Tuple = XComLWTuple(EventData); UnitState = XComGameState_Unit(EventSource); if (Tuple == none || UnitState == none) return ELR_NoInterrupt; // If the game did not want to promote this soldier to a specific soldier class if (Tuple.Data[0].n == '') { // If a soldier rolled high aim thanks to Not Created Equal, they are guaranteed to become a sniper. if (UnitState.GetCurrentStat(eStat_Offense) > 70) { Tuple.Data[0].n = 'Sharpshooter'; } } return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:13558-13597","title":"FirstPromotionOverrideClass"},{"location":"strategy/FirstPromotionOverrideClass/#firstpromotionoverrideclass","text":"Tracking Issue: #801 Tags: events The XComGameState_Unit::RankUpSoldier triggers a FirstPromotionOverrideClass event, allowing mods to override the soldier class template name that will be assigned to this unit, making it possible to set a class for the soldier based on arbitrary conditions. It is necessary to listen to this event using ELD_Immediate deferral in order for your changes to take effect in time. If the RankUpSoldier function was called with a soldier class template name already specified, it means the game wanted to promote this soldier to a specific class (e.g. GTS rookie training, Psi Operative training or Commander's Choice). In that case, you can set up your Event Listener to not have an effect on such a soldier.","title":"FirstPromotionOverrideClass"},{"location":"strategy/FirstPromotionOverrideClass/#firstpromotionoverrideclass-event","text":"Param Value EventID FirstPromotionOverrideClass EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes","title":"FirstPromotionOverrideClass event"},{"location":"strategy/FirstPromotionOverrideClass/#tuple-contents","text":"Index Name Type Direction 0 SoldierClassTemplateName name inout","title":"Tuple contents"},{"location":"strategy/FirstPromotionOverrideClass/#listener-template","text":"static function EventListenerReturn OnFirstPromotionOverrideClass(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit FirstSquaddie; local XComLWTuple Tuple; local name SoldierClassTemplateName; FirstSquaddie = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); SoldierClassTemplateName = Tuple.Data[0].n; // Your code here Tuple.Data[0].n = SoldierClassTemplateName; return ELR_NoInterrupt; } Example of an Event Listener Function: static function EventListenerReturn ListenerEventFunction(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { local XComLWTuple Tuple; local XComGameState_Unit UnitState; Tuple = XComLWTuple(EventData); UnitState = XComGameState_Unit(EventSource); if (Tuple == none || UnitState == none) return ELR_NoInterrupt; // If the game did not want to promote this soldier to a specific soldier class if (Tuple.Data[0].n == '') { // If a soldier rolled high aim thanks to Not Created Equal, they are guaranteed to become a sniper. if (UnitState.GetCurrentStat(eStat_Offense) > 70) { Tuple.Data[0].n = 'Sharpshooter'; } } return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/FirstPromotionOverrideClass/#source-code-references","text":"XComGameState_Unit.uc:13558-13597","title":"Source code references"},{"location":"strategy/Geoscape_ResInfoButtonVisible/","text":"Geoscape_ResInfoButtonVisible Tracking Issue: #365 Tags: ui , events Allows overriding whether the resistance info button should be visible. Default: After the first month if any faction met and not in flight. Geoscape_ResInfoButtonVisible event Param Value EventID Geoscape_ResInfoButtonVisible EventData XComLWTuple EventSource UIStrategyMap_HUD NewGameState none Tuple contents Index Name Type Direction 0 ShouldShow bool inout 1 InFlight bool in Listener template static function EventListenerReturn OnGeoscape_ResInfoButtonVisible(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyMap_HUD HUDScreen; local XComLWTuple Tuple; local bool ShouldShow; local bool InFlight; HUDScreen = UIStrategyMap_HUD(EventSource); Tuple = XComLWTuple(EventData); ShouldShow = Tuple.Data[0].b; InFlight = Tuple.Data[1].b; // Your code here Tuple.Data[0].b = ShouldShow; return ELR_NoInterrupt; } Source code references UIStrategyMap_HUD.uc:285-294","title":"Geoscape_ResInfoButtonVisible"},{"location":"strategy/Geoscape_ResInfoButtonVisible/#geoscape_resinfobuttonvisible","text":"Tracking Issue: #365 Tags: ui , events Allows overriding whether the resistance info button should be visible. Default: After the first month if any faction met and not in flight.","title":"Geoscape_ResInfoButtonVisible"},{"location":"strategy/Geoscape_ResInfoButtonVisible/#geoscape_resinfobuttonvisible-event","text":"Param Value EventID Geoscape_ResInfoButtonVisible EventData XComLWTuple EventSource UIStrategyMap_HUD NewGameState none","title":"Geoscape_ResInfoButtonVisible event"},{"location":"strategy/Geoscape_ResInfoButtonVisible/#tuple-contents","text":"Index Name Type Direction 0 ShouldShow bool inout 1 InFlight bool in","title":"Tuple contents"},{"location":"strategy/Geoscape_ResInfoButtonVisible/#listener-template","text":"static function EventListenerReturn OnGeoscape_ResInfoButtonVisible(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyMap_HUD HUDScreen; local XComLWTuple Tuple; local bool ShouldShow; local bool InFlight; HUDScreen = UIStrategyMap_HUD(EventSource); Tuple = XComLWTuple(EventData); ShouldShow = Tuple.Data[0].b; InFlight = Tuple.Data[1].b; // Your code here Tuple.Data[0].b = ShouldShow; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/Geoscape_ResInfoButtonVisible/#source-code-references","text":"UIStrategyMap_HUD.uc:285-294","title":"Source code references"},{"location":"strategy/GetCovertActionEvents_Settings/","text":"GetCovertActionEvents_Settings Tracking Issue: #391 Tags: ui , events Allows configuring the behavior of covert actions in the event queue. AddAll allows multiple covert actions, InsertSorted inserts them into position based on time remaining. Default: Only one covert action is added at the end. GetCovertActionEvents_Settings event Param Value EventID GetCovertActionEvents_Settings EventData XComLWTuple EventSource XComGameState_HeadquartersXCom NewGameState none Tuple contents Index Name Type Direction 0 AddAll bool out 1 InsertSorted bool out Listener template static function EventListenerReturn OnGetCovertActionEvents_Settings(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_HeadquartersXCom XComHQ; local XComLWTuple Tuple; local bool AddAll; local bool InsertSorted; XComHQ = XComGameState_HeadquartersXCom(EventSource); Tuple = XComLWTuple(EventData); // Your code here Tuple.Data[0].b = AddAll; Tuple.Data[1].b = InsertSorted; return ELR_NoInterrupt; } Source code references XComGameState_HeadquartersXCom.uc:8067-8079","title":"GetCovertActionEvents_Settings"},{"location":"strategy/GetCovertActionEvents_Settings/#getcovertactionevents_settings","text":"Tracking Issue: #391 Tags: ui , events Allows configuring the behavior of covert actions in the event queue. AddAll allows multiple covert actions, InsertSorted inserts them into position based on time remaining. Default: Only one covert action is added at the end.","title":"GetCovertActionEvents_Settings"},{"location":"strategy/GetCovertActionEvents_Settings/#getcovertactionevents_settings-event","text":"Param Value EventID GetCovertActionEvents_Settings EventData XComLWTuple EventSource XComGameState_HeadquartersXCom NewGameState none","title":"GetCovertActionEvents_Settings event"},{"location":"strategy/GetCovertActionEvents_Settings/#tuple-contents","text":"Index Name Type Direction 0 AddAll bool out 1 InsertSorted bool out","title":"Tuple contents"},{"location":"strategy/GetCovertActionEvents_Settings/#listener-template","text":"static function EventListenerReturn OnGetCovertActionEvents_Settings(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_HeadquartersXCom XComHQ; local XComLWTuple Tuple; local bool AddAll; local bool InsertSorted; XComHQ = XComGameState_HeadquartersXCom(EventSource); Tuple = XComLWTuple(EventData); // Your code here Tuple.Data[0].b = AddAll; Tuple.Data[1].b = InsertSorted; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/GetCovertActionEvents_Settings/#source-code-references","text":"XComGameState_HeadquartersXCom.uc:8067-8079","title":"Source code references"},{"location":"strategy/GetNumHeavyWeaponSlotsOverride/","text":"GetNumHeavyWeaponSlotsOverride Tracking Issue: #171 Tags: loadoutslots The GetNumHeavyWeaponSlotsOverride() X2DLCInfo method allows mods to override the base game logic that determines how many Heavy Weapon Slots a Unit has. To do so, simply interact with the NumHeavySlots argument by increasing, decreasing or setting its value directly. Note that this X2DLCInfo method is executed after the OverrideHasHeavyWeapon event, and may override its result. Source code references X2DownloadableContentInfo.uc:430-436","title":"GetNumHeavyWeaponSlotsOverride"},{"location":"strategy/GetNumHeavyWeaponSlotsOverride/#getnumheavyweaponslotsoverride","text":"Tracking Issue: #171 Tags: loadoutslots The GetNumHeavyWeaponSlotsOverride() X2DLCInfo method allows mods to override the base game logic that determines how many Heavy Weapon Slots a Unit has. To do so, simply interact with the NumHeavySlots argument by increasing, decreasing or setting its value directly. Note that this X2DLCInfo method is executed after the OverrideHasHeavyWeapon event, and may override its result.","title":"GetNumHeavyWeaponSlotsOverride"},{"location":"strategy/GetNumHeavyWeaponSlotsOverride/#source-code-references","text":"X2DownloadableContentInfo.uc:430-436","title":"Source code references"},{"location":"strategy/HeadquartersUnitFired/","text":"HeadquartersUnitFired Tracking Issue: #871 Tags: events This event is triggered when an XComGameStateContext_HeadquartersOrder of eHeadquartersOrderType_FireStaff type is submitted. The unit state in question is already removed ( RemoveStateObject ) when the event is triggered. Usually this happens when the player presses \"DISMISS\" in the armory menu. HeadquartersUnitFired event Param Value EventID HeadquartersUnitFired EventData none EventSource XComGameState_Unit NewGameState yes Listener template static function EventListenerReturn OnHeadquartersUnitFired(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit FiredUnit; FiredUnit = XComGameState_Unit(EventSource); // Your code here return ELR_NoInterrupt; } Source code references XComGameStateContext_HeadquartersOrder.uc:337-349","title":"HeadquartersUnitFired"},{"location":"strategy/HeadquartersUnitFired/#headquartersunitfired","text":"Tracking Issue: #871 Tags: events This event is triggered when an XComGameStateContext_HeadquartersOrder of eHeadquartersOrderType_FireStaff type is submitted. The unit state in question is already removed ( RemoveStateObject ) when the event is triggered. Usually this happens when the player presses \"DISMISS\" in the armory menu.","title":"HeadquartersUnitFired"},{"location":"strategy/HeadquartersUnitFired/#headquartersunitfired-event","text":"Param Value EventID HeadquartersUnitFired EventData none EventSource XComGameState_Unit NewGameState yes","title":"HeadquartersUnitFired event"},{"location":"strategy/HeadquartersUnitFired/#listener-template","text":"static function EventListenerReturn OnHeadquartersUnitFired(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit FiredUnit; FiredUnit = XComGameState_Unit(EventSource); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/HeadquartersUnitFired/#source-code-references","text":"XComGameStateContext_HeadquartersOrder.uc:337-349","title":"Source code references"},{"location":"strategy/IsWeaponAllowedByClass/","text":"IsWeaponAllowedByClass Tracking Issue: #1057 Tags: compatibility When the game needs to determine whether a weapon with particular category can be used by a particular soldier class, it calls the IsWeaponAllowedByClass() function, which checks whether the weapon is allowed in the inventory slot specified in the Weapon Template. This is a problem, because there are other Highlander features that allow equipping items in slots other than the one specified in the Weapon Template, such as using secondary weapons as primaries or equipping them into special sidearm slots. To address this issue, this feature introduces a new function: IsWeaponAllowedByClass_CH() , which checks whether the weapon is allowed in the inventory slot given to the function as an argument. Compatibility For the sake of consistency, it is preferable that mods call IsWeaponAllowedByClass_CH() rather than IsWeaponAllowedByClass() whenever possible. GetAllowedClassForWeapon_CH() Similarly to IsWeaponAllowedByClass_CH() , a GetAllowedClassForWeapon_CH() function was created to find a soldier class template of a class that is allowed to use a weapon of the specified template in the specified inventory slot, rather than in the slot specified in the weapon template itself. Compatibility For the sake of consistency, it is preferable that mods call GetAllowedClassForWeapon_CH() rather than GetAllowedClassForWeapon() whenever possible. Source code references X2SoldierClassTemplate.uc:151-165 UIUtilities_Strategy.uc:1363-1373","title":"IsWeaponAllowedByClass"},{"location":"strategy/IsWeaponAllowedByClass/#isweaponallowedbyclass","text":"Tracking Issue: #1057 Tags: compatibility When the game needs to determine whether a weapon with particular category can be used by a particular soldier class, it calls the IsWeaponAllowedByClass() function, which checks whether the weapon is allowed in the inventory slot specified in the Weapon Template. This is a problem, because there are other Highlander features that allow equipping items in slots other than the one specified in the Weapon Template, such as using secondary weapons as primaries or equipping them into special sidearm slots. To address this issue, this feature introduces a new function: IsWeaponAllowedByClass_CH() , which checks whether the weapon is allowed in the inventory slot given to the function as an argument.","title":"IsWeaponAllowedByClass"},{"location":"strategy/IsWeaponAllowedByClass/#compatibility","text":"For the sake of consistency, it is preferable that mods call IsWeaponAllowedByClass_CH() rather than IsWeaponAllowedByClass() whenever possible.","title":"Compatibility"},{"location":"strategy/IsWeaponAllowedByClass/#getallowedclassforweapon_ch","text":"Similarly to IsWeaponAllowedByClass_CH() , a GetAllowedClassForWeapon_CH() function was created to find a soldier class template of a class that is allowed to use a weapon of the specified template in the specified inventory slot, rather than in the slot specified in the weapon template itself.","title":"GetAllowedClassForWeapon_CH()"},{"location":"strategy/IsWeaponAllowedByClass/#compatibility_1","text":"For the sake of consistency, it is preferable that mods call GetAllowedClassForWeapon_CH() rather than GetAllowedClassForWeapon() whenever possible.","title":"Compatibility"},{"location":"strategy/IsWeaponAllowedByClass/#source-code-references","text":"X2SoldierClassTemplate.uc:151-165 UIUtilities_Strategy.uc:1363-1373","title":"Source code references"},{"location":"strategy/ItemUpgraded/","text":"ItemUpgraded Tracking Issue: #289 Tags: events This is an event that allows mods to perform non-standard handling to item states when they are upgraded to a new tier. It is fired up to four times during upgrading: * When upgrading the infinite item, if any. * When upgrading utility items, like grenades and medkits. * When upgrading unequipped items that have attachments * When upgrading equipped items that have attachments Note: EventSource (BaseItem) will be none when the event is triggered by upgrading an infinite item. This is because infinite items are created rather than upgraded. ItemUpgraded event Param Value EventID ItemUpgraded EventData XComGameState_Item EventSource XComGameState_Item NewGameState yes Listener template static function EventListenerReturn OnItemUpgraded(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Item BaseItem; local XComGameState_Item UpgradedItem; BaseItem = XComGameState_Item(EventSource); UpgradedItem = XComGameState_Item(EventData); // Your code here return ELR_NoInterrupt; } Source code references XComGameState_HeadquartersXCom.uc:4698-4713","title":"ItemUpgraded"},{"location":"strategy/ItemUpgraded/#itemupgraded","text":"Tracking Issue: #289 Tags: events This is an event that allows mods to perform non-standard handling to item states when they are upgraded to a new tier. It is fired up to four times during upgrading: * When upgrading the infinite item, if any. * When upgrading utility items, like grenades and medkits. * When upgrading unequipped items that have attachments * When upgrading equipped items that have attachments Note: EventSource (BaseItem) will be none when the event is triggered by upgrading an infinite item. This is because infinite items are created rather than upgraded.","title":"ItemUpgraded"},{"location":"strategy/ItemUpgraded/#itemupgraded-event","text":"Param Value EventID ItemUpgraded EventData XComGameState_Item EventSource XComGameState_Item NewGameState yes","title":"ItemUpgraded event"},{"location":"strategy/ItemUpgraded/#listener-template","text":"static function EventListenerReturn OnItemUpgraded(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Item BaseItem; local XComGameState_Item UpgradedItem; BaseItem = XComGameState_Item(EventSource); UpgradedItem = XComGameState_Item(EventData); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/ItemUpgraded/#source-code-references","text":"XComGameState_HeadquartersXCom.uc:4698-4713","title":"Source code references"},{"location":"strategy/ModifyStrategyStartState/","text":"ModifyStrategyStartState Tracking Issue: #1425 Called just before transferring from tactical to strategy. Allows mods to modify the strategy start state. Source code references X2DownloadableContentInfo.uc:255-257","title":"ModifyStrategyStartState"},{"location":"strategy/ModifyStrategyStartState/#modifystrategystartstate","text":"Tracking Issue: #1425 Called just before transferring from tactical to strategy. Allows mods to modify the strategy start state.","title":"ModifyStrategyStartState"},{"location":"strategy/ModifyStrategyStartState/#source-code-references","text":"X2DownloadableContentInfo.uc:255-257","title":"Source code references"},{"location":"strategy/NonIntegratedAlienRulerLocations/","text":"NonIntegratedAlienRulerLocations Tracking Issue: #771 Tags: dlc2 Mods can force a specific ruler to be present on a specific mission using XComGameState_AlienRulerManager::AlienRulerLocations - the same mechanism that XPACK integration uses/introduces to make rulers wait in specific alien facilities. This could be done even without the CHL patch, but it wouldn't work if DLC is not run in the integrated mode. With this CHL patch, you can use that mechanism safely in both integrated and non-integrated mode. Note that when the non-integrated mode is enabled, the AlienRulerLocations array is not populated by the DLC. Example usage: local XComGameState_AlienRulerManager RulerManager; local AlienRulerLocation RulerLocation; RulerLocation.RulerRef = RulerManager.GetAlienRulerReference('ViperKing'); RulerLocation.MissionRef = MissionRef; RulerLocation.bActivated = true; RulerLocation.bNeedsPopup = false; RulerManager.AlienRulerLocations.AddItem(RulerLocation); Source code references XComGameState_AlienRulerManager.uc:747-766","title":"NonIntegratedAlienRulerLocations"},{"location":"strategy/NonIntegratedAlienRulerLocations/#nonintegratedalienrulerlocations","text":"Tracking Issue: #771 Tags: dlc2 Mods can force a specific ruler to be present on a specific mission using XComGameState_AlienRulerManager::AlienRulerLocations - the same mechanism that XPACK integration uses/introduces to make rulers wait in specific alien facilities. This could be done even without the CHL patch, but it wouldn't work if DLC is not run in the integrated mode. With this CHL patch, you can use that mechanism safely in both integrated and non-integrated mode. Note that when the non-integrated mode is enabled, the AlienRulerLocations array is not populated by the DLC. Example usage: local XComGameState_AlienRulerManager RulerManager; local AlienRulerLocation RulerLocation; RulerLocation.RulerRef = RulerManager.GetAlienRulerReference('ViperKing'); RulerLocation.MissionRef = MissionRef; RulerLocation.bActivated = true; RulerLocation.bNeedsPopup = false; RulerManager.AlienRulerLocations.AddItem(RulerLocation);","title":"NonIntegratedAlienRulerLocations"},{"location":"strategy/NonIntegratedAlienRulerLocations/#source-code-references","text":"XComGameState_AlienRulerManager.uc:747-766","title":"Source code references"},{"location":"strategy/NonWeaponUpgradeSlots/","text":"NonWeaponUpgradeSlots Tracking Issue: #93 Mods can add upgrade slots to items that are not based on X2WeaponTemplate by adding entries to NonWeaponUpgradeSlots config array in XComGame.ini , for example: [XComGame.CHHelpers] +NonWeaponUpgradeSlots = (TemplateName = \"KevlarArmor\", NumUpgradeSlots = 1) +NonWeaponUpgradeSlots = (TemplateName = \"PlatedArmor\", NumUpgradeSlots = 2) +NonWeaponUpgradeSlots = (TemplateName = \"PoweredArmor\", NumUpgradeSlots = 3) Note that if several mods add config entries for the same item template, only the first one one will take effect. Which one counts as first will depend on the config load order. Source code references X2ItemTemplate.uc:396-406","title":"NonWeaponUpgradeSlots"},{"location":"strategy/NonWeaponUpgradeSlots/#nonweaponupgradeslots","text":"Tracking Issue: #93 Mods can add upgrade slots to items that are not based on X2WeaponTemplate by adding entries to NonWeaponUpgradeSlots config array in XComGame.ini , for example: [XComGame.CHHelpers] +NonWeaponUpgradeSlots = (TemplateName = \"KevlarArmor\", NumUpgradeSlots = 1) +NonWeaponUpgradeSlots = (TemplateName = \"PlatedArmor\", NumUpgradeSlots = 2) +NonWeaponUpgradeSlots = (TemplateName = \"PoweredArmor\", NumUpgradeSlots = 3) Note that if several mods add config entries for the same item template, only the first one one will take effect. Which one counts as first will depend on the config load order.","title":"NonWeaponUpgradeSlots"},{"location":"strategy/NonWeaponUpgradeSlots/#source-code-references","text":"X2ItemTemplate.uc:396-406","title":"Source code references"},{"location":"strategy/OnBestGearLoadoutApplied/","text":"OnBestGearLoadoutApplied Tracking Issue: #676 Tags: events The XComGameState_Unit::ApplyBestGearLoadout does not perform CanAddItemToInventory checks when it picks the best gear for the soldier, so if one of the selected items by that function cannot be equipped due to an override in CanAddItemToInventory_CH, the inventory slot will remain empty. This event passes along the Unit State whenever this function is called, so the mods can use their arbitrary conditions to decide what is the actual best gear loadout is for a unit. OnBestGearLoadoutApplied event Param Value EventID OnBestGearLoadoutApplied EventData XComGameState_Unit EventSource XComGameState_Unit NewGameState yes Listener template static function EventListenerReturn OnOnBestGearLoadoutApplied(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; UnitState = XComGameState_Unit(EventData); // Your code here return ELR_NoInterrupt; } // This EventFn requires the Event Listener to use an ELD_Immediate deferral. static function EventListenerReturn OnBestGearLoadoutApplied_Listener(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { local XComGameState_Unit UnitState; // This gets you Unit State from History. UnitState = XComGameState_Unit(EventData); // Here you can *read* the Unit State. // Get the Unit State from the pending New Game State. UnitState = XComGameState_Unit(NewGameState.GetGameStateForObjectID(UnitState.ObjectID)); // Now you can make changes to the Unit State, such as changing its equipment based on arbitrary conditions. } Source code references XComGameState_Unit.uc:11886-11915","title":"OnBestGearLoadoutApplied"},{"location":"strategy/OnBestGearLoadoutApplied/#onbestgearloadoutapplied","text":"Tracking Issue: #676 Tags: events The XComGameState_Unit::ApplyBestGearLoadout does not perform CanAddItemToInventory checks when it picks the best gear for the soldier, so if one of the selected items by that function cannot be equipped due to an override in CanAddItemToInventory_CH, the inventory slot will remain empty. This event passes along the Unit State whenever this function is called, so the mods can use their arbitrary conditions to decide what is the actual best gear loadout is for a unit.","title":"OnBestGearLoadoutApplied"},{"location":"strategy/OnBestGearLoadoutApplied/#onbestgearloadoutapplied-event","text":"Param Value EventID OnBestGearLoadoutApplied EventData XComGameState_Unit EventSource XComGameState_Unit NewGameState yes","title":"OnBestGearLoadoutApplied event"},{"location":"strategy/OnBestGearLoadoutApplied/#listener-template","text":"static function EventListenerReturn OnOnBestGearLoadoutApplied(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; UnitState = XComGameState_Unit(EventData); // Your code here return ELR_NoInterrupt; } // This EventFn requires the Event Listener to use an ELD_Immediate deferral. static function EventListenerReturn OnBestGearLoadoutApplied_Listener(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { local XComGameState_Unit UnitState; // This gets you Unit State from History. UnitState = XComGameState_Unit(EventData); // Here you can *read* the Unit State. // Get the Unit State from the pending New Game State. UnitState = XComGameState_Unit(NewGameState.GetGameStateForObjectID(UnitState.ObjectID)); // Now you can make changes to the Unit State, such as changing its equipment based on arbitrary conditions. }","title":"Listener template"},{"location":"strategy/OnBestGearLoadoutApplied/#source-code-references","text":"XComGameState_Unit.uc:11886-11915","title":"Source code references"},{"location":"strategy/OnGetPCSImage/","text":"OnGetPCSImage Tracking Issue: #110 Tags: ui , events Allows overriding the UI image for a PCS. The base game switches on the stat being boosted, which precludes custom PCS from having a custom icon. Note that for historical reasons, the tuple ID is GetPCSImageTuple while the event ID is OnGetPCSImage . OnGetPCSImage event Param Value EventID OnGetPCSImage EventData XComLWTuple EventSource none NewGameState none Tuple contents Index Name Type Direction 0 ItemState XComGameState_Item in 1 ImagePath string out Listener template static function EventListenerReturn OnOnGetPCSImage(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local XComGameState_Item ItemState; local string ImagePath; Tuple = XComLWTuple(EventData); ItemState = XComGameState_Item(Tuple.Data[0].o); // Your code here Tuple.Data[1].s = ImagePath; return ELR_NoInterrupt; } Source code references UIUtilities_Image.uc:841-852","title":"OnGetPCSImage"},{"location":"strategy/OnGetPCSImage/#ongetpcsimage","text":"Tracking Issue: #110 Tags: ui , events Allows overriding the UI image for a PCS. The base game switches on the stat being boosted, which precludes custom PCS from having a custom icon. Note that for historical reasons, the tuple ID is GetPCSImageTuple while the event ID is OnGetPCSImage .","title":"OnGetPCSImage"},{"location":"strategy/OnGetPCSImage/#ongetpcsimage-event","text":"Param Value EventID OnGetPCSImage EventData XComLWTuple EventSource none NewGameState none","title":"OnGetPCSImage event"},{"location":"strategy/OnGetPCSImage/#tuple-contents","text":"Index Name Type Direction 0 ItemState XComGameState_Item in 1 ImagePath string out","title":"Tuple contents"},{"location":"strategy/OnGetPCSImage/#listener-template","text":"static function EventListenerReturn OnOnGetPCSImage(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local XComGameState_Item ItemState; local string ImagePath; Tuple = XComLWTuple(EventData); ItemState = XComGameState_Item(Tuple.Data[0].o); // Your code here Tuple.Data[1].s = ImagePath; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OnGetPCSImage/#source-code-references","text":"UIUtilities_Image.uc:841-852","title":"Source code references"},{"location":"strategy/OverrideAllowStartingRegionLink/","text":"OverrideAllowStartingRegionLink Tracking Issue: #774 Tags: events This event allows mods to override the default behavior for whether a region can be linked to a potential starting region. The default behavior is that the two regions must be in the same continent if they are to be linked. To override that behavior, add a listener that has RegisterInCampaignStart set to true and within the listener function simply change the value of the AllowLink field in the given tuple data. For example, you could always set it to true to remove the constraints completely, so that a starting region can be linked to any neighboring region. This event is triggered during a start state, which you can access via XComGameStateHistory:GetStartState() . OverrideAllowStartingRegionLink event Param Value EventID OverrideAllowStartingRegionLink EventData XComLWTuple EventSource XComGameState_WorldRegion NewGameState none Tuple contents Index Name Type Direction 0 LinkedRegion XComGameState_WorldRegion in 1 AllowLink bool inout Listener template static function EventListenerReturn OnOverrideAllowStartingRegionLink(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_WorldRegion PotentialStartRegion; local XComLWTuple Tuple; local XComGameState_WorldRegion LinkedRegion; local bool AllowLink; PotentialStartRegion = XComGameState_WorldRegion(EventSource); Tuple = XComLWTuple(EventData); LinkedRegion = XComGameState_WorldRegion(Tuple.Data[0].o); AllowLink = Tuple.Data[1].b; // Your code here Tuple.Data[1].b = AllowLink; return ELR_NoInterrupt; } Source code references XComGameState_RegionLink.uc:305-324","title":"OverrideAllowStartingRegionLink"},{"location":"strategy/OverrideAllowStartingRegionLink/#overrideallowstartingregionlink","text":"Tracking Issue: #774 Tags: events This event allows mods to override the default behavior for whether a region can be linked to a potential starting region. The default behavior is that the two regions must be in the same continent if they are to be linked. To override that behavior, add a listener that has RegisterInCampaignStart set to true and within the listener function simply change the value of the AllowLink field in the given tuple data. For example, you could always set it to true to remove the constraints completely, so that a starting region can be linked to any neighboring region. This event is triggered during a start state, which you can access via XComGameStateHistory:GetStartState() .","title":"OverrideAllowStartingRegionLink"},{"location":"strategy/OverrideAllowStartingRegionLink/#overrideallowstartingregionlink-event","text":"Param Value EventID OverrideAllowStartingRegionLink EventData XComLWTuple EventSource XComGameState_WorldRegion NewGameState none","title":"OverrideAllowStartingRegionLink event"},{"location":"strategy/OverrideAllowStartingRegionLink/#tuple-contents","text":"Index Name Type Direction 0 LinkedRegion XComGameState_WorldRegion in 1 AllowLink bool inout","title":"Tuple contents"},{"location":"strategy/OverrideAllowStartingRegionLink/#listener-template","text":"static function EventListenerReturn OnOverrideAllowStartingRegionLink(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_WorldRegion PotentialStartRegion; local XComLWTuple Tuple; local XComGameState_WorldRegion LinkedRegion; local bool AllowLink; PotentialStartRegion = XComGameState_WorldRegion(EventSource); Tuple = XComLWTuple(EventData); LinkedRegion = XComGameState_WorldRegion(Tuple.Data[0].o); AllowLink = Tuple.Data[1].b; // Your code here Tuple.Data[1].b = AllowLink; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideAllowStartingRegionLink/#source-code-references","text":"XComGameState_RegionLink.uc:305-324","title":"Source code references"},{"location":"strategy/OverrideCanEquipImplant/","text":"OverrideCanEquipImplant Tracking Issue: #1094 Tags: events In the original CanEquipImplant function, an implant (PCS) can only be equipped if: The unit has no PCS equipped OR The type of the first stat on the new PCS is different from the one on the equipped PCS OR The value of the first stat on the new PCS is higher than on the equipped PCS Additionally, if the type of the first stat on the new PCS is Psi, the unit must be a Psi Operative The OverrideCanEquipImplant event allows mods to override above behaviour with arbitrary logic. OverrideCanEquipImplant event Param Value EventID OverrideCanEquipImplant EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 CanEquipImplant bool inout 1 Implant XComGameState_Item in Listener template static function EventListenerReturn OnOverrideCanEquipImplant(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool CanEquipImplant; local XComGameState_Item Implant; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); CanEquipImplant = Tuple.Data[0].b; Implant = XComGameState_Item(Tuple.Data[1].o); // Your code here Tuple.Data[0].b = CanEquipImplant; return ELR_NoInterrupt; } Source code references UIInventory_Implants.uc:113-128","title":"OverrideCanEquipImplant"},{"location":"strategy/OverrideCanEquipImplant/#overridecanequipimplant","text":"Tracking Issue: #1094 Tags: events In the original CanEquipImplant function, an implant (PCS) can only be equipped if: The unit has no PCS equipped OR The type of the first stat on the new PCS is different from the one on the equipped PCS OR The value of the first stat on the new PCS is higher than on the equipped PCS Additionally, if the type of the first stat on the new PCS is Psi, the unit must be a Psi Operative The OverrideCanEquipImplant event allows mods to override above behaviour with arbitrary logic.","title":"OverrideCanEquipImplant"},{"location":"strategy/OverrideCanEquipImplant/#overridecanequipimplant-event","text":"Param Value EventID OverrideCanEquipImplant EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"OverrideCanEquipImplant event"},{"location":"strategy/OverrideCanEquipImplant/#tuple-contents","text":"Index Name Type Direction 0 CanEquipImplant bool inout 1 Implant XComGameState_Item in","title":"Tuple contents"},{"location":"strategy/OverrideCanEquipImplant/#listener-template","text":"static function EventListenerReturn OnOverrideCanEquipImplant(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool CanEquipImplant; local XComGameState_Item Implant; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); CanEquipImplant = Tuple.Data[0].b; Implant = XComGameState_Item(Tuple.Data[1].o); // Your code here Tuple.Data[0].b = CanEquipImplant; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideCanEquipImplant/#source-code-references","text":"UIInventory_Implants.uc:113-128","title":"Source code references"},{"location":"strategy/OverrideCanTakeFacilityMission/","text":"OverrideCanTakeFacilityMission Tracking Issue: #875 Tags: events , ui EventID: OverrideCanTakeFacilityMission EventData: XComLWTuple { Data: [ inout bool CanTakeMission, in UIMission_AlienFacility (self) ] } EventSource: XComGameState_MissionSite NewGameState: no Source code references UIMission_AlienFacility.uc:242-253","title":"OverrideCanTakeFacilityMission"},{"location":"strategy/OverrideCanTakeFacilityMission/#overridecantakefacilitymission","text":"Tracking Issue: #875 Tags: events , ui EventID: OverrideCanTakeFacilityMission EventData: XComLWTuple { Data: [ inout bool CanTakeMission, in UIMission_AlienFacility (self) ] } EventSource: XComGameState_MissionSite NewGameState: no","title":"OverrideCanTakeFacilityMission"},{"location":"strategy/OverrideCanTakeFacilityMission/#source-code-references","text":"UIMission_AlienFacility.uc:242-253","title":"Source code references"},{"location":"strategy/OverrideDarkEventCount/","text":"OverrideDarkEventCount Tracking Issue: #711 Tags: events Triggers the event OverrideDarkEventCount to allow mods to change the number of dark events in the monthly report. OverrideDarkEventCount event Param Value EventID OverrideDarkEventCount EventData XComLWTuple EventSource XComGameState_HeadquartersAlien NewGameState yes Tuple contents Index Name Type Direction 0 NumEvents int inout 1 bChosenAddedEvent bool inout Listener template static function EventListenerReturn OnOverrideDarkEventCount(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_HeadquartersAlien AlienHQ; local XComLWTuple Tuple; local int NumEvents; local bool bChosenAddedEvent; AlienHQ = XComGameState_HeadquartersAlien(EventSource); Tuple = XComLWTuple(EventData); NumEvents = Tuple.Data[0].i; bChosenAddedEvent = Tuple.Data[1].b; // Your code here Tuple.Data[0].i = NumEvents; Tuple.Data[1].b = bChosenAddedEvent; return ELR_NoInterrupt; } Source code references XComGameState_HeadquartersAlien.uc:1794-1806","title":"OverrideDarkEventCount"},{"location":"strategy/OverrideDarkEventCount/#overridedarkeventcount","text":"Tracking Issue: #711 Tags: events Triggers the event OverrideDarkEventCount to allow mods to change the number of dark events in the monthly report.","title":"OverrideDarkEventCount"},{"location":"strategy/OverrideDarkEventCount/#overridedarkeventcount-event","text":"Param Value EventID OverrideDarkEventCount EventData XComLWTuple EventSource XComGameState_HeadquartersAlien NewGameState yes","title":"OverrideDarkEventCount event"},{"location":"strategy/OverrideDarkEventCount/#tuple-contents","text":"Index Name Type Direction 0 NumEvents int inout 1 bChosenAddedEvent bool inout","title":"Tuple contents"},{"location":"strategy/OverrideDarkEventCount/#listener-template","text":"static function EventListenerReturn OnOverrideDarkEventCount(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_HeadquartersAlien AlienHQ; local XComLWTuple Tuple; local int NumEvents; local bool bChosenAddedEvent; AlienHQ = XComGameState_HeadquartersAlien(EventSource); Tuple = XComLWTuple(EventData); NumEvents = Tuple.Data[0].i; bChosenAddedEvent = Tuple.Data[1].b; // Your code here Tuple.Data[0].i = NumEvents; Tuple.Data[1].b = bChosenAddedEvent; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideDarkEventCount/#source-code-references","text":"XComGameState_HeadquartersAlien.uc:1794-1806","title":"Source code references"},{"location":"strategy/OverrideEligibleStartingRegion/","text":"OverrideEligibleStartingRegion Tracking Issue: #1303 Tags: events This Event allows mods to override the default behavior for whether a region is allowed to be the starting region. The default behavior is that a region is eligible to be the starting region if it has at least two links to regions on the same continent as itself. To override that behavior, add a listener that has RegisterInCampaignStart set to true and within the listener function simply change the value of the ValidStartRegion field in the given tuple data. For example, you could always set it to true to remove the constraints completely, so that any region is a valid starting region. This event is triggered during a start state, which you can access via XComGameStateHistory:GetStartState() . OverrideEligibleStartingRegion event Param Value EventID OverrideEligibleStartingRegion EventData XComLWTuple EventSource XComGameState_WorldRegion NewGameState none Tuple contents Index Name Type Direction 0 ValidStartRegion bool inout Listener template static function EventListenerReturn OnOverrideEligibleStartingRegion(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_WorldRegion PotentialStartRegion; local XComLWTuple Tuple; local bool ValidStartRegion; PotentialStartRegion = XComGameState_WorldRegion(EventSource); Tuple = XComLWTuple(EventData); ValidStartRegion = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = ValidStartRegion; return ELR_NoInterrupt; } Source code references XComGameState_RegionLink.uc:259-279","title":"OverrideEligibleStartingRegion"},{"location":"strategy/OverrideEligibleStartingRegion/#overrideeligiblestartingregion","text":"Tracking Issue: #1303 Tags: events This Event allows mods to override the default behavior for whether a region is allowed to be the starting region. The default behavior is that a region is eligible to be the starting region if it has at least two links to regions on the same continent as itself. To override that behavior, add a listener that has RegisterInCampaignStart set to true and within the listener function simply change the value of the ValidStartRegion field in the given tuple data. For example, you could always set it to true to remove the constraints completely, so that any region is a valid starting region. This event is triggered during a start state, which you can access via XComGameStateHistory:GetStartState() .","title":"OverrideEligibleStartingRegion"},{"location":"strategy/OverrideEligibleStartingRegion/#overrideeligiblestartingregion-event","text":"Param Value EventID OverrideEligibleStartingRegion EventData XComLWTuple EventSource XComGameState_WorldRegion NewGameState none","title":"OverrideEligibleStartingRegion event"},{"location":"strategy/OverrideEligibleStartingRegion/#tuple-contents","text":"Index Name Type Direction 0 ValidStartRegion bool inout","title":"Tuple contents"},{"location":"strategy/OverrideEligibleStartingRegion/#listener-template","text":"static function EventListenerReturn OnOverrideEligibleStartingRegion(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_WorldRegion PotentialStartRegion; local XComLWTuple Tuple; local bool ValidStartRegion; PotentialStartRegion = XComGameState_WorldRegion(EventSource); Tuple = XComLWTuple(EventData); ValidStartRegion = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = ValidStartRegion; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideEligibleStartingRegion/#source-code-references","text":"XComGameState_RegionLink.uc:259-279","title":"Source code references"},{"location":"strategy/OverrideEligibleTrainingCenterAbilities/","text":"OverrideEligibleTrainingCenterAbilities Tracking Issue: #815 Tags: events The OverrideEligibleTrainingCenterAbilities event allows mods to make arbitrary changes to the list of eligible Training Center abilities generated for each unit. Typical use case would be making specific abilities eligible or inelegible based on arbitrary conditions, like soldier class weapon restrictions. This event does not trigger for soldiers that do not have a \"true\" XCOM row, like Faction Heroes that use custom RandomAbilityDecks instead. Since sending an SoldierClassAbilityType struct with the tuple is impossible, the event tuple contains three parallel arrays: with ability template names, their inventory slots and their utility categories for abilities assigned to utility items. When modifying these arrays it is absolutely critical that the arrays remain parallel, or you will end up breaking the list. To prevent that, it's highly recommended you take advantage of two helper functions: RebuildSoldierClassAbilityTypeArray and SplitSoldierClassAbilityTypeArray . For example: static function EventListenerReturn OnOverrideEligibleTrainingCenterAbilities(Object EventData, Object EventSource, XComGameState NewGameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local array<name> AbilityNames; local array<int> ApplyToWeaponSlots; local array<name> UtilityCats; local array<SoldierClassAbilityType> EligibleAbilities; Tuple = XComLWTuple(EventData); UnitState = XComGameState_Unit(EventSource); // Rebuild the EligibleAbilities array from the Tuple. AbilityNames = Tuple.Data[0].an; ApplyToWeaponSlots = Tuple.Data[1].ai; UtilityCats = Tuple.Data[2].an; EligibleAbilities = class'CHHelpers'.static.RebuildSoldierClassAbilityTypeArray(AbilityNames, ApplyToWeaponSlots, UtilityCats); // Your code here: modify EligibleAbilities as you please. // Split the modified EligibleAbilities into parallel arrays and pass it back to the Tuple. // This function will automaticaly wipe the contents of the 'out' arrays. class'CHHelpers'.static.SplitSoldierClassAbilityTypeArray(EligibleAbilities, AbilityNames, ApplyToWeaponSlots, UtilityCats); Tuple.Data[0].an = AbilityNames; Tuple.Data[1].ai = ApplyToWeaponSlots; Tuple.Data[2].an = UtilityCats; return ELR_NoInterrupt; } OverrideEligibleTrainingCenterAbilities event Param Value EventID OverrideEligibleTrainingCenterAbilities EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes Tuple contents Index Name Type Direction 0 AbilityNames array<name> inout 1 ApplyToWeaponSlots array<int> inout 2 UtilityCats array<name> inout Source code references XComGameState_Unit.uc:3741-3796","title":"OverrideEligibleTrainingCenterAbilities"},{"location":"strategy/OverrideEligibleTrainingCenterAbilities/#overrideeligibletrainingcenterabilities","text":"Tracking Issue: #815 Tags: events The OverrideEligibleTrainingCenterAbilities event allows mods to make arbitrary changes to the list of eligible Training Center abilities generated for each unit. Typical use case would be making specific abilities eligible or inelegible based on arbitrary conditions, like soldier class weapon restrictions. This event does not trigger for soldiers that do not have a \"true\" XCOM row, like Faction Heroes that use custom RandomAbilityDecks instead. Since sending an SoldierClassAbilityType struct with the tuple is impossible, the event tuple contains three parallel arrays: with ability template names, their inventory slots and their utility categories for abilities assigned to utility items. When modifying these arrays it is absolutely critical that the arrays remain parallel, or you will end up breaking the list. To prevent that, it's highly recommended you take advantage of two helper functions: RebuildSoldierClassAbilityTypeArray and SplitSoldierClassAbilityTypeArray . For example: static function EventListenerReturn OnOverrideEligibleTrainingCenterAbilities(Object EventData, Object EventSource, XComGameState NewGameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local array<name> AbilityNames; local array<int> ApplyToWeaponSlots; local array<name> UtilityCats; local array<SoldierClassAbilityType> EligibleAbilities; Tuple = XComLWTuple(EventData); UnitState = XComGameState_Unit(EventSource); // Rebuild the EligibleAbilities array from the Tuple. AbilityNames = Tuple.Data[0].an; ApplyToWeaponSlots = Tuple.Data[1].ai; UtilityCats = Tuple.Data[2].an; EligibleAbilities = class'CHHelpers'.static.RebuildSoldierClassAbilityTypeArray(AbilityNames, ApplyToWeaponSlots, UtilityCats); // Your code here: modify EligibleAbilities as you please. // Split the modified EligibleAbilities into parallel arrays and pass it back to the Tuple. // This function will automaticaly wipe the contents of the 'out' arrays. class'CHHelpers'.static.SplitSoldierClassAbilityTypeArray(EligibleAbilities, AbilityNames, ApplyToWeaponSlots, UtilityCats); Tuple.Data[0].an = AbilityNames; Tuple.Data[1].ai = ApplyToWeaponSlots; Tuple.Data[2].an = UtilityCats; return ELR_NoInterrupt; }","title":"OverrideEligibleTrainingCenterAbilities"},{"location":"strategy/OverrideEligibleTrainingCenterAbilities/#overrideeligibletrainingcenterabilities-event","text":"Param Value EventID OverrideEligibleTrainingCenterAbilities EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes","title":"OverrideEligibleTrainingCenterAbilities event"},{"location":"strategy/OverrideEligibleTrainingCenterAbilities/#tuple-contents","text":"Index Name Type Direction 0 AbilityNames array<name> inout 1 ApplyToWeaponSlots array<int> inout 2 UtilityCats array<name> inout","title":"Tuple contents"},{"location":"strategy/OverrideEligibleTrainingCenterAbilities/#source-code-references","text":"XComGameState_Unit.uc:3741-3796","title":"Source code references"},{"location":"strategy/OverrideHasAmmoPocket/","text":"OverrideHasAmmoPocket Tracking Issue: #735 Tags: loadoutslots , events Extends the ability check in HasAmmoPocket() for the config array AbilityUnlocksAmmoPocket ( XComGameData.ini ) to item granted abilities and abilities granted by the character template. Finally the event OverrideHasAmmoPocket is triggered that allows mods to override the final result OverrideHasAmmoPocket event Param Value EventID OverrideHasAmmoPocket EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 bHasAmmoPocket bool inout Listener template static function EventListenerReturn OnOverrideHasAmmoPocket(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool bHasAmmoPocket; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bHasAmmoPocket = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bHasAmmoPocket; return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:4110-4120","title":"OverrideHasAmmoPocket"},{"location":"strategy/OverrideHasAmmoPocket/#overridehasammopocket","text":"Tracking Issue: #735 Tags: loadoutslots , events Extends the ability check in HasAmmoPocket() for the config array AbilityUnlocksAmmoPocket ( XComGameData.ini ) to item granted abilities and abilities granted by the character template. Finally the event OverrideHasAmmoPocket is triggered that allows mods to override the final result","title":"OverrideHasAmmoPocket"},{"location":"strategy/OverrideHasAmmoPocket/#overridehasammopocket-event","text":"Param Value EventID OverrideHasAmmoPocket EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"OverrideHasAmmoPocket event"},{"location":"strategy/OverrideHasAmmoPocket/#tuple-contents","text":"Index Name Type Direction 0 bHasAmmoPocket bool inout","title":"Tuple contents"},{"location":"strategy/OverrideHasAmmoPocket/#listener-template","text":"static function EventListenerReturn OnOverrideHasAmmoPocket(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool bHasAmmoPocket; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bHasAmmoPocket = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bHasAmmoPocket; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideHasAmmoPocket/#source-code-references","text":"XComGameState_Unit.uc:4110-4120","title":"Source code references"},{"location":"strategy/OverrideHasExtraUtilitySlot/","text":"OverrideHasExtraUtilitySlot Tracking Issue: #735 Tags: loadoutslots , events Extends the ability check in HasExtraUtilitySlot() for the config array AbilityUnlocksExtraUtilitySlot ( XComGameData.ini ) to item granted abilities and abilities granted by the character template. Finally the event OverrideHasExtraUtilitySlot is triggered that allows mods to override the final result OverrideHasExtraUtilitySlot event Param Value EventID OverrideHasExtraUtilitySlot EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 bHasExtraUtilitySlot bool inout Listener template static function EventListenerReturn OnOverrideHasExtraUtilitySlot(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool bHasExtraUtilitySlot; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bHasExtraUtilitySlot = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bHasExtraUtilitySlot; return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:4135-4145","title":"OverrideHasExtraUtilitySlot"},{"location":"strategy/OverrideHasExtraUtilitySlot/#overridehasextrautilityslot","text":"Tracking Issue: #735 Tags: loadoutslots , events Extends the ability check in HasExtraUtilitySlot() for the config array AbilityUnlocksExtraUtilitySlot ( XComGameData.ini ) to item granted abilities and abilities granted by the character template. Finally the event OverrideHasExtraUtilitySlot is triggered that allows mods to override the final result","title":"OverrideHasExtraUtilitySlot"},{"location":"strategy/OverrideHasExtraUtilitySlot/#overridehasextrautilityslot-event","text":"Param Value EventID OverrideHasExtraUtilitySlot EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"OverrideHasExtraUtilitySlot event"},{"location":"strategy/OverrideHasExtraUtilitySlot/#tuple-contents","text":"Index Name Type Direction 0 bHasExtraUtilitySlot bool inout","title":"Tuple contents"},{"location":"strategy/OverrideHasExtraUtilitySlot/#listener-template","text":"static function EventListenerReturn OnOverrideHasExtraUtilitySlot(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool bHasExtraUtilitySlot; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bHasExtraUtilitySlot = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bHasExtraUtilitySlot; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideHasExtraUtilitySlot/#source-code-references","text":"XComGameState_Unit.uc:4135-4145","title":"Source code references"},{"location":"strategy/OverrideHasGrenadePocket/","text":"OverrideHasGrenadePocket Tracking Issue: #735 Tags: loadoutslots , events Extends the ability check in HasGrenadePocket() for the config array AbilityUnlocksGrenadePocket ( XComGameData.ini ) to item granted abilities and abilities granted by the character template. Finally the event OverrideHasGrenadePocket is triggered that allows mods to override the final result OverrideHasGrenadePocket event Param Value EventID OverrideHasGrenadePocket EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 bHasGrenadePocket bool inout Listener template static function EventListenerReturn OnOverrideHasGrenadePocket(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit SourceUnit; local XComLWTuple Tuple; local bool bHasGrenadePocket; SourceUnit = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bHasGrenadePocket = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bHasGrenadePocket; return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:4086-4096","title":"OverrideHasGrenadePocket"},{"location":"strategy/OverrideHasGrenadePocket/#overridehasgrenadepocket","text":"Tracking Issue: #735 Tags: loadoutslots , events Extends the ability check in HasGrenadePocket() for the config array AbilityUnlocksGrenadePocket ( XComGameData.ini ) to item granted abilities and abilities granted by the character template. Finally the event OverrideHasGrenadePocket is triggered that allows mods to override the final result","title":"OverrideHasGrenadePocket"},{"location":"strategy/OverrideHasGrenadePocket/#overridehasgrenadepocket-event","text":"Param Value EventID OverrideHasGrenadePocket EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"OverrideHasGrenadePocket event"},{"location":"strategy/OverrideHasGrenadePocket/#tuple-contents","text":"Index Name Type Direction 0 bHasGrenadePocket bool inout","title":"Tuple contents"},{"location":"strategy/OverrideHasGrenadePocket/#listener-template","text":"static function EventListenerReturn OnOverrideHasGrenadePocket(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit SourceUnit; local XComLWTuple Tuple; local bool bHasGrenadePocket; SourceUnit = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bHasGrenadePocket = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bHasGrenadePocket; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideHasGrenadePocket/#source-code-references","text":"XComGameState_Unit.uc:4086-4096","title":"Source code references"},{"location":"strategy/OverrideHasHeavyWeapon/","text":"OverrideHasHeavyWeapon Tracking Issue: #172 Tags: loadoutslots , events The OverrideHasHeavyWeapon event allows mods to override the base game logic that determines whether a Unit has a Heavy Weapon Slot or not. Keep in mind the GetNumHeavyWeaponSlotsOverride() X2DLCInfo method may override this later. OverrideHasHeavyWeapon event Param Value EventID OverrideHasHeavyWeapon EventData XComLWTuple EventSource XComGameState_Unit NewGameState maybe Tuple contents Index Name Type Direction 0 bOverrideHasHeavyWeapon bool inout 1 bHasHeavyWeapon bool inout Listener template static function EventListenerReturn OnOverrideHasHeavyWeapon(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool bOverrideHasHeavyWeapon; local bool bHasHeavyWeapon; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bOverrideHasHeavyWeapon = Tuple.Data[0].b; bHasHeavyWeapon = Tuple.Data[1].b; // Your code here Tuple.Data[0].b = bOverrideHasHeavyWeapon; Tuple.Data[1].b = bHasHeavyWeapon; return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:4204-4215","title":"OverrideHasHeavyWeapon"},{"location":"strategy/OverrideHasHeavyWeapon/#overridehasheavyweapon","text":"Tracking Issue: #172 Tags: loadoutslots , events The OverrideHasHeavyWeapon event allows mods to override the base game logic that determines whether a Unit has a Heavy Weapon Slot or not. Keep in mind the GetNumHeavyWeaponSlotsOverride() X2DLCInfo method may override this later.","title":"OverrideHasHeavyWeapon"},{"location":"strategy/OverrideHasHeavyWeapon/#overridehasheavyweapon-event","text":"Param Value EventID OverrideHasHeavyWeapon EventData XComLWTuple EventSource XComGameState_Unit NewGameState maybe","title":"OverrideHasHeavyWeapon event"},{"location":"strategy/OverrideHasHeavyWeapon/#tuple-contents","text":"Index Name Type Direction 0 bOverrideHasHeavyWeapon bool inout 1 bHasHeavyWeapon bool inout","title":"Tuple contents"},{"location":"strategy/OverrideHasHeavyWeapon/#listener-template","text":"static function EventListenerReturn OnOverrideHasHeavyWeapon(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool bOverrideHasHeavyWeapon; local bool bHasHeavyWeapon; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bOverrideHasHeavyWeapon = Tuple.Data[0].b; bHasHeavyWeapon = Tuple.Data[1].b; // Your code here Tuple.Data[0].b = bOverrideHasHeavyWeapon; Tuple.Data[1].b = bHasHeavyWeapon; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideHasHeavyWeapon/#source-code-references","text":"XComGameState_Unit.uc:4204-4215","title":"Source code references"},{"location":"strategy/OverrideImageForItemAvaliable/","text":"OverrideImageForItemAvaliable Tracking Issue: #491 Tags: ui Allows overriding the image shown for an item in the eAlert_ItemAvailable alert. This alert is triggered when a tech completes and makes available a new item for building, but, if it happens to target a singular weapon (rather than the upgrade schematic), shows a weapon without attachments (as specified in the Template's strImage ). This event gives mods a chance to fix it. ID: OverrideImageForItemAvaliable, Data: [inout string ImagePath, in X2ItemTemplate ItemTemplate], Source: UIAlert Source code references UIAlert.uc:3427-3438","title":"OverrideImageForItemAvaliable"},{"location":"strategy/OverrideImageForItemAvaliable/#overrideimageforitemavaliable","text":"Tracking Issue: #491 Tags: ui Allows overriding the image shown for an item in the eAlert_ItemAvailable alert. This alert is triggered when a tech completes and makes available a new item for building, but, if it happens to target a singular weapon (rather than the upgrade schematic), shows a weapon without attachments (as specified in the Template's strImage ). This event gives mods a chance to fix it. ID: OverrideImageForItemAvaliable, Data: [inout string ImagePath, in X2ItemTemplate ItemTemplate], Source: UIAlert","title":"OverrideImageForItemAvaliable"},{"location":"strategy/OverrideImageForItemAvaliable/#source-code-references","text":"UIAlert.uc:3427-3438","title":"Source code references"},{"location":"strategy/OverrideInjuryClearingFatigueBehavior/","text":"OverrideInjuryClearingFatigueBehavior Tracking Issue: #1126 Tags: events Allows overriding The game's behavior regarding Removing Fatigue on Healing Default: Vanilla behavior will be used. OverrideInjuryClearingFatigueBehavior event Param Value EventID OverrideInjuryClearingFatigueBehavior EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes Tuple contents Index Name Type Direction 0 ShouldOverride bool inout Listener template static function EventListenerReturn OnOverrideInjuryClearingFatigueBehavior(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool ShouldOverride; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); ShouldOverride = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = ShouldOverride; return ELR_NoInterrupt; } Source code references XComGameStateContext_HeadquartersOrder.uc:1231-1240","title":"OverrideInjuryClearingFatigueBehavior"},{"location":"strategy/OverrideInjuryClearingFatigueBehavior/#overrideinjuryclearingfatiguebehavior","text":"Tracking Issue: #1126 Tags: events Allows overriding The game's behavior regarding Removing Fatigue on Healing Default: Vanilla behavior will be used.","title":"OverrideInjuryClearingFatigueBehavior"},{"location":"strategy/OverrideInjuryClearingFatigueBehavior/#overrideinjuryclearingfatiguebehavior-event","text":"Param Value EventID OverrideInjuryClearingFatigueBehavior EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes","title":"OverrideInjuryClearingFatigueBehavior event"},{"location":"strategy/OverrideInjuryClearingFatigueBehavior/#tuple-contents","text":"Index Name Type Direction 0 ShouldOverride bool inout","title":"Tuple contents"},{"location":"strategy/OverrideInjuryClearingFatigueBehavior/#listener-template","text":"static function EventListenerReturn OnOverrideInjuryClearingFatigueBehavior(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool ShouldOverride; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); ShouldOverride = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = ShouldOverride; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideInjuryClearingFatigueBehavior/#source-code-references","text":"XComGameStateContext_HeadquartersOrder.uc:1231-1240","title":"Source code references"},{"location":"strategy/OverrideMissionImage/","text":"OverrideMissionImage Tracking Issue: #635 Tags: ui , events Allows overriding the image shown for a mission in the UIMission screen. OverrideMissionImage event Param Value EventID OverrideMissionImage EventData XComLWTuple EventSource XComGameState_MissionSite NewGameState none Tuple contents Index Name Type Direction 0 ImagePath string inout Listener template static function EventListenerReturn OnOverrideMissionImage(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_MissionSite MissionState; local XComLWTuple Tuple; local string ImagePath; MissionState = XComGameState_MissionSite(EventSource); Tuple = XComLWTuple(EventData); ImagePath = Tuple.Data[0].s; // Your code here Tuple.Data[0].s = ImagePath; return ELR_NoInterrupt; } Source code references XComGameState_MissionSite.uc:1933-1941","title":"OverrideMissionImage"},{"location":"strategy/OverrideMissionImage/#overridemissionimage","text":"Tracking Issue: #635 Tags: ui , events Allows overriding the image shown for a mission in the UIMission screen.","title":"OverrideMissionImage"},{"location":"strategy/OverrideMissionImage/#overridemissionimage-event","text":"Param Value EventID OverrideMissionImage EventData XComLWTuple EventSource XComGameState_MissionSite NewGameState none","title":"OverrideMissionImage event"},{"location":"strategy/OverrideMissionImage/#tuple-contents","text":"Index Name Type Direction 0 ImagePath string inout","title":"Tuple contents"},{"location":"strategy/OverrideMissionImage/#listener-template","text":"static function EventListenerReturn OnOverrideMissionImage(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_MissionSite MissionState; local XComLWTuple Tuple; local string ImagePath; MissionState = XComGameState_MissionSite(EventSource); Tuple = XComLWTuple(EventData); ImagePath = Tuple.Data[0].s; // Your code here Tuple.Data[0].s = ImagePath; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideMissionImage/#source-code-references","text":"XComGameState_MissionSite.uc:1933-1941","title":"Source code references"},{"location":"strategy/OverrideNegativeTraitRoll/","text":"OverrideNegativeTraitRoll Tracking Issue: #1150 Tags: events Fires an event that allows mods to override whether a soldier should get a negative trait after the mission. Default: Vanilla Behavior will be used. OverrideNegativeTraitRoll event Param Value EventID OverrideNegativeTraitRoll EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes Tuple contents Index Name Type Direction 0 ShouldRollNegativeTrait bool inout Listener template static function EventListenerReturn OnOverrideNegativeTraitRoll(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool ShouldRollNegativeTrait; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); ShouldRollNegativeTrait = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = ShouldRollNegativeTrait; return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:962-971","title":"OverrideNegativeTraitRoll"},{"location":"strategy/OverrideNegativeTraitRoll/#overridenegativetraitroll","text":"Tracking Issue: #1150 Tags: events Fires an event that allows mods to override whether a soldier should get a negative trait after the mission. Default: Vanilla Behavior will be used.","title":"OverrideNegativeTraitRoll"},{"location":"strategy/OverrideNegativeTraitRoll/#overridenegativetraitroll-event","text":"Param Value EventID OverrideNegativeTraitRoll EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes","title":"OverrideNegativeTraitRoll event"},{"location":"strategy/OverrideNegativeTraitRoll/#tuple-contents","text":"Index Name Type Direction 0 ShouldRollNegativeTrait bool inout","title":"Tuple contents"},{"location":"strategy/OverrideNegativeTraitRoll/#listener-template","text":"static function EventListenerReturn OnOverrideNegativeTraitRoll(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool ShouldRollNegativeTrait; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); ShouldRollNegativeTrait = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = ShouldRollNegativeTrait; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideNegativeTraitRoll/#source-code-references","text":"XComGameState_Unit.uc:962-971","title":"Source code references"},{"location":"strategy/OverrideNextRetaliationDisplay/","text":"OverrideNextRetaliationDisplay Tracking Issue: #667 Tags: events The Dark Events Screen ( UIAdventOperations ) by default shows a string like: \"Next Retaliation: 6 Weeks (Estimated)\". This event allows mods to override whether to show that text, and customize the actual displayed text. OverrideNextRetaliationDisplay event Param Value EventID OverrideNextRetaliationDisplay EventData XComLWTuple EventSource UIAdventOperations NewGameState none Tuple contents Index Name Type Direction 0 bShow bool inout 1 strHeader string inout 2 strValue string inout 3 strFooter string inout Listener template static function EventListenerReturn OnOverrideNextRetaliationDisplay(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIAdventOperations Screen; local XComLWTuple Tuple; local bool bShow; local string strHeader; local string strValue; local string strFooter; Screen = UIAdventOperations(EventSource); Tuple = XComLWTuple(EventData); bShow = Tuple.Data[0].b; strHeader = Tuple.Data[1].s; strValue = Tuple.Data[2].s; strFooter = Tuple.Data[3].s; // Your code here Tuple.Data[0].b = bShow; Tuple.Data[1].s = strHeader; Tuple.Data[2].s = strValue; Tuple.Data[3].s = strFooter; return ELR_NoInterrupt; } Source code references UIAdventOperations.uc:253-268","title":"OverrideNextRetaliationDisplay"},{"location":"strategy/OverrideNextRetaliationDisplay/#overridenextretaliationdisplay","text":"Tracking Issue: #667 Tags: events The Dark Events Screen ( UIAdventOperations ) by default shows a string like: \"Next Retaliation: 6 Weeks (Estimated)\". This event allows mods to override whether to show that text, and customize the actual displayed text.","title":"OverrideNextRetaliationDisplay"},{"location":"strategy/OverrideNextRetaliationDisplay/#overridenextretaliationdisplay-event","text":"Param Value EventID OverrideNextRetaliationDisplay EventData XComLWTuple EventSource UIAdventOperations NewGameState none","title":"OverrideNextRetaliationDisplay event"},{"location":"strategy/OverrideNextRetaliationDisplay/#tuple-contents","text":"Index Name Type Direction 0 bShow bool inout 1 strHeader string inout 2 strValue string inout 3 strFooter string inout","title":"Tuple contents"},{"location":"strategy/OverrideNextRetaliationDisplay/#listener-template","text":"static function EventListenerReturn OnOverrideNextRetaliationDisplay(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIAdventOperations Screen; local XComLWTuple Tuple; local bool bShow; local string strHeader; local string strValue; local string strFooter; Screen = UIAdventOperations(EventSource); Tuple = XComLWTuple(EventData); bShow = Tuple.Data[0].b; strHeader = Tuple.Data[1].s; strValue = Tuple.Data[2].s; strFooter = Tuple.Data[3].s; // Your code here Tuple.Data[0].b = bShow; Tuple.Data[1].s = strHeader; Tuple.Data[2].s = strValue; Tuple.Data[3].s = strFooter; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideNextRetaliationDisplay/#source-code-references","text":"UIAdventOperations.uc:253-268","title":"Source code references"},{"location":"strategy/OverrideNumUpgradeSlots/","text":"OverrideNumUpgradeSlots Tracking Issue: #93 Tags: events This event allows mods to modify the number of upgrade slots for each individual item state. OverrideNumUpgradeSlots event Param Value EventID OverrideNumUpgradeSlots EventData XComLWTuple EventSource XComGameState_Item NewGameState none Tuple contents Index Name Type Direction 0 NumUpgradeSlots int inout Listener template static function EventListenerReturn OnOverrideNumUpgradeSlots(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Item ItemState; local XComLWTuple Tuple; local int NumUpgradeSlots; ItemState = XComGameState_Item(EventSource); Tuple = XComLWTuple(EventData); NumUpgradeSlots = Tuple.Data[0].i; // Your code here Tuple.Data[0].i = NumUpgradeSlots; return ELR_NoInterrupt; } Source code references XComGameState_Item.uc:2459-2467","title":"OverrideNumUpgradeSlots"},{"location":"strategy/OverrideNumUpgradeSlots/#overridenumupgradeslots","text":"Tracking Issue: #93 Tags: events This event allows mods to modify the number of upgrade slots for each individual item state.","title":"OverrideNumUpgradeSlots"},{"location":"strategy/OverrideNumUpgradeSlots/#overridenumupgradeslots-event","text":"Param Value EventID OverrideNumUpgradeSlots EventData XComLWTuple EventSource XComGameState_Item NewGameState none","title":"OverrideNumUpgradeSlots event"},{"location":"strategy/OverrideNumUpgradeSlots/#tuple-contents","text":"Index Name Type Direction 0 NumUpgradeSlots int inout","title":"Tuple contents"},{"location":"strategy/OverrideNumUpgradeSlots/#listener-template","text":"static function EventListenerReturn OnOverrideNumUpgradeSlots(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Item ItemState; local XComLWTuple Tuple; local int NumUpgradeSlots; ItemState = XComGameState_Item(EventSource); Tuple = XComLWTuple(EventData); NumUpgradeSlots = Tuple.Data[0].i; // Your code here Tuple.Data[0].i = NumUpgradeSlots; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideNumUpgradeSlots/#source-code-references","text":"XComGameState_Item.uc:2459-2467","title":"Source code references"},{"location":"strategy/OverridePromotionBlueprintTagPrefix/","text":"OverridePromotionBlueprintTagPrefix Tracking Issue: #600 Tags: ui , events Fires an 'OverridePromotionBlueprintTagPrefix' event that allows mods to override the promotion blueprint tag prefix for the after action screen. This means that mods can ensure the camera is positioned properly when displaying their custom promotion screen during the post-mission cinematic. OverridePromotionBlueprintTagPrefix event Param Value EventID OverridePromotionBlueprintTagPrefix EventData XComLWTuple EventSource UIAfterAction NewGameState none Tuple contents Index Name Type Direction 0 UnitState XComGameState_Unit in 1 TagPrefix string inout Listener template static function EventListenerReturn OnOverridePromotionBlueprintTagPrefix(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIAfterAction Screen; local XComLWTuple Tuple; local XComGameState_Unit UnitState; local string TagPrefix; Screen = UIAfterAction(EventSource); Tuple = XComLWTuple(EventData); UnitState = XComGameState_Unit(Tuple.Data[0].o); TagPrefix = Tuple.Data[1].s; // Your code here Tuple.Data[1].s = TagPrefix; return ELR_NoInterrupt; } Source code references UIAfterAction.uc:749-760","title":"OverridePromotionBlueprintTagPrefix"},{"location":"strategy/OverridePromotionBlueprintTagPrefix/#overridepromotionblueprinttagprefix","text":"Tracking Issue: #600 Tags: ui , events Fires an 'OverridePromotionBlueprintTagPrefix' event that allows mods to override the promotion blueprint tag prefix for the after action screen. This means that mods can ensure the camera is positioned properly when displaying their custom promotion screen during the post-mission cinematic.","title":"OverridePromotionBlueprintTagPrefix"},{"location":"strategy/OverridePromotionBlueprintTagPrefix/#overridepromotionblueprinttagprefix-event","text":"Param Value EventID OverridePromotionBlueprintTagPrefix EventData XComLWTuple EventSource UIAfterAction NewGameState none","title":"OverridePromotionBlueprintTagPrefix event"},{"location":"strategy/OverridePromotionBlueprintTagPrefix/#tuple-contents","text":"Index Name Type Direction 0 UnitState XComGameState_Unit in 1 TagPrefix string inout","title":"Tuple contents"},{"location":"strategy/OverridePromotionBlueprintTagPrefix/#listener-template","text":"static function EventListenerReturn OnOverridePromotionBlueprintTagPrefix(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIAfterAction Screen; local XComLWTuple Tuple; local XComGameState_Unit UnitState; local string TagPrefix; Screen = UIAfterAction(EventSource); Tuple = XComLWTuple(EventData); UnitState = XComGameState_Unit(Tuple.Data[0].o); TagPrefix = Tuple.Data[1].s; // Your code here Tuple.Data[1].s = TagPrefix; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverridePromotionBlueprintTagPrefix/#source-code-references","text":"UIAfterAction.uc:749-760","title":"Source code references"},{"location":"strategy/OverridePromotionUIClass/","text":"OverridePromotionUIClass Tracking Issue: #600 Tags: ui , events Fires an event that allows mods to override the UI class used for a given promotion screen. Note that any class provided by a mod must be UIArmory_Promotion or a subclass of it. OverridePromotionUIClass event Param Value EventID OverridePromotionUIClass EventData XComLWTuple EventSource XComHQPresentationLayer NewGameState none Tuple contents Index Name Type Direction 0 PromotionScreenType enum (CHLPromotionScreenType) in 1 PromotionUIClass class (class<UIArmory_Promotion>) inout Listener template static function EventListenerReturn OnOverridePromotionUIClass(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComHQPresentationLayer Pres; local XComLWTuple Tuple; local CHLPromotionScreenType PromotionScreenType; local class<UIArmory_Promotion> PromotionUIClass; Pres = XComHQPresentationLayer(EventSource); Tuple = XComLWTuple(EventData); PromotionScreenType = CHLPromotionScreenType(Tuple.Data[0].i); PromotionUIClass = class<UIArmory_Promotion>(Tuple.Data[1].o); // Your code here Tuple.Data[1].o = PromotionUIClass; return ELR_NoInterrupt; } The following simplified example is taken from Community Promotion Screen : local XComLWTuple Tuple; local CHLPromotionScreenType ScreenType; Tuple = XComLWTuple(EventData); ScreenType = CHLPromotionScreenType(Tuple.Data[0].i); if ((ScreenType == eCHLPST_PsiOp && ShouldOverridePsiPromotionScreen()) || (ScreenType == eCHLPST_Hero && ShouldOverrideHeroPromotionScreen()) || (ScreenType == eCHLPST_Standard && ShouldOverrideStandardPromotionScreen())) { Tuple.Data[1].o = class'NPSBDP_UIArmory_PromotionHero'; } return ELR_NoInterrupt; The integer values of PromotionScreenType correspond to the CHLPromotionScreenType enum. enum CHLPromotionScreenType { eCHLPST_Standard, eCHLPST_Hero, eCHLPST_PsiOp }; Source code references XComHQPresentationLayer.uc:1543-1575 XComHQPresentationLayer.uc:4-12","title":"OverridePromotionUIClass"},{"location":"strategy/OverridePromotionUIClass/#overridepromotionuiclass","text":"Tracking Issue: #600 Tags: ui , events Fires an event that allows mods to override the UI class used for a given promotion screen. Note that any class provided by a mod must be UIArmory_Promotion or a subclass of it.","title":"OverridePromotionUIClass"},{"location":"strategy/OverridePromotionUIClass/#overridepromotionuiclass-event","text":"Param Value EventID OverridePromotionUIClass EventData XComLWTuple EventSource XComHQPresentationLayer NewGameState none","title":"OverridePromotionUIClass event"},{"location":"strategy/OverridePromotionUIClass/#tuple-contents","text":"Index Name Type Direction 0 PromotionScreenType enum (CHLPromotionScreenType) in 1 PromotionUIClass class (class<UIArmory_Promotion>) inout","title":"Tuple contents"},{"location":"strategy/OverridePromotionUIClass/#listener-template","text":"static function EventListenerReturn OnOverridePromotionUIClass(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComHQPresentationLayer Pres; local XComLWTuple Tuple; local CHLPromotionScreenType PromotionScreenType; local class<UIArmory_Promotion> PromotionUIClass; Pres = XComHQPresentationLayer(EventSource); Tuple = XComLWTuple(EventData); PromotionScreenType = CHLPromotionScreenType(Tuple.Data[0].i); PromotionUIClass = class<UIArmory_Promotion>(Tuple.Data[1].o); // Your code here Tuple.Data[1].o = PromotionUIClass; return ELR_NoInterrupt; } The following simplified example is taken from Community Promotion Screen : local XComLWTuple Tuple; local CHLPromotionScreenType ScreenType; Tuple = XComLWTuple(EventData); ScreenType = CHLPromotionScreenType(Tuple.Data[0].i); if ((ScreenType == eCHLPST_PsiOp && ShouldOverridePsiPromotionScreen()) || (ScreenType == eCHLPST_Hero && ShouldOverrideHeroPromotionScreen()) || (ScreenType == eCHLPST_Standard && ShouldOverrideStandardPromotionScreen())) { Tuple.Data[1].o = class'NPSBDP_UIArmory_PromotionHero'; } return ELR_NoInterrupt; The integer values of PromotionScreenType correspond to the CHLPromotionScreenType enum. enum CHLPromotionScreenType { eCHLPST_Standard, eCHLPST_Hero, eCHLPST_PsiOp };","title":"Listener template"},{"location":"strategy/OverridePromotionUIClass/#source-code-references","text":"XComHQPresentationLayer.uc:1543-1575 XComHQPresentationLayer.uc:4-12","title":"Source code references"},{"location":"strategy/OverrideRespecSoldierProjectPoints/","text":"OverrideRespecSoldierProjectPoints Tracking Issue: #624 Tags: events The 'OverrideRespecSoldierProjectPoints' event that allows mods to override the number of project points, i.e. time required to respec a given soldier. The listener is passed the Unit State of the soldier that is to be respecced and the current amount of project points required, either from the base game's config, or from a listener that has fired earlier. To override the project points, the listener simply needs to provide a new value for the ProjectPoints element of the tuple. OverrideRespecSoldierProjectPoints event Param Value EventID OverrideRespecSoldierProjectPoints EventData XComLWTuple EventSource XComGameState_HeadquartersProjectRespecSoldier NewGameState none Tuple contents Index Name Type Direction 0 Unit XComGameState_Unit in 1 ProjectPoints int inout Listener template static function EventListenerReturn OnOverrideRespecSoldierProjectPoints(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_HeadquartersProjectRespecSoldier RespecProject; local XComLWTuple Tuple; local XComGameState_Unit Unit; local int ProjectPoints; RespecProject = XComGameState_HeadquartersProjectRespecSoldier(EventSource); Tuple = XComLWTuple(EventData); Unit = XComGameState_Unit(Tuple.Data[0].o); ProjectPoints = Tuple.Data[1].i; // Your code here Tuple.Data[1].i = ProjectPoints; return ELR_NoInterrupt; } Source code references XComGameState_HeadquartersProjectRespecSoldier.uc:57-71","title":"OverrideRespecSoldierProjectPoints"},{"location":"strategy/OverrideRespecSoldierProjectPoints/#overriderespecsoldierprojectpoints","text":"Tracking Issue: #624 Tags: events The 'OverrideRespecSoldierProjectPoints' event that allows mods to override the number of project points, i.e. time required to respec a given soldier. The listener is passed the Unit State of the soldier that is to be respecced and the current amount of project points required, either from the base game's config, or from a listener that has fired earlier. To override the project points, the listener simply needs to provide a new value for the ProjectPoints element of the tuple.","title":"OverrideRespecSoldierProjectPoints"},{"location":"strategy/OverrideRespecSoldierProjectPoints/#overriderespecsoldierprojectpoints-event","text":"Param Value EventID OverrideRespecSoldierProjectPoints EventData XComLWTuple EventSource XComGameState_HeadquartersProjectRespecSoldier NewGameState none","title":"OverrideRespecSoldierProjectPoints event"},{"location":"strategy/OverrideRespecSoldierProjectPoints/#tuple-contents","text":"Index Name Type Direction 0 Unit XComGameState_Unit in 1 ProjectPoints int inout","title":"Tuple contents"},{"location":"strategy/OverrideRespecSoldierProjectPoints/#listener-template","text":"static function EventListenerReturn OnOverrideRespecSoldierProjectPoints(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_HeadquartersProjectRespecSoldier RespecProject; local XComLWTuple Tuple; local XComGameState_Unit Unit; local int ProjectPoints; RespecProject = XComGameState_HeadquartersProjectRespecSoldier(EventSource); Tuple = XComLWTuple(EventData); Unit = XComGameState_Unit(Tuple.Data[0].o); ProjectPoints = Tuple.Data[1].i; // Your code here Tuple.Data[1].i = ProjectPoints; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideRespecSoldierProjectPoints/#source-code-references","text":"XComGameState_HeadquartersProjectRespecSoldier.uc:57-71","title":"Source code references"},{"location":"strategy/OverrideShowPromoteIcon/","text":"OverrideShowPromoteIcon Tracking Issue: #631 Tags: events The OverrideShowPromoteIcon event allows mods to determine whether a promotion icon for a particular soldier should be displayed or not. This can be relevant for mods that add their own promotion mechanics for soldiers, e.g. a psionic class that has to go on a few missions before they can be stuck into a Psi Lab to get their promotion. OverrideShowPromoteIcon event Param Value EventID OverrideShowPromoteIcon EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 bShowPromotionIcon bool inout Listener template static function EventListenerReturn OnOverrideShowPromoteIcon(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool bShowPromotionIcon; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bShowPromotionIcon = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bShowPromotionIcon; return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:13782-13794","title":"OverrideShowPromoteIcon"},{"location":"strategy/OverrideShowPromoteIcon/#overrideshowpromoteicon","text":"Tracking Issue: #631 Tags: events The OverrideShowPromoteIcon event allows mods to determine whether a promotion icon for a particular soldier should be displayed or not. This can be relevant for mods that add their own promotion mechanics for soldiers, e.g. a psionic class that has to go on a few missions before they can be stuck into a Psi Lab to get their promotion.","title":"OverrideShowPromoteIcon"},{"location":"strategy/OverrideShowPromoteIcon/#overrideshowpromoteicon-event","text":"Param Value EventID OverrideShowPromoteIcon EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"OverrideShowPromoteIcon event"},{"location":"strategy/OverrideShowPromoteIcon/#tuple-contents","text":"Index Name Type Direction 0 bShowPromotionIcon bool inout","title":"Tuple contents"},{"location":"strategy/OverrideShowPromoteIcon/#listener-template","text":"static function EventListenerReturn OnOverrideShowPromoteIcon(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool bShowPromotionIcon; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bShowPromotionIcon = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bShowPromotionIcon; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideShowPromoteIcon/#source-code-references","text":"XComGameState_Unit.uc:13782-13794","title":"Source code references"},{"location":"strategy/OverrideStrategyCostString/","text":"OverrideStrategyCostString Tracking Issue: #1218 Tags: ui , events Fires an event that allows mods to override the strategy layer cost strings. Default: Vanilla behavior will be used. OverrideStrategyCostString event Param Value EventID OverrideStrategyCostString EventData XComLWTuple EventSource none NewGameState none Tuple contents Index Name Type Direction 0 ItemTemplateName name in 1 Quantity int in 2 IsResourceCost bool in 3 CostString string inout Listener template static function EventListenerReturn OnOverrideStrategyCostString(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local name ItemTemplateName; local int Quantity; local bool IsResourceCost; local string CostString; Tuple = XComLWTuple(EventData); ItemTemplateName = Tuple.Data[0].n; Quantity = Tuple.Data[1].i; IsResourceCost = Tuple.Data[2].b; CostString = Tuple.Data[3].s; // Your code here Tuple.Data[3].s = CostString; return ELR_NoInterrupt; } Source code references UIUtilities_Strategy.uc:147-161","title":"OverrideStrategyCostString"},{"location":"strategy/OverrideStrategyCostString/#overridestrategycoststring","text":"Tracking Issue: #1218 Tags: ui , events Fires an event that allows mods to override the strategy layer cost strings. Default: Vanilla behavior will be used.","title":"OverrideStrategyCostString"},{"location":"strategy/OverrideStrategyCostString/#overridestrategycoststring-event","text":"Param Value EventID OverrideStrategyCostString EventData XComLWTuple EventSource none NewGameState none","title":"OverrideStrategyCostString event"},{"location":"strategy/OverrideStrategyCostString/#tuple-contents","text":"Index Name Type Direction 0 ItemTemplateName name in 1 Quantity int in 2 IsResourceCost bool in 3 CostString string inout","title":"Tuple contents"},{"location":"strategy/OverrideStrategyCostString/#listener-template","text":"static function EventListenerReturn OnOverrideStrategyCostString(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local name ItemTemplateName; local int Quantity; local bool IsResourceCost; local string CostString; Tuple = XComLWTuple(EventData); ItemTemplateName = Tuple.Data[0].n; Quantity = Tuple.Data[1].i; IsResourceCost = Tuple.Data[2].b; CostString = Tuple.Data[3].s; // Your code here Tuple.Data[3].s = CostString; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideStrategyCostString/#source-code-references","text":"UIUtilities_Strategy.uc:147-161","title":"Source code references"},{"location":"strategy/OverrideTotalNumKills/","text":"OverrideTotalNumKills Tracking Issue: #562 Tags: events Allows mods to override the total amount of kill XP this unit has. The event data includes the kill XP calculated by vanilla, which can be left as it is, modified, or replaced completely. One example use case is to provide an additional source of XP, such as simply going on a mission. OverrideTotalNumKills event Param Value EventID OverrideTotalNumKills EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 TotalNumKills int inout Listener template static function EventListenerReturn OnOverrideTotalNumKills(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local int TotalNumKills; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); TotalNumKills = Tuple.Data[0].i; // Your code here Tuple.Data[0].i = TotalNumKills; return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:13323-13336","title":"OverrideTotalNumKills"},{"location":"strategy/OverrideTotalNumKills/#overridetotalnumkills","text":"Tracking Issue: #562 Tags: events Allows mods to override the total amount of kill XP this unit has. The event data includes the kill XP calculated by vanilla, which can be left as it is, modified, or replaced completely. One example use case is to provide an additional source of XP, such as simply going on a mission.","title":"OverrideTotalNumKills"},{"location":"strategy/OverrideTotalNumKills/#overridetotalnumkills-event","text":"Param Value EventID OverrideTotalNumKills EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"OverrideTotalNumKills event"},{"location":"strategy/OverrideTotalNumKills/#tuple-contents","text":"Index Name Type Direction 0 TotalNumKills int inout","title":"Tuple contents"},{"location":"strategy/OverrideTotalNumKills/#listener-template","text":"static function EventListenerReturn OnOverrideTotalNumKills(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local int TotalNumKills; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); TotalNumKills = Tuple.Data[0].i; // Your code here Tuple.Data[0].i = TotalNumKills; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideTotalNumKills/#source-code-references","text":"XComGameState_Unit.uc:13323-13336","title":"Source code references"},{"location":"strategy/PhotoboothParticleEffectEnums/","text":"PhotoboothParticleEffectEnums Tracking Issue: #359 This feature provides additional enum values for Photobooth particle effects. To use it, modmakers are required to submit a Pull Request where they will add new enum names, which can then be used when defining particle effects for the Photobooth in XComContent.ini by specifying ParticleEffectTypes = ePPET_NAME within an m_arrAnimationPoses entry, and ParticleEffectType = ePPET_NAME within a ParticleEffects entry. The enum value will then be used by the game to connect the two entries. Note that it's also possible to add particle effects to Photobooth poses by adding them directly to AnimSequences via PlayParticleEffect AnimNotifies, like TLP poses do. Source code references X2Photobooth.uc:67-75","title":"PhotoboothParticleEffectEnums"},{"location":"strategy/PhotoboothParticleEffectEnums/#photoboothparticleeffectenums","text":"Tracking Issue: #359 This feature provides additional enum values for Photobooth particle effects. To use it, modmakers are required to submit a Pull Request where they will add new enum names, which can then be used when defining particle effects for the Photobooth in XComContent.ini by specifying ParticleEffectTypes = ePPET_NAME within an m_arrAnimationPoses entry, and ParticleEffectType = ePPET_NAME within a ParticleEffects entry. The enum value will then be used by the game to connect the two entries. Note that it's also possible to add particle effects to Photobooth poses by adding them directly to AnimSequences via PlayParticleEffect AnimNotifies, like TLP poses do.","title":"PhotoboothParticleEffectEnums"},{"location":"strategy/PhotoboothParticleEffectEnums/#source-code-references","text":"X2Photobooth.uc:67-75","title":"Source code references"},{"location":"strategy/PositiveTraitUI/","text":"PositiveTraitUI Tracking Issue: #1081 Tags: ui Positive traits are a scrapped WOTC feature. The game had only negative traits on release, and no UI was created for a \"positive trait acquired\" event, even though X2TraitTemplate has an unused bPositiveTrait flag. This feature copies and adjusts the \"soldier promoted\" UI to make it function as a makeshift \"positive trait acquired\" UI. This popup will be displayed whenever a soldier acquires a trait with the bPositiveTrait flag set to true on its X2TraitTemplate. Source code references UIAlert.uc:1245-1249 XComGame.ini:294","title":"PositiveTraitUI"},{"location":"strategy/PositiveTraitUI/#positivetraitui","text":"Tracking Issue: #1081 Tags: ui Positive traits are a scrapped WOTC feature. The game had only negative traits on release, and no UI was created for a \"positive trait acquired\" event, even though X2TraitTemplate has an unused bPositiveTrait flag. This feature copies and adjusts the \"soldier promoted\" UI to make it function as a makeshift \"positive trait acquired\" UI. This popup will be displayed whenever a soldier acquires a trait with the bPositiveTrait flag set to true on its X2TraitTemplate.","title":"PositiveTraitUI"},{"location":"strategy/PositiveTraitUI/#source-code-references","text":"UIAlert.uc:1245-1249 XComGame.ini:294","title":"Source code references"},{"location":"strategy/PostInventoryLoadoutApplied/","text":"PostInventoryLoadoutApplied Tracking Issue: #800 Tags: events The PostInventoryLoadoutApplied event allows mods to make arbitrary changes to a Unit after they have been equipped with a Loadout by XComGameState_Unit::ApplyInventoryLoadout() . Normally this is done only once, shortly after the unit was created, but the ApplyInventoryLoadout() may call itself to also equip the Required Loadout on the unit. This means that if listeners intend to call UnitState.ApplyInventoryLoadout() themselves to equip a replacement loadout, they should use UnitState.HasLoadout() to check if the replacement loadout was already equipped by previously triggered listener. Note that the LoadoutName and LoadoutItems components of the Tuple will be empty if ApplyInventoryLoadout() fails to find the loadout it was looking for. PostInventoryLoadoutApplied event Param Value EventID PostInventoryLoadoutApplied EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes Tuple contents Index Name Type Direction 0 LoadoutName name in 1 LoadoutItems array<name> in Listener template static function EventListenerReturn OnPostInventoryLoadoutApplied(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local name LoadoutName; local array<name> LoadoutItems; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); LoadoutName = Tuple.Data[0].n; LoadoutItems = Tuple.Data[1].an; // Your code here return ELR_NoInterrupt; } Refer to this feature for an event that triggers every time the unit is equipped with best available infinite weapons and armor. PostSquaddieLoadoutApplied The PostSquaddieLoadoutApplied event allows mods to make arbitrary changes to a Unit after they have been equipped with a Squaddie Loadout by XComGameState_Unit::ApplySquaddieLoadout() . Normally this function is called only when the unit is ranked up from a rookie to squaddie. Note that the LoadoutName and LoadoutItems components of the Tuple will be empty if ApplySquaddieLoadout() fails to find the loadout it was looking for. PostSquaddieLoadoutApplied event Param Value EventID PostSquaddieLoadoutApplied EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes Tuple contents Index Name Type Direction 0 LoadoutName name in 1 LoadoutItems array<name> in Listener template static function EventListenerReturn OnPostSquaddieLoadoutApplied(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local name LoadoutName; local array<name> LoadoutItems; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); LoadoutName = Tuple.Data[0].n; LoadoutItems = Tuple.Data[1].an; // Your code here return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:11633-11654 XComGameState_Unit.uc:11805-11820","title":"PostInventoryLoadoutApplied"},{"location":"strategy/PostInventoryLoadoutApplied/#postinventoryloadoutapplied","text":"Tracking Issue: #800 Tags: events The PostInventoryLoadoutApplied event allows mods to make arbitrary changes to a Unit after they have been equipped with a Loadout by XComGameState_Unit::ApplyInventoryLoadout() . Normally this is done only once, shortly after the unit was created, but the ApplyInventoryLoadout() may call itself to also equip the Required Loadout on the unit. This means that if listeners intend to call UnitState.ApplyInventoryLoadout() themselves to equip a replacement loadout, they should use UnitState.HasLoadout() to check if the replacement loadout was already equipped by previously triggered listener. Note that the LoadoutName and LoadoutItems components of the Tuple will be empty if ApplyInventoryLoadout() fails to find the loadout it was looking for.","title":"PostInventoryLoadoutApplied"},{"location":"strategy/PostInventoryLoadoutApplied/#postinventoryloadoutapplied-event","text":"Param Value EventID PostInventoryLoadoutApplied EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes","title":"PostInventoryLoadoutApplied event"},{"location":"strategy/PostInventoryLoadoutApplied/#tuple-contents","text":"Index Name Type Direction 0 LoadoutName name in 1 LoadoutItems array<name> in","title":"Tuple contents"},{"location":"strategy/PostInventoryLoadoutApplied/#listener-template","text":"static function EventListenerReturn OnPostInventoryLoadoutApplied(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local name LoadoutName; local array<name> LoadoutItems; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); LoadoutName = Tuple.Data[0].n; LoadoutItems = Tuple.Data[1].an; // Your code here return ELR_NoInterrupt; } Refer to this feature for an event that triggers every time the unit is equipped with best available infinite weapons and armor.","title":"Listener template"},{"location":"strategy/PostInventoryLoadoutApplied/#postsquaddieloadoutapplied","text":"The PostSquaddieLoadoutApplied event allows mods to make arbitrary changes to a Unit after they have been equipped with a Squaddie Loadout by XComGameState_Unit::ApplySquaddieLoadout() . Normally this function is called only when the unit is ranked up from a rookie to squaddie. Note that the LoadoutName and LoadoutItems components of the Tuple will be empty if ApplySquaddieLoadout() fails to find the loadout it was looking for.","title":"PostSquaddieLoadoutApplied"},{"location":"strategy/PostInventoryLoadoutApplied/#postsquaddieloadoutapplied-event","text":"Param Value EventID PostSquaddieLoadoutApplied EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes","title":"PostSquaddieLoadoutApplied event"},{"location":"strategy/PostInventoryLoadoutApplied/#tuple-contents_1","text":"Index Name Type Direction 0 LoadoutName name in 1 LoadoutItems array<name> in","title":"Tuple contents"},{"location":"strategy/PostInventoryLoadoutApplied/#listener-template_1","text":"static function EventListenerReturn OnPostSquaddieLoadoutApplied(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local name LoadoutName; local array<name> LoadoutItems; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); LoadoutName = Tuple.Data[0].n; LoadoutItems = Tuple.Data[1].an; // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/PostInventoryLoadoutApplied/#source-code-references","text":"XComGameState_Unit.uc:11633-11654 XComGameState_Unit.uc:11805-11820","title":"Source code references"},{"location":"strategy/PostUFOSetInterceptionTime/","text":"PostUFOSetInterceptionTime Tracking Issue: #1316 Tags: events This event allows mods to modify the state of a UFO after it has been created but before the gamestate is submitted. To use this event, listen to it with the ELD_Immediate deferral, and make sure to get the latest version of the UFO state object from the NewGameState, for example: local XComGameState_UFO UFOState; UFOState = XComGameState_UFO(EventSource); UFOState = XComGameState_UFO(NewGameState.GetGameStateForObjectID(UFOState.ObjectID)); PostUFOSetInterceptionTime event Param Value EventID PostUFOSetInterceptionTime EventData XComGameState_UFO EventSource XComGameState_UFO NewGameState yes Listener template static function EventListenerReturn OnPostUFOSetInterceptionTime(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { // Your code here return ELR_NoInterrupt; } Source code references XComGameState_UFO.uc:91-109","title":"PostUFOSetInterceptionTime"},{"location":"strategy/PostUFOSetInterceptionTime/#postufosetinterceptiontime","text":"Tracking Issue: #1316 Tags: events This event allows mods to modify the state of a UFO after it has been created but before the gamestate is submitted. To use this event, listen to it with the ELD_Immediate deferral, and make sure to get the latest version of the UFO state object from the NewGameState, for example: local XComGameState_UFO UFOState; UFOState = XComGameState_UFO(EventSource); UFOState = XComGameState_UFO(NewGameState.GetGameStateForObjectID(UFOState.ObjectID));","title":"PostUFOSetInterceptionTime"},{"location":"strategy/PostUFOSetInterceptionTime/#postufosetinterceptiontime-event","text":"Param Value EventID PostUFOSetInterceptionTime EventData XComGameState_UFO EventSource XComGameState_UFO NewGameState yes","title":"PostUFOSetInterceptionTime event"},{"location":"strategy/PostUFOSetInterceptionTime/#listener-template","text":"static function EventListenerReturn OnPostUFOSetInterceptionTime(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/PostUFOSetInterceptionTime/#source-code-references","text":"XComGameState_UFO.uc:91-109","title":"Source code references"},{"location":"strategy/PreCompleteStrategyFromTacticalTransfer/","text":"PreCompleteStrategyFromTacticalTransfer Tracking Issue: #785 Tags: events There are no events that trigger before the mission rewards and several other critical functions are processed. This event gives a way for mods to change several aspects in the transition from tactical to strategy. PreCompleteStrategyFromTacticalTransfer event Param Value EventID PreCompleteStrategyFromTacticalTransfer EventData None EventSource None NewGameState none Listener template static function EventListenerReturn OnPreCompleteStrategyFromTacticalTransfer(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { // Your code here return ELR_NoInterrupt; } Source code references XComGameStateContext_StrategyGameRule.uc:356-366","title":"PreCompleteStrategyFromTacticalTransfer"},{"location":"strategy/PreCompleteStrategyFromTacticalTransfer/#precompletestrategyfromtacticaltransfer","text":"Tracking Issue: #785 Tags: events There are no events that trigger before the mission rewards and several other critical functions are processed. This event gives a way for mods to change several aspects in the transition from tactical to strategy.","title":"PreCompleteStrategyFromTacticalTransfer"},{"location":"strategy/PreCompleteStrategyFromTacticalTransfer/#precompletestrategyfromtacticaltransfer-event","text":"Param Value EventID PreCompleteStrategyFromTacticalTransfer EventData None EventSource None NewGameState none","title":"PreCompleteStrategyFromTacticalTransfer event"},{"location":"strategy/PreCompleteStrategyFromTacticalTransfer/#listener-template","text":"static function EventListenerReturn OnPreCompleteStrategyFromTacticalTransfer(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/PreCompleteStrategyFromTacticalTransfer/#source-code-references","text":"XComGameStateContext_StrategyGameRule.uc:356-366","title":"Source code references"},{"location":"strategy/PreDarkEventDeactivated/","text":"PreDarkEventDeactivated Tracking Issue: #753 Tags: events Notifies listeners of when a dark event has expired/been deactivated. This event fires before the dark event's deactivation code runs, so register an ELD_Immediate listener if you want access to the state before that happens, or an ELD_OnStateSubmitted listener if you want the state after the full deactivation. PreDarkEventDeactivated event Param Value EventID PreDarkEventDeactivated EventData XComGameState_DarkEvent EventSource XComGameState_DarkEvent NewGameState yes Listener template static function EventListenerReturn OnPreDarkEventDeactivated(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_DarkEvent EventState; EventState = XComGameState_DarkEvent(EventData); // Your code here return ELR_NoInterrupt; } Source code references XComGameState_DarkEvent.uc:227-239","title":"PreDarkEventDeactivated"},{"location":"strategy/PreDarkEventDeactivated/#predarkeventdeactivated","text":"Tracking Issue: #753 Tags: events Notifies listeners of when a dark event has expired/been deactivated. This event fires before the dark event's deactivation code runs, so register an ELD_Immediate listener if you want access to the state before that happens, or an ELD_OnStateSubmitted listener if you want the state after the full deactivation.","title":"PreDarkEventDeactivated"},{"location":"strategy/PreDarkEventDeactivated/#predarkeventdeactivated-event","text":"Param Value EventID PreDarkEventDeactivated EventData XComGameState_DarkEvent EventSource XComGameState_DarkEvent NewGameState yes","title":"PreDarkEventDeactivated event"},{"location":"strategy/PreDarkEventDeactivated/#listener-template","text":"static function EventListenerReturn OnPreDarkEventDeactivated(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_DarkEvent EventState; EventState = XComGameState_DarkEvent(EventData); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/PreDarkEventDeactivated/#source-code-references","text":"XComGameState_DarkEvent.uc:227-239","title":"Source code references"},{"location":"strategy/PsiProjectCompleted/","text":"PsiProjectCompleted Tracking Issue: #534 Tags: events Triggers a PsiProjectCompleted event to inform mods that a Psi Operative has finished training in the Psi Lab. PsiProjectCompleted event Param Value EventID PsiProjectCompleted EventData XComLWTuple EventSource XComGameState_HeadquartersProjectPsiTraining NewGameState none Tuple contents Index Name Type Direction 0 Unit XComGameState_Unit in 1 AbilityName string in Listener template static function EventListenerReturn OnPsiProjectCompleted(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_HeadquartersProjectPsiTraining PsiTrainingProject; local XComLWTuple Tuple; local XComGameState_Unit Unit; local string AbilityName; PsiTrainingProject = XComGameState_HeadquartersProjectPsiTraining(EventSource); Tuple = XComLWTuple(EventData); Unit = XComGameState_Unit(Tuple.Data[0].o); AbilityName = Tuple.Data[1].s; // Your code here return ELR_NoInterrupt; } Source code references XComGameState_HeadquartersProjectPsiTraining.uc:139-148","title":"PsiProjectCompleted"},{"location":"strategy/PsiProjectCompleted/#psiprojectcompleted","text":"Tracking Issue: #534 Tags: events Triggers a PsiProjectCompleted event to inform mods that a Psi Operative has finished training in the Psi Lab.","title":"PsiProjectCompleted"},{"location":"strategy/PsiProjectCompleted/#psiprojectcompleted-event","text":"Param Value EventID PsiProjectCompleted EventData XComLWTuple EventSource XComGameState_HeadquartersProjectPsiTraining NewGameState none","title":"PsiProjectCompleted event"},{"location":"strategy/PsiProjectCompleted/#tuple-contents","text":"Index Name Type Direction 0 Unit XComGameState_Unit in 1 AbilityName string in","title":"Tuple contents"},{"location":"strategy/PsiProjectCompleted/#listener-template","text":"static function EventListenerReturn OnPsiProjectCompleted(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_HeadquartersProjectPsiTraining PsiTrainingProject; local XComLWTuple Tuple; local XComGameState_Unit Unit; local string AbilityName; PsiTrainingProject = XComGameState_HeadquartersProjectPsiTraining(EventSource); Tuple = XComLWTuple(EventData); Unit = XComGameState_Unit(Tuple.Data[0].o); AbilityName = Tuple.Data[1].s; // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/PsiProjectCompleted/#source-code-references","text":"XComGameState_HeadquartersProjectPsiTraining.uc:139-148","title":"Source code references"},{"location":"strategy/RegisterInCampaignStart/","text":"RegisterInCampaignStart Tracking Issue: #869 Specifies that a listener template should be registered before campaign initialization occurs so that it can respond to events fired during that initialization (strategy listeners don't receive those events). Source code references CHEventListenerTemplate.uc:67-70","title":"RegisterInCampaignStart"},{"location":"strategy/RegisterInCampaignStart/#registerincampaignstart","text":"Tracking Issue: #869 Specifies that a listener template should be registered before campaign initialization occurs so that it can respond to events fired during that initialization (strategy listeners don't receive those events).","title":"RegisterInCampaignStart"},{"location":"strategy/RegisterInCampaignStart/#source-code-references","text":"CHEventListenerTemplate.uc:67-70","title":"Source code references"},{"location":"strategy/ShowItemInLockerList/","text":"ShowItemInLockerList Tracking Issue: #844 Tags: events Allows listeners to override the result of SlotShowItemInLockerList OverrideShowItemInLockerList event Param Value EventID OverrideShowItemInLockerList EventData XComLWTuple EventSource XComGameState_Item NewGameState maybe Tuple contents Index Name Type Direction 0 bSlotShowItemInLockerList bool inout 1 Slot enum (EInventorySlot) in 2 UnitState XComGameState_Unit in Listener template static function EventListenerReturn OnOverrideShowItemInLockerList(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Item ItemState; local XComLWTuple Tuple; local bool bSlotShowItemInLockerList; local EInventorySlot Slot; local XComGameState_Unit UnitState; ItemState = XComGameState_Item(EventSource); Tuple = XComLWTuple(EventData); bSlotShowItemInLockerList = Tuple.Data[0].b; Slot = EInventorySlot(Tuple.Data[1].i); UnitState = XComGameState_Unit(Tuple.Data[2].o); // Your code here Tuple.Data[0].b = bSlotShowItemInLockerList; return ELR_NoInterrupt; } Source code references CHItemSlot.uc:408-420","title":"ShowItemInLockerList"},{"location":"strategy/ShowItemInLockerList/#showiteminlockerlist","text":"Tracking Issue: #844 Tags: events Allows listeners to override the result of SlotShowItemInLockerList","title":"ShowItemInLockerList"},{"location":"strategy/ShowItemInLockerList/#overrideshowiteminlockerlist-event","text":"Param Value EventID OverrideShowItemInLockerList EventData XComLWTuple EventSource XComGameState_Item NewGameState maybe","title":"OverrideShowItemInLockerList event"},{"location":"strategy/ShowItemInLockerList/#tuple-contents","text":"Index Name Type Direction 0 bSlotShowItemInLockerList bool inout 1 Slot enum (EInventorySlot) in 2 UnitState XComGameState_Unit in","title":"Tuple contents"},{"location":"strategy/ShowItemInLockerList/#listener-template","text":"static function EventListenerReturn OnOverrideShowItemInLockerList(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Item ItemState; local XComLWTuple Tuple; local bool bSlotShowItemInLockerList; local EInventorySlot Slot; local XComGameState_Unit UnitState; ItemState = XComGameState_Item(EventSource); Tuple = XComLWTuple(EventData); bSlotShowItemInLockerList = Tuple.Data[0].b; Slot = EInventorySlot(Tuple.Data[1].i); UnitState = XComGameState_Unit(Tuple.Data[2].o); // Your code here Tuple.Data[0].b = bSlotShowItemInLockerList; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/ShowItemInLockerList/#source-code-references","text":"CHItemSlot.uc:408-420","title":"Source code references"},{"location":"strategy/SitRepCheckAdditionalRequirements/","text":"SitRepCheckAdditionalRequirements Tracking Issue: #561 Tags: events The SitRepCheckAdditionalRequirements event allows mods to subject sitreps to additional checks for specific missions, and then either allow the sitrep to be added to the particular mission (default behavior), or forbid it. SitRepCheckAdditionalRequirements event Param Value EventID SitRepCheckAdditionalRequirements EventData XComLWTuple EventSource X2SitRepTemplate NewGameState none Tuple contents Index Name Type Direction 0 bMeetsRequirements bool inout 1 MissionState XComGameState_MissionSite in Listener template static function EventListenerReturn OnSitRepCheckAdditionalRequirements(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local X2SitRepTemplate SitRepTemplate; local XComLWTuple Tuple; local bool bMeetsRequirements; local XComGameState_MissionSite MissionState; SitRepTemplate = X2SitRepTemplate(EventSource); Tuple = XComLWTuple(EventData); bMeetsRequirements = Tuple.Data[0].b; MissionState = XComGameState_MissionSite(Tuple.Data[1].o); // Your code here Tuple.Data[0].b = bMeetsRequirements; return ELR_NoInterrupt; } Source code references X2SitRepTemplate.uc:121-131","title":"SitRepCheckAdditionalRequirements"},{"location":"strategy/SitRepCheckAdditionalRequirements/#sitrepcheckadditionalrequirements","text":"Tracking Issue: #561 Tags: events The SitRepCheckAdditionalRequirements event allows mods to subject sitreps to additional checks for specific missions, and then either allow the sitrep to be added to the particular mission (default behavior), or forbid it.","title":"SitRepCheckAdditionalRequirements"},{"location":"strategy/SitRepCheckAdditionalRequirements/#sitrepcheckadditionalrequirements-event","text":"Param Value EventID SitRepCheckAdditionalRequirements EventData XComLWTuple EventSource X2SitRepTemplate NewGameState none","title":"SitRepCheckAdditionalRequirements event"},{"location":"strategy/SitRepCheckAdditionalRequirements/#tuple-contents","text":"Index Name Type Direction 0 bMeetsRequirements bool inout 1 MissionState XComGameState_MissionSite in","title":"Tuple contents"},{"location":"strategy/SitRepCheckAdditionalRequirements/#listener-template","text":"static function EventListenerReturn OnSitRepCheckAdditionalRequirements(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local X2SitRepTemplate SitRepTemplate; local XComLWTuple Tuple; local bool bMeetsRequirements; local XComGameState_MissionSite MissionState; SitRepTemplate = X2SitRepTemplate(EventSource); Tuple = XComLWTuple(EventData); bMeetsRequirements = Tuple.Data[0].b; MissionState = XComGameState_MissionSite(Tuple.Data[1].o); // Your code here Tuple.Data[0].b = bMeetsRequirements; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/SitRepCheckAdditionalRequirements/#source-code-references","text":"X2SitRepTemplate.uc:121-131","title":"Source code references"},{"location":"strategy/StrategyMap_NavHelpUpdated/","text":"StrategyMap_NavHelpUpdated Tracking Issue: #932 Tags: ui , events This event is fired after the base game has performed its own updates to the nav help on the Geoscape (StrategyMap), allowing mods to make further changes if they wish. StrategyMap_NavHelpUpdated event Param Value EventID StrategyMap_NavHelpUpdated EventData UINavigationHelp EventSource UIStrategyMap NewGameState none Listener template static function EventListenerReturn OnStrategyMap_NavHelpUpdated(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyMap StrategyMap; StrategyMap = UIStrategyMap(EventSource); // Your code here return ELR_NoInterrupt; } Source code references UIStrategyMap.uc:703-712","title":"StrategyMap_NavHelpUpdated"},{"location":"strategy/StrategyMap_NavHelpUpdated/#strategymap_navhelpupdated","text":"Tracking Issue: #932 Tags: ui , events This event is fired after the base game has performed its own updates to the nav help on the Geoscape (StrategyMap), allowing mods to make further changes if they wish.","title":"StrategyMap_NavHelpUpdated"},{"location":"strategy/StrategyMap_NavHelpUpdated/#strategymap_navhelpupdated-event","text":"Param Value EventID StrategyMap_NavHelpUpdated EventData UINavigationHelp EventSource UIStrategyMap NewGameState none","title":"StrategyMap_NavHelpUpdated event"},{"location":"strategy/StrategyMap_NavHelpUpdated/#listener-template","text":"static function EventListenerReturn OnStrategyMap_NavHelpUpdated(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyMap StrategyMap; StrategyMap = UIStrategyMap(EventSource); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/StrategyMap_NavHelpUpdated/#source-code-references","text":"UIStrategyMap.uc:703-712","title":"Source code references"},{"location":"strategy/TemporarilyBlockDarkEventActivation/","text":"TemporarilyBlockDarkEventActivation Tracking Issue: #597 While this flag is turned on, the dark event cannot activate/complete (transition from preparing to active) and will simply \"wait\" until this flag is turned off. Another possible way of looking at it is that the DE is postponed indefinitely while this flag is active but only if the EndDateTime was reached. var bool bTemporarilyBlockActivation; Source code references XComGameState_DarkEvent.uc:27-33 XComGameState_HeadquartersAlien.uc:1947","title":"TemporarilyBlockDarkEventActivation"},{"location":"strategy/TemporarilyBlockDarkEventActivation/#temporarilyblockdarkeventactivation","text":"Tracking Issue: #597 While this flag is turned on, the dark event cannot activate/complete (transition from preparing to active) and will simply \"wait\" until this flag is turned off. Another possible way of looking at it is that the DE is postponed indefinitely while this flag is active but only if the EndDateTime was reached. var bool bTemporarilyBlockActivation;","title":"TemporarilyBlockDarkEventActivation"},{"location":"strategy/TemporarilyBlockDarkEventActivation/#source-code-references","text":"XComGameState_DarkEvent.uc:27-33 XComGameState_HeadquartersAlien.uc:1947","title":"Source code references"},{"location":"strategy/UIAvengerShortcuts_ShowCQResistanceOrders/","text":"UIAvengerShortcuts_ShowCQResistanceOrders Tracking Issue: #368 Tags: ui , events Allows overriding whether the resistance orders button should be shown in UIAvengerShortcuts . Default: After the first month if any faction met. UIAvengerShortcuts_ShowCQResistanceOrders event Param Value EventID UIAvengerShortcuts_ShowCQResistanceOrders EventData XComLWTuple EventSource UIAvengerShortcuts NewGameState none Tuple contents Index Name Type Direction 0 ShouldShow bool inout Listener template static function EventListenerReturn OnUIAvengerShortcuts_ShowCQResistanceOrders(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIAvengerShortcuts ShortcutsScreen; local XComLWTuple Tuple; local bool ShouldShow; ShortcutsScreen = UIAvengerShortcuts(EventSource); Tuple = XComLWTuple(EventData); ShouldShow = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = ShouldShow; return ELR_NoInterrupt; } Source code references UIAvengerShortcuts.uc:1130-1139","title":"UIAvengerShortcuts_ShowCQResistanceOrders"},{"location":"strategy/UIAvengerShortcuts_ShowCQResistanceOrders/#uiavengershortcuts_showcqresistanceorders","text":"Tracking Issue: #368 Tags: ui , events Allows overriding whether the resistance orders button should be shown in UIAvengerShortcuts . Default: After the first month if any faction met.","title":"UIAvengerShortcuts_ShowCQResistanceOrders"},{"location":"strategy/UIAvengerShortcuts_ShowCQResistanceOrders/#uiavengershortcuts_showcqresistanceorders-event","text":"Param Value EventID UIAvengerShortcuts_ShowCQResistanceOrders EventData XComLWTuple EventSource UIAvengerShortcuts NewGameState none","title":"UIAvengerShortcuts_ShowCQResistanceOrders event"},{"location":"strategy/UIAvengerShortcuts_ShowCQResistanceOrders/#tuple-contents","text":"Index Name Type Direction 0 ShouldShow bool inout","title":"Tuple contents"},{"location":"strategy/UIAvengerShortcuts_ShowCQResistanceOrders/#listener-template","text":"static function EventListenerReturn OnUIAvengerShortcuts_ShowCQResistanceOrders(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIAvengerShortcuts ShortcutsScreen; local XComLWTuple Tuple; local bool ShouldShow; ShortcutsScreen = UIAvengerShortcuts(EventSource); Tuple = XComLWTuple(EventData); ShouldShow = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = ShouldShow; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/UIAvengerShortcuts_ShowCQResistanceOrders/#source-code-references","text":"UIAvengerShortcuts.uc:1130-1139","title":"Source code references"},{"location":"strategy/UIResistanceReport_ShowCouncil/","text":"UIResistanceReport_ShowCouncil Tracking Issue: #663 Tags: ui , events Allows overriding whether to show the council guy and his remarks in the background at the end of month. UIResistanceReport_ShowCouncil event Param Value EventID UIResistanceReport_ShowCouncil EventData XComLWTuple EventSource UIResistanceReport NewGameState none Tuple contents Index Name Type Direction 0 ShouldShow bool inout Listener template static function EventListenerReturn OnUIResistanceReport_ShowCouncil(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIResistanceReport Screen; local XComLWTuple Tuple; local bool ShouldShow; Screen = UIResistanceReport(EventSource); Tuple = XComLWTuple(EventData); ShouldShow = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = ShouldShow; return ELR_NoInterrupt; } Source code references UIResistanceReport.uc:57-67","title":"UIResistanceReport_ShowCouncil"},{"location":"strategy/UIResistanceReport_ShowCouncil/#uiresistancereport_showcouncil","text":"Tracking Issue: #663 Tags: ui , events Allows overriding whether to show the council guy and his remarks in the background at the end of month.","title":"UIResistanceReport_ShowCouncil"},{"location":"strategy/UIResistanceReport_ShowCouncil/#uiresistancereport_showcouncil-event","text":"Param Value EventID UIResistanceReport_ShowCouncil EventData XComLWTuple EventSource UIResistanceReport NewGameState none","title":"UIResistanceReport_ShowCouncil event"},{"location":"strategy/UIResistanceReport_ShowCouncil/#tuple-contents","text":"Index Name Type Direction 0 ShouldShow bool inout","title":"Tuple contents"},{"location":"strategy/UIResistanceReport_ShowCouncil/#listener-template","text":"static function EventListenerReturn OnUIResistanceReport_ShowCouncil(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIResistanceReport Screen; local XComLWTuple Tuple; local bool ShouldShow; Screen = UIResistanceReport(EventSource); Tuple = XComLWTuple(EventData); ShouldShow = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = ShouldShow; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/UIResistanceReport_ShowCouncil/#source-code-references","text":"UIResistanceReport.uc:57-67","title":"Source code references"},{"location":"strategy/UIScanButtonOnMouseEvent/","text":"UIScanButtonOnMouseEvent Tracking Issue: #483 Tags: ui UIScanButton now triggers its OnMouseEventDelegate if set. Do not call ProcessMouseEvents , do not pass go, do not collect $200, just set the delegate directly. Source code references UIScanButton.uc:289-292","title":"UIScanButtonOnMouseEvent"},{"location":"strategy/UIScanButtonOnMouseEvent/#uiscanbuttononmouseevent","text":"Tracking Issue: #483 Tags: ui UIScanButton now triggers its OnMouseEventDelegate if set. Do not call ProcessMouseEvents , do not pass go, do not collect $200, just set the delegate directly.","title":"UIScanButtonOnMouseEvent"},{"location":"strategy/UIScanButtonOnMouseEvent/#source-code-references","text":"UIScanButton.uc:289-292","title":"Source code references"},{"location":"strategy/UIStrategyPolicy_MiscEvents/","text":"UIStrategyPolicy_MiscEvents Tracking Issue: #986 Tags: ui , events UIStrategyPolicy is the screen that allows players to allocate resistance orders at end of \"month\". The Community Highlander adds the following events to that screen so mods have more options for modifying it without overriding it entirely. See the tracking issue for background on why these events were added, and hence a potential use for them. Note You'll need to look at the code for UIStrategyPolicy in order to understand when these events are fired, and hence which ones you'll need for your own customisations. UIStrategyPolicy_PreRefreshAllDecks event Param Value EventID UIStrategyPolicy_PreRefreshAllDecks EventData none EventSource UIStrategyPolicy NewGameState none Listener template static function EventListenerReturn OnUIStrategyPolicy_PreRefreshAllDecks(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; StrategyPolicy = UIStrategyPolicy(EventSource); // Your code here return ELR_NoInterrupt; } UIStrategyPolicy_PostRealizeColumn event Param Value EventID UIStrategyPolicy_PostRealizeColumn EventData UIList EventSource UIStrategyPolicy NewGameState none Listener template static function EventListenerReturn OnUIStrategyPolicy_PostRealizeColumn(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; local UIList Column; StrategyPolicy = UIStrategyPolicy(EventSource); Column = UIList(EventData); // Your code here return ELR_NoInterrupt; } UIStrategyPolicy_PreSelect event Param Value EventID UIStrategyPolicy_PreSelect EventData UIStrategyPolicy_Card EventSource UIStrategyPolicy NewGameState none Listener template static function EventListenerReturn OnUIStrategyPolicy_PreSelect(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; local UIStrategyPolicy_Card TargetCard; StrategyPolicy = UIStrategyPolicy(EventSource); TargetCard = UIStrategyPolicy_Card(EventData); // Your code here return ELR_NoInterrupt; } UIStrategyPolicy_PreClearSelection event Param Value EventID UIStrategyPolicy_PreClearSelection EventData none EventSource UIStrategyPolicy NewGameState none Listener template static function EventListenerReturn OnUIStrategyPolicy_PreClearSelection(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; StrategyPolicy = UIStrategyPolicy(EventSource); // Your code here return ELR_NoInterrupt; } UIStrategyPolicy_DraggingStarted event Param Value EventID UIStrategyPolicy_DraggingStarted EventData none EventSource UIStrategyPolicy NewGameState none Listener template static function EventListenerReturn OnUIStrategyPolicy_DraggingStarted(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; StrategyPolicy = UIStrategyPolicy(EventSource); // Your code here return ELR_NoInterrupt; } UIStrategyPolicy_DraggingEnded event Param Value EventID UIStrategyPolicy_DraggingEnded EventData none EventSource UIStrategyPolicy NewGameState none Listener template static function EventListenerReturn OnUIStrategyPolicy_DraggingEnded(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; StrategyPolicy = UIStrategyPolicy(EventSource); // Your code here return ELR_NoInterrupt; } Source code references UIStrategyPolicy.uc:13-66 UIStrategyPolicy.uc:423 UIStrategyPolicy.uc:914 UIStrategyPolicy.uc:1290 UIStrategyPolicy.uc:1299 UIStrategyPolicy.uc:1597 UIStrategyPolicy.uc:1611","title":"UIStrategyPolicy_MiscEvents"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#uistrategypolicy_miscevents","text":"Tracking Issue: #986 Tags: ui , events UIStrategyPolicy is the screen that allows players to allocate resistance orders at end of \"month\". The Community Highlander adds the following events to that screen so mods have more options for modifying it without overriding it entirely. See the tracking issue for background on why these events were added, and hence a potential use for them. Note You'll need to look at the code for UIStrategyPolicy in order to understand when these events are fired, and hence which ones you'll need for your own customisations.","title":"UIStrategyPolicy_MiscEvents"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#uistrategypolicy_prerefreshalldecks-event","text":"Param Value EventID UIStrategyPolicy_PreRefreshAllDecks EventData none EventSource UIStrategyPolicy NewGameState none","title":"UIStrategyPolicy_PreRefreshAllDecks event"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#listener-template","text":"static function EventListenerReturn OnUIStrategyPolicy_PreRefreshAllDecks(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; StrategyPolicy = UIStrategyPolicy(EventSource); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#uistrategypolicy_postrealizecolumn-event","text":"Param Value EventID UIStrategyPolicy_PostRealizeColumn EventData UIList EventSource UIStrategyPolicy NewGameState none","title":"UIStrategyPolicy_PostRealizeColumn event"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#listener-template_1","text":"static function EventListenerReturn OnUIStrategyPolicy_PostRealizeColumn(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; local UIList Column; StrategyPolicy = UIStrategyPolicy(EventSource); Column = UIList(EventData); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#uistrategypolicy_preselect-event","text":"Param Value EventID UIStrategyPolicy_PreSelect EventData UIStrategyPolicy_Card EventSource UIStrategyPolicy NewGameState none","title":"UIStrategyPolicy_PreSelect event"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#listener-template_2","text":"static function EventListenerReturn OnUIStrategyPolicy_PreSelect(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; local UIStrategyPolicy_Card TargetCard; StrategyPolicy = UIStrategyPolicy(EventSource); TargetCard = UIStrategyPolicy_Card(EventData); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#uistrategypolicy_preclearselection-event","text":"Param Value EventID UIStrategyPolicy_PreClearSelection EventData none EventSource UIStrategyPolicy NewGameState none","title":"UIStrategyPolicy_PreClearSelection event"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#listener-template_3","text":"static function EventListenerReturn OnUIStrategyPolicy_PreClearSelection(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; StrategyPolicy = UIStrategyPolicy(EventSource); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#uistrategypolicy_draggingstarted-event","text":"Param Value EventID UIStrategyPolicy_DraggingStarted EventData none EventSource UIStrategyPolicy NewGameState none","title":"UIStrategyPolicy_DraggingStarted event"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#listener-template_4","text":"static function EventListenerReturn OnUIStrategyPolicy_DraggingStarted(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; StrategyPolicy = UIStrategyPolicy(EventSource); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#uistrategypolicy_draggingended-event","text":"Param Value EventID UIStrategyPolicy_DraggingEnded EventData none EventSource UIStrategyPolicy NewGameState none","title":"UIStrategyPolicy_DraggingEnded event"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#listener-template_5","text":"static function EventListenerReturn OnUIStrategyPolicy_DraggingEnded(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; StrategyPolicy = UIStrategyPolicy(EventSource); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#source-code-references","text":"UIStrategyPolicy.uc:13-66 UIStrategyPolicy.uc:423 UIStrategyPolicy.uc:914 UIStrategyPolicy.uc:1290 UIStrategyPolicy.uc:1299 UIStrategyPolicy.uc:1597 UIStrategyPolicy.uc:1611","title":"Source code references"},{"location":"strategy/UIStrategyPolicy_ScreenInit/","text":"UIStrategyPolicy_ScreenInit Tracking Issue: #440 Tags: ui Triggers the event UIStrategyPolicy_ScreenInit immediately after opening the UIStrategyPolicy screen, before it has fully initialized. Can be used to make modifications to camera transition behavior that would be too late in a ScreenListener. ID: UIStrategyPolicy_ScreenInit, Source: UIStrategyPolicy Source code references UIStrategyPolicy.uc:141-149","title":"UIStrategyPolicy_ScreenInit"},{"location":"strategy/UIStrategyPolicy_ScreenInit/#uistrategypolicy_screeninit","text":"Tracking Issue: #440 Tags: ui Triggers the event UIStrategyPolicy_ScreenInit immediately after opening the UIStrategyPolicy screen, before it has fully initialized. Can be used to make modifications to camera transition behavior that would be too late in a ScreenListener. ID: UIStrategyPolicy_ScreenInit, Source: UIStrategyPolicy","title":"UIStrategyPolicy_ScreenInit"},{"location":"strategy/UIStrategyPolicy_ScreenInit/#source-code-references","text":"UIStrategyPolicy.uc:141-149","title":"Source code references"},{"location":"strategy/UIStrategyPolicy_ShowCovertActionsOnClose/","text":"UIStrategyPolicy_ShowCovertActionsOnClose Tracking Issue: #365 Tags: ui , events Allows overriding whether to show the UICovertActions screen after closing the UIStrategyPolicy screen. Default: Show if UIStrategyPolicy was created as part of the end-of-month report and no covert actions are in progress. UIStrategyPolicy_ShowCovertActionsOnClose event Param Value EventID UIStrategyPolicy_ShowCovertActionsOnClose EventData XComLWTuple EventSource UIStrategyPolicy NewGameState none Tuple contents Index Name Type Direction 0 ShouldShow bool inout Listener template static function EventListenerReturn OnUIStrategyPolicy_ShowCovertActionsOnClose(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local bool ShouldShow; Tuple = XComLWTuple(EventData); ShouldShow = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = ShouldShow; return ELR_NoInterrupt; } Source code references UIStrategyPolicy.uc:1932-1944","title":"UIStrategyPolicy_ShowCovertActionsOnClose"},{"location":"strategy/UIStrategyPolicy_ShowCovertActionsOnClose/#uistrategypolicy_showcovertactionsonclose","text":"Tracking Issue: #365 Tags: ui , events Allows overriding whether to show the UICovertActions screen after closing the UIStrategyPolicy screen. Default: Show if UIStrategyPolicy was created as part of the end-of-month report and no covert actions are in progress.","title":"UIStrategyPolicy_ShowCovertActionsOnClose"},{"location":"strategy/UIStrategyPolicy_ShowCovertActionsOnClose/#uistrategypolicy_showcovertactionsonclose-event","text":"Param Value EventID UIStrategyPolicy_ShowCovertActionsOnClose EventData XComLWTuple EventSource UIStrategyPolicy NewGameState none","title":"UIStrategyPolicy_ShowCovertActionsOnClose event"},{"location":"strategy/UIStrategyPolicy_ShowCovertActionsOnClose/#tuple-contents","text":"Index Name Type Direction 0 ShouldShow bool inout","title":"Tuple contents"},{"location":"strategy/UIStrategyPolicy_ShowCovertActionsOnClose/#listener-template","text":"static function EventListenerReturn OnUIStrategyPolicy_ShowCovertActionsOnClose(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local bool ShouldShow; Tuple = XComLWTuple(EventData); ShouldShow = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = ShouldShow; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/UIStrategyPolicy_ShowCovertActionsOnClose/#source-code-references","text":"UIStrategyPolicy.uc:1932-1944","title":"Source code references"},{"location":"strategy/UpdateNavHelp/","text":"UpdateNavHelp Tracking Issue: #420 Tags: events This event allows mods to modify the nav help menu at the bottom of the squad select screen - the menu that normally includes buttons like \"MAKE WEAPONS AVAILABLE\". Note that robojumper's Squad Select mod also triggers this event with the same parameters, so it should be automatically compatible. UISquadSelect_NavHelpUpdate event Param Value EventID UISquadSelect_NavHelpUpdate EventData UINavigationHelp EventSource UISquadSelect NewGameState none Listener template static function EventListenerReturn OnUISquadSelect_NavHelpUpdate(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UISquadSelect SquadSelect; local UINavigationHelp NavHelp; SquadSelect = UISquadSelect(EventSource); NavHelp = UINavigationHelp(EventData); // Your code here return ELR_NoInterrupt; } Source code references UISquadSelect.uc:913-923","title":"UpdateNavHelp"},{"location":"strategy/UpdateNavHelp/#updatenavhelp","text":"Tracking Issue: #420 Tags: events This event allows mods to modify the nav help menu at the bottom of the squad select screen - the menu that normally includes buttons like \"MAKE WEAPONS AVAILABLE\". Note that robojumper's Squad Select mod also triggers this event with the same parameters, so it should be automatically compatible.","title":"UpdateNavHelp"},{"location":"strategy/UpdateNavHelp/#uisquadselect_navhelpupdate-event","text":"Param Value EventID UISquadSelect_NavHelpUpdate EventData UINavigationHelp EventSource UISquadSelect NewGameState none","title":"UISquadSelect_NavHelpUpdate event"},{"location":"strategy/UpdateNavHelp/#listener-template","text":"static function EventListenerReturn OnUISquadSelect_NavHelpUpdate(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UISquadSelect SquadSelect; local UINavigationHelp NavHelp; SquadSelect = UISquadSelect(EventSource); NavHelp = UINavigationHelp(EventData); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/UpdateNavHelp/#source-code-references","text":"UISquadSelect.uc:913-923","title":"Source code references"},{"location":"strategy/ValidateGTSClassTraining/","text":"ValidateGTSClassTraining Tracking Issue: #814 Tags: events Triggers an 'ValidateGTSClassTraining' event that allows listeners to control whether the given class can be trained in the GTS. The event is fired once for each class whenever the GTS creates a list of classes to train. The boolean value is based on vanilla checks (NumInForcedDeck and bMultiplayerOnly), so vanilla behavior is maintained when the value isn't changed by the listener(s), and listeners can base their logic on the vanilla checks or override the result. ValidateGTSClassTraining event Param Value EventID ValidateGTSClassTraining EventData XComLWTuple EventSource UIChooseClass NewGameState none Tuple contents Index Name Type Direction 0 CanTrainClass bool out 1 SoldierClassTemplate X2SoldierClassTemplate in Listener template static function EventListenerReturn OnValidateGTSClassTraining(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIChooseClass ChooseClassScreen; local XComLWTuple Tuple; local bool CanTrainClass; local X2SoldierClassTemplate SoldierClassTemplate; ChooseClassScreen = UIChooseClass(EventSource); Tuple = XComLWTuple(EventData); SoldierClassTemplate = X2SoldierClassTemplate(Tuple.Data[1].o); // Your code here Tuple.Data[0].b = CanTrainClass; return ELR_NoInterrupt; } Source code references UIChooseClass.uc:128-146","title":"ValidateGTSClassTraining"},{"location":"strategy/ValidateGTSClassTraining/#validategtsclasstraining","text":"Tracking Issue: #814 Tags: events Triggers an 'ValidateGTSClassTraining' event that allows listeners to control whether the given class can be trained in the GTS. The event is fired once for each class whenever the GTS creates a list of classes to train. The boolean value is based on vanilla checks (NumInForcedDeck and bMultiplayerOnly), so vanilla behavior is maintained when the value isn't changed by the listener(s), and listeners can base their logic on the vanilla checks or override the result.","title":"ValidateGTSClassTraining"},{"location":"strategy/ValidateGTSClassTraining/#validategtsclasstraining-event","text":"Param Value EventID ValidateGTSClassTraining EventData XComLWTuple EventSource UIChooseClass NewGameState none","title":"ValidateGTSClassTraining event"},{"location":"strategy/ValidateGTSClassTraining/#tuple-contents","text":"Index Name Type Direction 0 CanTrainClass bool out 1 SoldierClassTemplate X2SoldierClassTemplate in","title":"Tuple contents"},{"location":"strategy/ValidateGTSClassTraining/#listener-template","text":"static function EventListenerReturn OnValidateGTSClassTraining(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIChooseClass ChooseClassScreen; local XComLWTuple Tuple; local bool CanTrainClass; local X2SoldierClassTemplate SoldierClassTemplate; ChooseClassScreen = UIChooseClass(EventSource); Tuple = XComLWTuple(EventData); SoldierClassTemplate = X2SoldierClassTemplate(Tuple.Data[1].o); // Your code here Tuple.Data[0].b = CanTrainClass; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/ValidateGTSClassTraining/#source-code-references","text":"UIChooseClass.uc:128-146","title":"Source code references"},{"location":"strategy/WillRecoveryTimeModifier/","text":"WillRecoveryTimeModifier Tracking Issue: #650 Tags: events Allows mods to apply a multiplier to the Will recovery project time, where a value of 1.0 makes no change, 2.0 doubles the duration, etc. Listeners can get the recovering unit from the Will project's ProjectFocus property. WillRecoveryTimeModifier event Param Value EventID WillRecoveryTimeModifier EventData XComLWTuple EventSource XComGameState_HeadquartersProjectRecoverWill NewGameState maybe Tuple contents Index Name Type Direction 0 TimeMultiplier float inout 1 bAssumeActive bool in Listener template static function EventListenerReturn OnWillRecoveryTimeModifier(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_HeadquartersProjectRecoverWill ProjectState; local XComLWTuple Tuple; local float TimeMultiplier; local bool bAssumeActive; ProjectState = XComGameState_HeadquartersProjectRecoverWill(EventSource); Tuple = XComLWTuple(EventData); TimeMultiplier = Tuple.Data[0].f; bAssumeActive = Tuple.Data[1].b; // Your code here Tuple.Data[0].f = TimeMultiplier; return ELR_NoInterrupt; } The NewGameState and bAssumeActive will be whatever caller to CalculateWorkPerHour() passes. Note that both arguments are optional. If you want to modify the TimeMultiplier , you must subscribe with ELD_Immediate deferral Source code references XComGameState_HeadquartersProjectRecoverWill.uc:93-111","title":"WillRecoveryTimeModifier"},{"location":"strategy/WillRecoveryTimeModifier/#willrecoverytimemodifier","text":"Tracking Issue: #650 Tags: events Allows mods to apply a multiplier to the Will recovery project time, where a value of 1.0 makes no change, 2.0 doubles the duration, etc. Listeners can get the recovering unit from the Will project's ProjectFocus property.","title":"WillRecoveryTimeModifier"},{"location":"strategy/WillRecoveryTimeModifier/#willrecoverytimemodifier-event","text":"Param Value EventID WillRecoveryTimeModifier EventData XComLWTuple EventSource XComGameState_HeadquartersProjectRecoverWill NewGameState maybe","title":"WillRecoveryTimeModifier event"},{"location":"strategy/WillRecoveryTimeModifier/#tuple-contents","text":"Index Name Type Direction 0 TimeMultiplier float inout 1 bAssumeActive bool in","title":"Tuple contents"},{"location":"strategy/WillRecoveryTimeModifier/#listener-template","text":"static function EventListenerReturn OnWillRecoveryTimeModifier(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_HeadquartersProjectRecoverWill ProjectState; local XComLWTuple Tuple; local float TimeMultiplier; local bool bAssumeActive; ProjectState = XComGameState_HeadquartersProjectRecoverWill(EventSource); Tuple = XComLWTuple(EventData); TimeMultiplier = Tuple.Data[0].f; bAssumeActive = Tuple.Data[1].b; // Your code here Tuple.Data[0].f = TimeMultiplier; return ELR_NoInterrupt; } The NewGameState and bAssumeActive will be whatever caller to CalculateWorkPerHour() passes. Note that both arguments are optional. If you want to modify the TimeMultiplier , you must subscribe with ELD_Immediate deferral","title":"Listener template"},{"location":"strategy/WillRecoveryTimeModifier/#source-code-references","text":"XComGameState_HeadquartersProjectRecoverWill.uc:93-111","title":"Source code references"},{"location":"strategy/WorldRegionGetMeshScale/","text":"WorldRegionGetMeshScale Tracking Issue: #864 Tags: events This is an event that mods which add new static meshes to the overworld can hook into to ensure that those static meshes scale properly. The EventData is a single-value XComLWTuple that contains the vector that will be applied to the static mesh. The EventSource is the WorldRegion instance. Source code references XComGameState_WorldRegion.uc:1065-1071","title":"WorldRegionGetMeshScale"},{"location":"strategy/WorldRegionGetMeshScale/#worldregiongetmeshscale","text":"Tracking Issue: #864 Tags: events This is an event that mods which add new static meshes to the overworld can hook into to ensure that those static meshes scale properly. The EventData is a single-value XComLWTuple that contains the vector that will be applied to the static mesh. The EventSource is the WorldRegion instance.","title":"WorldRegionGetMeshScale"},{"location":"strategy/WorldRegionGetMeshScale/#source-code-references","text":"XComGameState_WorldRegion.uc:1065-1071","title":"Source code references"},{"location":"strategy/WorldRegionGetStaticMesh/","text":"WorldRegionGetStaticMesh Tracking Issue: #864 Tags: events This is an event that mods which add new static meshes to the overworld can hook into to ensure that those static meshes actually display. The EventData is a single-value XComLWTuple that contains the StaticMesh that will be displayed. The EventSource is the WorldRegion instance. Source code references XComGameState_WorldRegion.uc:1029-1034","title":"WorldRegionGetStaticMesh"},{"location":"strategy/WorldRegionGetStaticMesh/#worldregiongetstaticmesh","text":"Tracking Issue: #864 Tags: events This is an event that mods which add new static meshes to the overworld can hook into to ensure that those static meshes actually display. The EventData is a single-value XComLWTuple that contains the StaticMesh that will be displayed. The EventSource is the WorldRegion instance.","title":"WorldRegionGetStaticMesh"},{"location":"strategy/WorldRegionGetStaticMesh/#source-code-references","text":"XComGameState_WorldRegion.uc:1029-1034","title":"Source code references"},{"location":"tactical/AllowInteractHack/","text":"AllowInteractHack Tracking Issue: #564 Tags: events The AllowInteractHack event allows mods to forbid an interactive object from being hackable by a unit. AllowInteractHack event Param Value EventID AllowInteractHack EventData XComLWTuple EventSource XComGameState_InteractiveObject NewGameState none Tuple contents Index Name Type Direction 0 bAllowInteractHack bool inout 1 HackingUnit XComGameState_Unit in Listener template static function EventListenerReturn OnAllowInteractHack(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_InteractiveObject InteractiveObject; local XComLWTuple Tuple; local bool bAllowInteractHack; local XComGameState_Unit HackingUnit; InteractiveObject = XComGameState_InteractiveObject(EventSource); Tuple = XComLWTuple(EventData); bAllowInteractHack = Tuple.Data[0].b; HackingUnit = XComGameState_Unit(Tuple.Data[1].o); // Your code here Tuple.Data[0].b = bAllowInteractHack; return ELR_NoInterrupt; } Source code references XComGameState_InteractiveObject.uc:525-533","title":"AllowInteractHack"},{"location":"tactical/AllowInteractHack/#allowinteracthack","text":"Tracking Issue: #564 Tags: events The AllowInteractHack event allows mods to forbid an interactive object from being hackable by a unit.","title":"AllowInteractHack"},{"location":"tactical/AllowInteractHack/#allowinteracthack-event","text":"Param Value EventID AllowInteractHack EventData XComLWTuple EventSource XComGameState_InteractiveObject NewGameState none","title":"AllowInteractHack event"},{"location":"tactical/AllowInteractHack/#tuple-contents","text":"Index Name Type Direction 0 bAllowInteractHack bool inout 1 HackingUnit XComGameState_Unit in","title":"Tuple contents"},{"location":"tactical/AllowInteractHack/#listener-template","text":"static function EventListenerReturn OnAllowInteractHack(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_InteractiveObject InteractiveObject; local XComLWTuple Tuple; local bool bAllowInteractHack; local XComGameState_Unit HackingUnit; InteractiveObject = XComGameState_InteractiveObject(EventSource); Tuple = XComLWTuple(EventData); bAllowInteractHack = Tuple.Data[0].b; HackingUnit = XComGameState_Unit(Tuple.Data[1].o); // Your code here Tuple.Data[0].b = bAllowInteractHack; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/AllowInteractHack/#source-code-references","text":"XComGameState_InteractiveObject.uc:525-533","title":"Source code references"},{"location":"tactical/BleedingDamageBypassesShields/","text":"BleedingDamageBypassesShields Tracking Issue: #629 In base game, shields (eStat_ShieldHP) absorb damage from typical damage over time bleeding effects, such as those applied by ADVENT Stiletto Rounds. Mods can override this behavior by setting the BLEEDING_IGNORES_SHIELDS flag in XComGameCore.ini : [XComGame.X2StatusEffects] BLEEDING_IGNORES_SHIELDS=true ; Make bleeding DOT ignore shields Note that this will apply only to bleeding effects created using the X2StatusEffect::CreateBleedingStatusEffect() helper method, which should cover all instance of bleeding DOT effects in the base game, but mods can potentially create their own bleeding effects, bypassing this helper method. Refer to this feature to apply similar change to burning, poisoned and acid damage over time. Source code references X2StatusEffects.uc:2317-2333","title":"BleedingDamageBypassesShields"},{"location":"tactical/BleedingDamageBypassesShields/#bleedingdamagebypassesshields","text":"Tracking Issue: #629 In base game, shields (eStat_ShieldHP) absorb damage from typical damage over time bleeding effects, such as those applied by ADVENT Stiletto Rounds. Mods can override this behavior by setting the BLEEDING_IGNORES_SHIELDS flag in XComGameCore.ini : [XComGame.X2StatusEffects] BLEEDING_IGNORES_SHIELDS=true ; Make bleeding DOT ignore shields Note that this will apply only to bleeding effects created using the X2StatusEffect::CreateBleedingStatusEffect() helper method, which should cover all instance of bleeding DOT effects in the base game, but mods can potentially create their own bleeding effects, bypassing this helper method. Refer to this feature to apply similar change to burning, poisoned and acid damage over time.","title":"BleedingDamageBypassesShields"},{"location":"tactical/BleedingDamageBypassesShields/#source-code-references","text":"X2StatusEffects.uc:2317-2333","title":"Source code references"},{"location":"tactical/BurningAndPoisonedDamageBypassesShields/","text":"BurningAndPoisonedDamageBypassesShields Tracking Issue: #89 In base game, shields (eStat_ShieldHP) absorb damage from typical damage over time effects, such as burning or poisoned. Mods can override this behavior by setting the following flags in XComGameCore.ini : [XComGame.X2Effect_Burning] BURNED_IGNORES_SHIELDS=true ; Make burn and acid DOT ignore shields [XComGame.X2StatusEffects] POISONED_IGNORES_SHIELDS=true ; Make poison DOT ignore shields Note that BURNED_IGNORES_SHIELDS will apply to all instances of X2Effect_Burning that use its SetBurnDamage() helper method to set up the burn damage effect. POISONED_IGNORES_SHIELDS will apply to all instances of posioned effect created using the X2StatusEffect::CreatePoisonedStatusEffect() helper method. This should cover all instance of these effects in the base game, but mods can potentially disregard these helper methods. Refer to this feature to apply similar change to bleeding damage over time. Source code references X2StatusEffects.uc:1142-1163","title":"BurningAndPoisonedDamageBypassesShields"},{"location":"tactical/BurningAndPoisonedDamageBypassesShields/#burningandpoisoneddamagebypassesshields","text":"Tracking Issue: #89 In base game, shields (eStat_ShieldHP) absorb damage from typical damage over time effects, such as burning or poisoned. Mods can override this behavior by setting the following flags in XComGameCore.ini : [XComGame.X2Effect_Burning] BURNED_IGNORES_SHIELDS=true ; Make burn and acid DOT ignore shields [XComGame.X2StatusEffects] POISONED_IGNORES_SHIELDS=true ; Make poison DOT ignore shields Note that BURNED_IGNORES_SHIELDS will apply to all instances of X2Effect_Burning that use its SetBurnDamage() helper method to set up the burn damage effect. POISONED_IGNORES_SHIELDS will apply to all instances of posioned effect created using the X2StatusEffect::CreatePoisonedStatusEffect() helper method. This should cover all instance of these effects in the base game, but mods can potentially disregard these helper methods. Refer to this feature to apply similar change to bleeding damage over time.","title":"BurningAndPoisonedDamageBypassesShields"},{"location":"tactical/BurningAndPoisonedDamageBypassesShields/#source-code-references","text":"X2StatusEffects.uc:1142-1163","title":"Source code references"},{"location":"tactical/CHL_SetupActionsForBeginTurn/","text":"CHL_SetupActionsForBeginTurn Tracking Issue: #1325 A function located in XComGameState_Unit. This variant of the vanilla SetupActionsForBeginTurn comes with a slew of optional parameters to allow for greater control. If none of the parameters are used, it'll default to behaving like the vanilla SetupActionsForBeginTurn function. Below is the definitions of these parameters and what they are for: optional bool GiveActionPoints = true - Controls whether or not a unit will gain the default 2 standard action points. optional bool ResetUntouchable = true - Controls whether or not the units with untouchable will be reset and able to be acquired again. optional bool ResetGotFreeFireAction = true - Controls whether or not hair trigger procs reset. optional bool HandleMovesUnitValues = true - Units have some movement related unit values get manipulated in the vanilla SetupActionsForBeginTurn function. This determines if that happens or not. optional bool CleanupBeginTurnUnitValues = true - Controls whether or not unit values with eCleanup_BeginTurn get reset. optional bool UpdateTurnStartLocation = true - Controls whether or not the unit's turn start location gets updated. optional bool ResetPanicTestsPerformedThisTurn = true - Controls whether or not the tracker for the amount of panic tests performed gets reset. Source code references XComGameState_Unit.uc:7456-7473 XComGame.ini:309","title":"CHL_SetupActionsForBeginTurn"},{"location":"tactical/CHL_SetupActionsForBeginTurn/#chl_setupactionsforbeginturn","text":"Tracking Issue: #1325 A function located in XComGameState_Unit. This variant of the vanilla SetupActionsForBeginTurn comes with a slew of optional parameters to allow for greater control. If none of the parameters are used, it'll default to behaving like the vanilla SetupActionsForBeginTurn function. Below is the definitions of these parameters and what they are for: optional bool GiveActionPoints = true - Controls whether or not a unit will gain the default 2 standard action points. optional bool ResetUntouchable = true - Controls whether or not the units with untouchable will be reset and able to be acquired again. optional bool ResetGotFreeFireAction = true - Controls whether or not hair trigger procs reset. optional bool HandleMovesUnitValues = true - Units have some movement related unit values get manipulated in the vanilla SetupActionsForBeginTurn function. This determines if that happens or not. optional bool CleanupBeginTurnUnitValues = true - Controls whether or not unit values with eCleanup_BeginTurn get reset. optional bool UpdateTurnStartLocation = true - Controls whether or not the unit's turn start location gets updated. optional bool ResetPanicTestsPerformedThisTurn = true - Controls whether or not the tracker for the amount of panic tests performed gets reset.","title":"CHL_SetupActionsForBeginTurn"},{"location":"tactical/CHL_SetupActionsForBeginTurn/#source-code-references","text":"XComGameState_Unit.uc:7456-7473 XComGame.ini:309","title":"Source code references"},{"location":"tactical/ConsiderAlliesforSoundAlerts/","text":"ConsiderAlliesforSoundAlerts Tracking Issue: #620 Normally units firing weapons alert only their enemies. This feature allows units to alert their allies as well when they fire. Note that this will not have any effect unless a mod has turned on yellow alerts in XComGameState_AIUnitData::ShouldEnemyFactionsTriggerAlertsOutsidePlayerVision() , since by default alert data is not recorded for sounds outside of XCom's vision. Source code references XComGameState_Unit.uc:9824-9829 XComGame.ini:260 XComGameState_Unit.uc:11034","title":"ConsiderAlliesforSoundAlerts"},{"location":"tactical/ConsiderAlliesforSoundAlerts/#consideralliesforsoundalerts","text":"Tracking Issue: #620 Normally units firing weapons alert only their enemies. This feature allows units to alert their allies as well when they fire. Note that this will not have any effect unless a mod has turned on yellow alerts in XComGameState_AIUnitData::ShouldEnemyFactionsTriggerAlertsOutsidePlayerVision() , since by default alert data is not recorded for sounds outside of XCom's vision.","title":"ConsiderAlliesforSoundAlerts"},{"location":"tactical/ConsiderAlliesforSoundAlerts/#source-code-references","text":"XComGameState_Unit.uc:9824-9829 XComGame.ini:260 XComGameState_Unit.uc:11034","title":"Source code references"},{"location":"tactical/CustomTargetStyles/","text":"CustomTargetStyles Tracking Issue: #763 Tags: compatibility Target styles are responsible for the initial target selection for tactical abilities. The AbilityTargetStyle builds an initial target list (or none, for cursor-targeted abilities). The AbilityMultiTargetStyle adds other targets to every target built by the AbilityTargetStyle or the cursor target. Even though the results are cached, this code is extremely performance-critical: Every time a game state is added to the History, all cached results are invalidated. Whenever the AI evaluates a unit, the player selects a unit, or a reaction ability checks for valid targets, this code is run for every ability on the unit! As a result, all of this code is native: The target styles themselves are native, and their functions are called by the native GatherAbilityTargets function. This native code simply cannot see UnrealScript implementations of target styles, so custom target styles are essentially ignored. We can override GatherAbilityTargets in a subclass with the slower UnrealScript implementation that Firaxis helpfully provided in a comment. Doing this with all abilities would seriously degrade performance, so we use CH_ClassIsNative to check if any target styles are non-native, and if so use a custom XComGameState_Ability subclass when instanciating the game state object for an ability template. TL;DR Custom, scripted ability target/multi-target styles magically start working. Compatibility In order to selectively override the XComGameState_Ability class, we modify X2AbilityTemplate:CreateInstanceFromTemplate . If your mod overrides CreateInstanceFromTemplate in a subclass of X2AbilityTemplate , the Highlander will not be able to apply this enhancement to that ability. On the other hand, if you override CreateInstanceFromTemplate precisely to instantiate your own ability state object with GatherAbilityTargets de-nativized for a custom target style, your abilities will keep working the same way. Source code references XComGameState_Ability_CH.uc:1-30 X2AbilityTemplate.uc:262 XComGameState_Ability.uc:284","title":"CustomTargetStyles"},{"location":"tactical/CustomTargetStyles/#customtargetstyles","text":"Tracking Issue: #763 Tags: compatibility Target styles are responsible for the initial target selection for tactical abilities. The AbilityTargetStyle builds an initial target list (or none, for cursor-targeted abilities). The AbilityMultiTargetStyle adds other targets to every target built by the AbilityTargetStyle or the cursor target. Even though the results are cached, this code is extremely performance-critical: Every time a game state is added to the History, all cached results are invalidated. Whenever the AI evaluates a unit, the player selects a unit, or a reaction ability checks for valid targets, this code is run for every ability on the unit! As a result, all of this code is native: The target styles themselves are native, and their functions are called by the native GatherAbilityTargets function. This native code simply cannot see UnrealScript implementations of target styles, so custom target styles are essentially ignored. We can override GatherAbilityTargets in a subclass with the slower UnrealScript implementation that Firaxis helpfully provided in a comment. Doing this with all abilities would seriously degrade performance, so we use CH_ClassIsNative to check if any target styles are non-native, and if so use a custom XComGameState_Ability subclass when instanciating the game state object for an ability template. TL;DR Custom, scripted ability target/multi-target styles magically start working.","title":"CustomTargetStyles"},{"location":"tactical/CustomTargetStyles/#compatibility","text":"In order to selectively override the XComGameState_Ability class, we modify X2AbilityTemplate:CreateInstanceFromTemplate . If your mod overrides CreateInstanceFromTemplate in a subclass of X2AbilityTemplate , the Highlander will not be able to apply this enhancement to that ability. On the other hand, if you override CreateInstanceFromTemplate precisely to instantiate your own ability state object with GatherAbilityTargets de-nativized for a custom target style, your abilities will keep working the same way.","title":"Compatibility"},{"location":"tactical/CustomTargetStyles/#source-code-references","text":"XComGameState_Ability_CH.uc:1-30 X2AbilityTemplate.uc:262 XComGameState_Ability.uc:284","title":"Source code references"},{"location":"tactical/DamageCalc_ArmorBeforeShield/","text":"DamageCalc_ArmorBeforeShield Tracking Issue: #743 By default, shields are damaged before any damage is mitigated by armor. This is fine in vanilla when shields are rare, but becomes an issue in modded campaigns where 'shields' are turned into 'ablative' hit points that provide a buffer before units become wounded and suffer red fog. Increasing ablative is often a non-optimal choice because it can make the the soldier's armor pips become redundant. This change adds an optional config variable (XComGameCore.ini) that other mods or the player can enable. When enabled, it changes the TakeDamage event inside XComGameState_Unit to handle armor mitigation and apply any shredding to the armor before moving on to shields. Shield-bypassing damage such as Psi or EMP damage behaves as normal, ignoring armor and shields to hit health. [XComGame.X2Effect_ApplyWeaponDamage] ; Issue 743 ; Set to false/commented out if you want damage to hit shields/ablative, then armor, then health (vanilla behaviour) ; Set to true/uncomment it if you want damage to hit armor, then shield/ablative, then health ;ARMOR_BEFORE_SHIELD=true Source code references XComGameState_Unit.uc:6464-6484","title":"DamageCalc_ArmorBeforeShield"},{"location":"tactical/DamageCalc_ArmorBeforeShield/#damagecalc_armorbeforeshield","text":"Tracking Issue: #743 By default, shields are damaged before any damage is mitigated by armor. This is fine in vanilla when shields are rare, but becomes an issue in modded campaigns where 'shields' are turned into 'ablative' hit points that provide a buffer before units become wounded and suffer red fog. Increasing ablative is often a non-optimal choice because it can make the the soldier's armor pips become redundant. This change adds an optional config variable (XComGameCore.ini) that other mods or the player can enable. When enabled, it changes the TakeDamage event inside XComGameState_Unit to handle armor mitigation and apply any shredding to the armor before moving on to shields. Shield-bypassing damage such as Psi or EMP damage behaves as normal, ignoring armor and shields to hit health. [XComGame.X2Effect_ApplyWeaponDamage] ; Issue 743 ; Set to false/commented out if you want damage to hit shields/ablative, then armor, then health (vanilla behaviour) ; Set to true/uncomment it if you want damage to hit armor, then shield/ablative, then health ;ARMOR_BEFORE_SHIELD=true","title":"DamageCalc_ArmorBeforeShield"},{"location":"tactical/DamageCalc_ArmorBeforeShield/#source-code-references","text":"XComGameState_Unit.uc:6464-6484","title":"Source code references"},{"location":"tactical/DamageEffectForDamageModifierHooks/","text":"DamageEffectForDamageModifierHooks Tracking Issue: #1305 Adds an improved version of GetAttackingDamageModifier() that always gets the Damage Effect. The regular version of the hook gets the Damage Effect only when the effect is getting applied, which prevents the hook from being able to provide an accurate contextual damage preview. Source code references X2Effect_Persistent.uc:663-666","title":"DamageEffectForDamageModifierHooks"},{"location":"tactical/DamageEffectForDamageModifierHooks/#damageeffectfordamagemodifierhooks","text":"Tracking Issue: #1305 Adds an improved version of GetAttackingDamageModifier() that always gets the Damage Effect. The regular version of the hook gets the Damage Effect only when the effect is getting applied, which prevents the hook from being able to provide an accurate contextual damage preview.","title":"DamageEffectForDamageModifierHooks"},{"location":"tactical/DamageEffectForDamageModifierHooks/#source-code-references","text":"X2Effect_Persistent.uc:663-666","title":"Source code references"},{"location":"tactical/DisableAimAssist/","text":"DisableAimAssist Tracking Issue: #1228 This feature adds a config variable that acts as a master switch for disabling all instances of Aim Assist. Source code references X2AbilityToHitCalc_StandardAim.uc:860-861 XComGame.ini:286","title":"DisableAimAssist"},{"location":"tactical/DisableAimAssist/#disableaimassist","text":"Tracking Issue: #1228 This feature adds a config variable that acts as a master switch for disabling all instances of Aim Assist.","title":"DisableAimAssist"},{"location":"tactical/DisableAimAssist/#source-code-references","text":"X2AbilityToHitCalc_StandardAim.uc:860-861 XComGame.ini:286","title":"Source code references"},{"location":"tactical/DisableExtraLOSCheckForPoison/","text":"DisableExtraLOSCheckForPoison Tracking Issue: #669 When true, this option fixes poison so that clouds of it apply to all tiles that are highlighted in targeting. Source code references CHHelpers.uc:226-228 XComGame.ini:38","title":"DisableExtraLOSCheckForPoison"},{"location":"tactical/DisableExtraLOSCheckForPoison/#disableextraloscheckforpoison","text":"Tracking Issue: #669 When true, this option fixes poison so that clouds of it apply to all tiles that are highlighted in targeting.","title":"DisableExtraLOSCheckForPoison"},{"location":"tactical/DisableExtraLOSCheckForPoison/#source-code-references","text":"CHHelpers.uc:226-228 XComGame.ini:38","title":"Source code references"},{"location":"tactical/DisableExtraLOSCheckForSmoke/","text":"DisableExtraLOSCheckForSmoke Tracking Issue: #669 When true, this option fixes smoke so that it applies to all tiles that are highlighted in targeting (as per the Reliable Smoke mod). Source code references CHHelpers.uc:221-223 XComGame.ini:35","title":"DisableExtraLOSCheckForSmoke"},{"location":"tactical/DisableExtraLOSCheckForSmoke/#disableextraloscheckforsmoke","text":"Tracking Issue: #669 When true, this option fixes smoke so that it applies to all tiles that are highlighted in targeting (as per the Reliable Smoke mod).","title":"DisableExtraLOSCheckForSmoke"},{"location":"tactical/DisableExtraLOSCheckForSmoke/#source-code-references","text":"CHHelpers.uc:221-223 XComGame.ini:35","title":"Source code references"},{"location":"tactical/DisplayCustomOverwatchActionPointOnUnitFlag/","text":"DisplayCustomOverwatchActionPointOnUnitFlag Tracking Issue: #724 Tags: compatibility The base XCOM 2 behavior is to show an Overwatch \"eye\" icon under the unit flag only if the soldier has at least one \"overwatch\" Reserve Action Point. The icon is not displayed for Pistol Overwatch. This change addresses that issue, and also allows mods that add weapons with custom Overwatch Action Point to specify that action point name in XComGame.ini: [XComGame.CHHelpers] +ValidReserveAPForUnitFlag = \"overwatch\" +ValidReserveAPForUnitFlag = \"pistoloverwatch\" Compatibility: If you override UIUnitFlag::RealizeOverwatch , your code may undo this change. Source code references UIUnitFlag.uc:1699-1712","title":"DisplayCustomOverwatchActionPointOnUnitFlag"},{"location":"tactical/DisplayCustomOverwatchActionPointOnUnitFlag/#displaycustomoverwatchactionpointonunitflag","text":"Tracking Issue: #724 Tags: compatibility The base XCOM 2 behavior is to show an Overwatch \"eye\" icon under the unit flag only if the soldier has at least one \"overwatch\" Reserve Action Point. The icon is not displayed for Pistol Overwatch. This change addresses that issue, and also allows mods that add weapons with custom Overwatch Action Point to specify that action point name in XComGame.ini: [XComGame.CHHelpers] +ValidReserveAPForUnitFlag = \"overwatch\" +ValidReserveAPForUnitFlag = \"pistoloverwatch\" Compatibility: If you override UIUnitFlag::RealizeOverwatch , your code may undo this change.","title":"DisplayCustomOverwatchActionPointOnUnitFlag"},{"location":"tactical/DisplayCustomOverwatchActionPointOnUnitFlag/#source-code-references","text":"UIUnitFlag.uc:1699-1712","title":"Source code references"},{"location":"tactical/DrawDebugLabels/","text":"DrawDebugLabels Tracking Issue: #490 Tags: events Allow mods to draw their own debug labels to the screen. Make sure to set 'bDrawDebugLabels = true' in XComGame.ini for this event to start triggering. DrawDebugLabels event Param Value EventID DrawDebugLabels EventData Canvas EventSource XComTacticalController NewGameState none Listener template static function EventListenerReturn OnDrawDebugLabels(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComTacticalController TacticalController; local Canvas kCanvas; TacticalController = XComTacticalController(EventSource); kCanvas = Canvas(EventData); // Your code here return ELR_NoInterrupt; } Source code references XComTacticalController.uc:1018-1027 XComGame.ini:272","title":"DrawDebugLabels"},{"location":"tactical/DrawDebugLabels/#drawdebuglabels","text":"Tracking Issue: #490 Tags: events Allow mods to draw their own debug labels to the screen. Make sure to set 'bDrawDebugLabels = true' in XComGame.ini for this event to start triggering.","title":"DrawDebugLabels"},{"location":"tactical/DrawDebugLabels/#drawdebuglabels-event","text":"Param Value EventID DrawDebugLabels EventData Canvas EventSource XComTacticalController NewGameState none","title":"DrawDebugLabels event"},{"location":"tactical/DrawDebugLabels/#listener-template","text":"static function EventListenerReturn OnDrawDebugLabels(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComTacticalController TacticalController; local Canvas kCanvas; TacticalController = XComTacticalController(EventSource); kCanvas = Canvas(EventData); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/DrawDebugLabels/#source-code-references","text":"XComTacticalController.uc:1018-1027 XComGame.ini:272","title":"Source code references"},{"location":"tactical/ExtraDamageModifierHooks/","text":"ExtraDamageModifierHooks Tracking Issue: #923 Tags: compatibility The base game does not work well with certain types of damage-modifier effects. In particular, attempts to implement multiplicative, percentage-based damage modifiers are hindered by the fact that the overall calculated damage depends on the order in which such effects are applied to a unit. The following hooks solve the problem by applying configured damage modifiers either before or after the \"default\" behaviour, which is where normal flat damage is added or subtracted. As long as all the effects using these hooks are commutative with one another, the final damage result will be independent of the order in which effects are applied. Currently, the difference between the original damage value and the modified damage value is truncated. That allows the following behavior: If the modified damage is lower than the original, it is effectively rounded up. If higher, it is rounded down. In summary: use these hooks to apply multiplicative damage modifiers such as percent-based increases and reductions. The pre-default hooks are for multipliers that should apply to just the calculated base damage, while the post-default hooks apply modifiers to the calculated damage after all the additive modifiers have been applied. Important Your implementations of these functions should return the amount of damage your effect is adding or subtracting, not the overall damage. The value you return will be added to CurrentDamage . Pre-default hooks The \"pre-default\" hooks are applied immediately after the base damage has been calculated. This allows mods to apply damage modifiers based on the base damage before any flat damage modifiers are applied. The following hook is used for effects that are applied to the attacker: float GetPreDefaultAttackingDamageModifier_CH( XComGameState_Effect EffectState, XComGameState_Unit SourceUnit, Damageable Target, XComGameState_Ability AbilityState, const out EffectAppliedData ApplyEffectParameters, float CurrentDamage, XComGameState NewGameState) This next one is used for effects that are applied to the target (the \"defender\"): float GetPreDefaultDefendingDamageModifier_CH( XComGameState_Effect EffectState, XComGameState_Unit SourceUnit, XComGameState_Unit TargetUnit, XComGameState_Ability AbilityState, const out EffectAppliedData ApplyEffectParameters, float CurrentDamage, XComGameState NewGameState) The arguments are largely self explanatory, but note that CurrentDamage is a float, as is the return value. CurrentDamage is the current total damage, which is the base damage with any preceding damage modifiers already applied. Post-default hooks Once the pre-default modifiers have been applied, the traditional (flat) damage modifiers are processed as per existing base game behaviour. When that has finished, the \"post-default\" hooks are applied. This allows mods to apply damage modifiers to the total damage including any bonus flat damage. The following hook is used for effects that are applied to the attacker: float GetPostDefaultAttackingDamageModifier_CH( XComGameState_Effect EffectState, XComGameState_Unit SourceUnit, Damageable Target, XComGameState_Ability AbilityState, const out EffectAppliedData ApplyEffectParameters, float CurrentDamage, XComGameState NewGameState) This next one is used for effects that are applied to the target (the \"defender\"): float GetPostDefaultDefendingDamageModifier_CH( XComGameState_Effect EffectState, XComGameState_Unit SourceUnit, XComGameState_Unit TargetUnit, XComGameState_Ability AbilityState, const out EffectAppliedData ApplyEffectParameters, float CurrentDamage, XComGameState NewGameState) The arguments are largely self explanatory, but note that CurrentDamage is a float, as is the return value. CurrentDamage is the current total damage. Compatibility If you implement any of these functions in your own effects, they will do nothing unless the game is using version 1.22.0+ of the Community Highlander. Do note that these are applied along with any traditional damage modifiers your effect has, so if you want your effects to work with older versions of the Community Highlander and setups without any Community Highlander at all, then you should guard the old damage modifier functions with a check for these new functions, e.g. function int GetAttackingDamageModifier(...) { if (Function'XComGame.X2Effect_Persistent.GetPreDefaultAttackingDamageModifier_CH' != none) { // Using the new hooks, so skip the old implementation return 0; } // Continue with old implementation here ... } Source code references X2Effect_Persistent.uc:708-829","title":"ExtraDamageModifierHooks"},{"location":"tactical/ExtraDamageModifierHooks/#extradamagemodifierhooks","text":"Tracking Issue: #923 Tags: compatibility The base game does not work well with certain types of damage-modifier effects. In particular, attempts to implement multiplicative, percentage-based damage modifiers are hindered by the fact that the overall calculated damage depends on the order in which such effects are applied to a unit. The following hooks solve the problem by applying configured damage modifiers either before or after the \"default\" behaviour, which is where normal flat damage is added or subtracted. As long as all the effects using these hooks are commutative with one another, the final damage result will be independent of the order in which effects are applied. Currently, the difference between the original damage value and the modified damage value is truncated. That allows the following behavior: If the modified damage is lower than the original, it is effectively rounded up. If higher, it is rounded down. In summary: use these hooks to apply multiplicative damage modifiers such as percent-based increases and reductions. The pre-default hooks are for multipliers that should apply to just the calculated base damage, while the post-default hooks apply modifiers to the calculated damage after all the additive modifiers have been applied. Important Your implementations of these functions should return the amount of damage your effect is adding or subtracting, not the overall damage. The value you return will be added to CurrentDamage .","title":"ExtraDamageModifierHooks"},{"location":"tactical/ExtraDamageModifierHooks/#pre-default-hooks","text":"The \"pre-default\" hooks are applied immediately after the base damage has been calculated. This allows mods to apply damage modifiers based on the base damage before any flat damage modifiers are applied. The following hook is used for effects that are applied to the attacker: float GetPreDefaultAttackingDamageModifier_CH( XComGameState_Effect EffectState, XComGameState_Unit SourceUnit, Damageable Target, XComGameState_Ability AbilityState, const out EffectAppliedData ApplyEffectParameters, float CurrentDamage, XComGameState NewGameState) This next one is used for effects that are applied to the target (the \"defender\"): float GetPreDefaultDefendingDamageModifier_CH( XComGameState_Effect EffectState, XComGameState_Unit SourceUnit, XComGameState_Unit TargetUnit, XComGameState_Ability AbilityState, const out EffectAppliedData ApplyEffectParameters, float CurrentDamage, XComGameState NewGameState) The arguments are largely self explanatory, but note that CurrentDamage is a float, as is the return value. CurrentDamage is the current total damage, which is the base damage with any preceding damage modifiers already applied.","title":"Pre-default hooks"},{"location":"tactical/ExtraDamageModifierHooks/#post-default-hooks","text":"Once the pre-default modifiers have been applied, the traditional (flat) damage modifiers are processed as per existing base game behaviour. When that has finished, the \"post-default\" hooks are applied. This allows mods to apply damage modifiers to the total damage including any bonus flat damage. The following hook is used for effects that are applied to the attacker: float GetPostDefaultAttackingDamageModifier_CH( XComGameState_Effect EffectState, XComGameState_Unit SourceUnit, Damageable Target, XComGameState_Ability AbilityState, const out EffectAppliedData ApplyEffectParameters, float CurrentDamage, XComGameState NewGameState) This next one is used for effects that are applied to the target (the \"defender\"): float GetPostDefaultDefendingDamageModifier_CH( XComGameState_Effect EffectState, XComGameState_Unit SourceUnit, XComGameState_Unit TargetUnit, XComGameState_Ability AbilityState, const out EffectAppliedData ApplyEffectParameters, float CurrentDamage, XComGameState NewGameState) The arguments are largely self explanatory, but note that CurrentDamage is a float, as is the return value. CurrentDamage is the current total damage.","title":"Post-default hooks"},{"location":"tactical/ExtraDamageModifierHooks/#compatibility","text":"If you implement any of these functions in your own effects, they will do nothing unless the game is using version 1.22.0+ of the Community Highlander. Do note that these are applied along with any traditional damage modifiers your effect has, so if you want your effects to work with older versions of the Community Highlander and setups without any Community Highlander at all, then you should guard the old damage modifier functions with a check for these new functions, e.g. function int GetAttackingDamageModifier(...) { if (Function'XComGame.X2Effect_Persistent.GetPreDefaultAttackingDamageModifier_CH' != none) { // Using the new hooks, so skip the old implementation return 0; } // Continue with old implementation here ... }","title":"Compatibility"},{"location":"tactical/ExtraDamageModifierHooks/#source-code-references","text":"X2Effect_Persistent.uc:708-829","title":"Source code references"},{"location":"tactical/FinalizePlayerStateForTacticalMusic/","text":"FinalizePlayerStateForTacticalMusic Tracking Issue: #1153 Tags: events Determines the next music cue for changing music during tactical engagements. This determination is done by looking at multiple factors such as enemy alert level and how many units XCom can see. To do this, it requires knowledge of which player team is active. To allow for better compatibility between mods which manage player activity and mods which manage sound options, there is one event which will allow to override the player state or its parameters. FinalizePlayerStateForTacticalMusic event Param Value EventID FinalizePlayerStateForTacticalMusic EventData XComLWTuple EventSource XComTacticalSoundManager NewGameState none Tuple contents Index Name Type Direction 0 PlayerState XComGameState_Player inout Listener template static function EventListenerReturn OnFinalizePlayerStateForTacticalMusic(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComTacticalSoundManager SoundManager; local XComLWTuple Tuple; local XComGameState_Player PlayerState; SoundManager = XComTacticalSoundManager(EventSource); Tuple = XComLWTuple(EventData); PlayerState = XComGameState_Player(Tuple.Data[0].o); // Your code here Tuple.Data[0].o = PlayerState; return ELR_NoInterrupt; } Source code references XComTacticalSoundManager.uc:429-447","title":"FinalizePlayerStateForTacticalMusic"},{"location":"tactical/FinalizePlayerStateForTacticalMusic/#finalizeplayerstatefortacticalmusic","text":"Tracking Issue: #1153 Tags: events Determines the next music cue for changing music during tactical engagements. This determination is done by looking at multiple factors such as enemy alert level and how many units XCom can see. To do this, it requires knowledge of which player team is active. To allow for better compatibility between mods which manage player activity and mods which manage sound options, there is one event which will allow to override the player state or its parameters.","title":"FinalizePlayerStateForTacticalMusic"},{"location":"tactical/FinalizePlayerStateForTacticalMusic/#finalizeplayerstatefortacticalmusic-event","text":"Param Value EventID FinalizePlayerStateForTacticalMusic EventData XComLWTuple EventSource XComTacticalSoundManager NewGameState none","title":"FinalizePlayerStateForTacticalMusic event"},{"location":"tactical/FinalizePlayerStateForTacticalMusic/#tuple-contents","text":"Index Name Type Direction 0 PlayerState XComGameState_Player inout","title":"Tuple contents"},{"location":"tactical/FinalizePlayerStateForTacticalMusic/#listener-template","text":"static function EventListenerReturn OnFinalizePlayerStateForTacticalMusic(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComTacticalSoundManager SoundManager; local XComLWTuple Tuple; local XComGameState_Player PlayerState; SoundManager = XComTacticalSoundManager(EventSource); Tuple = XComLWTuple(EventData); PlayerState = XComGameState_Player(Tuple.Data[0].o); // Your code here Tuple.Data[0].o = PlayerState; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/FinalizePlayerStateForTacticalMusic/#source-code-references","text":"XComTacticalSoundManager.uc:429-447","title":"Source code references"},{"location":"tactical/ForceReapplyOnRefresh/","text":"ForceReapplyOnRefresh Tracking Issue: #475 The bForceReapplyOnRefresh flag allows effects that use or extend the X2Effect_PersistentStatChange class to be reapplied to a unit that is already under the influence of this effect. For example, it can be used to make sure Flashbangs remove Overwatch from units that are already disoriented. Source code references X2Effect_PersistentStatChange.uc:13-19","title":"ForceReapplyOnRefresh"},{"location":"tactical/ForceReapplyOnRefresh/#forcereapplyonrefresh","text":"Tracking Issue: #475 The bForceReapplyOnRefresh flag allows effects that use or extend the X2Effect_PersistentStatChange class to be reapplied to a unit that is already under the influence of this effect. For example, it can be used to make sure Flashbangs remove Overwatch from units that are already disoriented.","title":"ForceReapplyOnRefresh"},{"location":"tactical/ForceReapplyOnRefresh/#source-code-references","text":"X2Effect_PersistentStatChange.uc:13-19","title":"Source code references"},{"location":"tactical/GetAdditionalHitModifiers/","text":"GetAdditionalHitModifiers Tracking Issue: #1271 This feature adds a method that can be used by subclasses to apply additional hit modifiers without having to override and copy paste the entire GetHitChance() function. Override this method in subclasses to apply additional hit modifiers. Using the existing AddModifier() function is recommended, for example: AddModifier(10, \"localized reason\", m_ShotBreakdown, eHit_Success, bDebugLog); Source code references X2AbilityToHitCalc_StandardAim.uc:716-719 X2AbilityToHitCalc_StandardAim.uc:1087-1092","title":"GetAdditionalHitModifiers"},{"location":"tactical/GetAdditionalHitModifiers/#getadditionalhitmodifiers","text":"Tracking Issue: #1271 This feature adds a method that can be used by subclasses to apply additional hit modifiers without having to override and copy paste the entire GetHitChance() function. Override this method in subclasses to apply additional hit modifiers. Using the existing AddModifier() function is recommended, for example: AddModifier(10, \"localized reason\", m_ShotBreakdown, eHit_Success, bDebugLog);","title":"GetAdditionalHitModifiers"},{"location":"tactical/GetAdditionalHitModifiers/#source-code-references","text":"X2AbilityToHitCalc_StandardAim.uc:716-719 X2AbilityToHitCalc_StandardAim.uc:1087-1092","title":"Source code references"},{"location":"tactical/GetHitChanceEvents/","text":"GetHitChanceEvents Tracking Issue: #1031 WARNING! Triggering events in X2AbilityToHitCalc::GetHitChance() and other functions called by this function may freeze (hard hang) the game under certain circumstances. In our experiments, the game would hang when the player used a moving melee ability when an event was triggered in UITacticalHUD_AbilityContainer::ConfirmAbility() right above the XComPresentationLayer(Owner.Owner).PopTargetingStates(); line or anywhere further down the script trace, while another event was also triggered in GetHitChance() or anywhere further down the script trace. The game hangs while executing UI code, but it is the event in the To Hit Calculation logic that induces it. The speculation is that triggering events in GetHitChance() somehow corrupts the event manager, or it could be a threading issue. Source code references X2AbilityToHitCalc_StandardAim.uc:332-343","title":"GetHitChanceEvents"},{"location":"tactical/GetHitChanceEvents/#gethitchanceevents","text":"Tracking Issue: #1031 WARNING! Triggering events in X2AbilityToHitCalc::GetHitChance() and other functions called by this function may freeze (hard hang) the game under certain circumstances. In our experiments, the game would hang when the player used a moving melee ability when an event was triggered in UITacticalHUD_AbilityContainer::ConfirmAbility() right above the XComPresentationLayer(Owner.Owner).PopTargetingStates(); line or anywhere further down the script trace, while another event was also triggered in GetHitChance() or anywhere further down the script trace. The game hangs while executing UI code, but it is the event in the To Hit Calculation logic that induces it. The speculation is that triggering events in GetHitChance() somehow corrupts the event manager, or it could be a threading issue.","title":"GetHitChanceEvents"},{"location":"tactical/GetHitChanceEvents/#source-code-references","text":"X2AbilityToHitCalc_StandardAim.uc:332-343","title":"Source code references"},{"location":"tactical/GetStatModifiersFixed/","text":"GetStatModifiersFixed Tracking Issue: #313 Tags: compatibility The base game provides a function native function GetStatModifiers(ECharStatType Stat, out array<XComGameState_Effect> Mods, out array<float> ModValues, optional XComGameStateHistory GameStateHistoryObject); that can be used to identify how much different effects contribute to the calculated stat total. For example, X2AbilityToHitCalc_StandardAim wants to show how many percentage points to-hit or to-crit different effects provide or diminish. However, the function is subtly broken in the presence of multiplicative modifiers ( MODOP_Multiplication or MODOP_PostMultiplication ), where it doesn't return the correct contribution but instead simply returns MultiplicationMod * BaseStat . This makes multiplicative modifiers unusable for eStat_Offense and eStat_CritChance . The Highlander function GetStatModifiersFixed wraps the broken function and fixes the numbers. Additionally, X2AbilityToHitCalc_StandardAim is changed to call this modified function. Compatibility Mods that override/replace X2AbilityToHitCalc_StandardAim:GetHitChance may undo the Highlander's changes and use the broken function. In particular, XModBase versions prior to 2.0.2 are known to undo this fix . It is recommended that mods using XModBase upgrade to 2.0.2, and otherwise affected mods check whether GetStatModifiersFixed exists and call it instead: if (Function'XComGame.XComGameState_Unit.GetStatModifiersFixed' != none) { // call GetStatModifiersFixed } else { // call GetStatModifiers } Source code references XComGameState_Unit.uc:7244-7279 X2AbilityToHitCalc_StandardAim.uc:417 X2AbilityToHitCalc_StandardAim.uc:465 X2AbilityToHitCalc_StandardAim.uc:590","title":"GetStatModifiersFixed"},{"location":"tactical/GetStatModifiersFixed/#getstatmodifiersfixed","text":"Tracking Issue: #313 Tags: compatibility The base game provides a function native function GetStatModifiers(ECharStatType Stat, out array<XComGameState_Effect> Mods, out array<float> ModValues, optional XComGameStateHistory GameStateHistoryObject); that can be used to identify how much different effects contribute to the calculated stat total. For example, X2AbilityToHitCalc_StandardAim wants to show how many percentage points to-hit or to-crit different effects provide or diminish. However, the function is subtly broken in the presence of multiplicative modifiers ( MODOP_Multiplication or MODOP_PostMultiplication ), where it doesn't return the correct contribution but instead simply returns MultiplicationMod * BaseStat . This makes multiplicative modifiers unusable for eStat_Offense and eStat_CritChance . The Highlander function GetStatModifiersFixed wraps the broken function and fixes the numbers. Additionally, X2AbilityToHitCalc_StandardAim is changed to call this modified function.","title":"GetStatModifiersFixed"},{"location":"tactical/GetStatModifiersFixed/#compatibility","text":"Mods that override/replace X2AbilityToHitCalc_StandardAim:GetHitChance may undo the Highlander's changes and use the broken function. In particular, XModBase versions prior to 2.0.2 are known to undo this fix . It is recommended that mods using XModBase upgrade to 2.0.2, and otherwise affected mods check whether GetStatModifiersFixed exists and call it instead: if (Function'XComGame.XComGameState_Unit.GetStatModifiersFixed' != none) { // call GetStatModifiersFixed } else { // call GetStatModifiers }","title":"Compatibility"},{"location":"tactical/GetStatModifiersFixed/#source-code-references","text":"XComGameState_Unit.uc:7244-7279 X2AbilityToHitCalc_StandardAim.uc:417 X2AbilityToHitCalc_StandardAim.uc:465 X2AbilityToHitCalc_StandardAim.uc:590","title":"Source code references"},{"location":"tactical/GrenadesRequiringUnitsOnTargetedTiles/","text":"GrenadesRequiringUnitsOnTargetedTiles Tracking Issue: #669 An array of grenade template names for which only units actually on painted tiles should be affected by that grenade. Main example is smoke, since only units on smoked tiles should get the effect. Source code references CHHelpers.uc:215-218 XComGame.ini:41 X2TargetingMethod_Grenade.uc:221","title":"GrenadesRequiringUnitsOnTargetedTiles"},{"location":"tactical/GrenadesRequiringUnitsOnTargetedTiles/#grenadesrequiringunitsontargetedtiles","text":"Tracking Issue: #669 An array of grenade template names for which only units actually on painted tiles should be affected by that grenade. Main example is smoke, since only units on smoked tiles should get the effect.","title":"GrenadesRequiringUnitsOnTargetedTiles"},{"location":"tactical/GrenadesRequiringUnitsOnTargetedTiles/#source-code-references","text":"CHHelpers.uc:215-218 XComGame.ini:41 X2TargetingMethod_Grenade.uc:221","title":"Source code references"},{"location":"tactical/HasHeightAdvantageOverride/","text":"HasHeightAdvantageOverride Tracking Issue: #851 This feature allows mods to override whether a unit has height advantage over another unit, gaining various tactical benefits. Normally this override would have been implemented as an event, but events in To Hit Chance Calculation logic can cause issues, see GetHitChanceEvents , so the delegates system is used instead. How to use Implement the following code in your mod's X2DownloadableContentInfo class: static event OnPostTemplatesCreated() { local CHHelpers CHHelpersObj; CHHelpersObj = class'CHHelpers'.static.GetCDO(); if (CHHelpersObj != none) { CHHelpersObj.AddOverrideHasHeightAdvantageCallback(OverrideHasHeightAdvantage); } } // To avoid crashes associated with garbage collection failure when transitioning between Tactical and Strategy, // this function must be bound to the ClassDefaultObject of your class. Having this function in a class that // `extends X2DownloadableContentInfo` is the easiest way to ensure that. static private function EHLDelegateReturn OverrideHasHeightAdvantage(XComGameState_Unit Attacker, XComGameState_Unit TargetUnit, out int bHasHeightAdvantage) { // Optionally modify bHasHeightAdvantage here. // `bHasHeightAdvantage` is `0` if the `Attacker` does not have height advantage over the `TargetUnit`, // and `1` if height advantage is present. // Return EHLDR_NoInterrupt or EHLDR_InterruptDelegates depending on // if you want to allow other delegates to run after yours // and potentially modify bHasHeightAdvantage further. return EHLDR_NoInterrupt; } Delegate Priority You can optionally specify callback Priority. CHHelpersObj.AddOverrideHasHeightAdvantageCallback(OverrideHasHeightAdvantage, 45); Delegates with higher Priority value are executed first. Delegates with the same Priority are executed in the order they were added to CHHelpers, which would normally be the same as DLCRunOrder . This function will return true if the delegate was successfully registered. Removing Delegates If necessary, it's possible to remove a delegate. CHHelpersObj.RemoveOverrideHasHeightAdvantageCallback(OverrideHasHeightAdvantage); The function will return true if the Callback was successfully deleted, return false otherwise. Source code references XComGameState_Unit.uc:1162-1197 CHHelpers.uc:925-934 CHHelpers.uc:972-978","title":"HasHeightAdvantageOverride"},{"location":"tactical/HasHeightAdvantageOverride/#hasheightadvantageoverride","text":"Tracking Issue: #851 This feature allows mods to override whether a unit has height advantage over another unit, gaining various tactical benefits. Normally this override would have been implemented as an event, but events in To Hit Chance Calculation logic can cause issues, see GetHitChanceEvents , so the delegates system is used instead.","title":"HasHeightAdvantageOverride"},{"location":"tactical/HasHeightAdvantageOverride/#how-to-use","text":"Implement the following code in your mod's X2DownloadableContentInfo class: static event OnPostTemplatesCreated() { local CHHelpers CHHelpersObj; CHHelpersObj = class'CHHelpers'.static.GetCDO(); if (CHHelpersObj != none) { CHHelpersObj.AddOverrideHasHeightAdvantageCallback(OverrideHasHeightAdvantage); } } // To avoid crashes associated with garbage collection failure when transitioning between Tactical and Strategy, // this function must be bound to the ClassDefaultObject of your class. Having this function in a class that // `extends X2DownloadableContentInfo` is the easiest way to ensure that. static private function EHLDelegateReturn OverrideHasHeightAdvantage(XComGameState_Unit Attacker, XComGameState_Unit TargetUnit, out int bHasHeightAdvantage) { // Optionally modify bHasHeightAdvantage here. // `bHasHeightAdvantage` is `0` if the `Attacker` does not have height advantage over the `TargetUnit`, // and `1` if height advantage is present. // Return EHLDR_NoInterrupt or EHLDR_InterruptDelegates depending on // if you want to allow other delegates to run after yours // and potentially modify bHasHeightAdvantage further. return EHLDR_NoInterrupt; }","title":"How to use"},{"location":"tactical/HasHeightAdvantageOverride/#delegate-priority","text":"You can optionally specify callback Priority. CHHelpersObj.AddOverrideHasHeightAdvantageCallback(OverrideHasHeightAdvantage, 45); Delegates with higher Priority value are executed first. Delegates with the same Priority are executed in the order they were added to CHHelpers, which would normally be the same as DLCRunOrder . This function will return true if the delegate was successfully registered.","title":"Delegate Priority"},{"location":"tactical/HasHeightAdvantageOverride/#removing-delegates","text":"If necessary, it's possible to remove a delegate. CHHelpersObj.RemoveOverrideHasHeightAdvantageCallback(OverrideHasHeightAdvantage); The function will return true if the Callback was successfully deleted, return false otherwise.","title":"Removing Delegates"},{"location":"tactical/HasHeightAdvantageOverride/#source-code-references","text":"XComGameState_Unit.uc:1162-1197 CHHelpers.uc:925-934 CHHelpers.uc:972-978","title":"Source code references"},{"location":"tactical/ImproveAIAreaOfEffectProfiles/","text":"ImproveAIAreaOfEffectProfiles Tracking Issue: #1369 Setting bTestTargetEffectsApply on AOE Profiles in XComAI is supposed to filter the list of acceptable targets for a given Area of Effect ability by looking through the targeting conditions on each effect and checking whether or not the prospective targets are immune to the damage (this is done in X2Effect::TargetIsValidForAbility). However, this feature was not built to handle grenade templates and the logic for multitargeteffects was also being short-circuited due to bValid not being reset between each unit (i.e. so if a single unit passed the check, all subsequent units in the AOE were being added to the supposedly-filtered target list). Source code references XGAIBehavior.uc:6783-6789","title":"ImproveAIAreaOfEffectProfiles"},{"location":"tactical/ImproveAIAreaOfEffectProfiles/#improveaiareaofeffectprofiles","text":"Tracking Issue: #1369 Setting bTestTargetEffectsApply on AOE Profiles in XComAI is supposed to filter the list of acceptable targets for a given Area of Effect ability by looking through the targeting conditions on each effect and checking whether or not the prospective targets are immune to the damage (this is done in X2Effect::TargetIsValidForAbility). However, this feature was not built to handle grenade templates and the logic for multitargeteffects was also being short-circuited due to bValid not being reset between each unit (i.e. so if a single unit passed the check, all subsequent units in the AOE were being added to the supposedly-filtered target list).","title":"ImproveAIAreaOfEffectProfiles"},{"location":"tactical/ImproveAIAreaOfEffectProfiles/#source-code-references","text":"XGAIBehavior.uc:6783-6789","title":"Source code references"},{"location":"tactical/KismetGameStateMatinee/","text":"KismetGameStateMatinee Tracking Issue: #837 Tags: events Allow mods to insert their logic next to matinees triggered by mission kismet, by using ELD_OnVisualizationBlockStarted / ELD_OnVisualizationBlockCompleted or PreBuildVisualizationFn / PostBuildVisualizationFn . The triggering SeqAct_PlayGameStateMatinee can be fetched using the following code: XComGameStateContext_Kismet(GameState.GetContext()).FindSequenceOp() The SeqAct isn't passed as the event source as there is no definitive answer (at the time of implementation of this event) to whether passing kismet objects in events is safe in terms of the replay functionality or not. KismetGameStateMatinee event Param Value EventID KismetGameStateMatinee EventData none EventSource none NewGameState yes Listener template static function EventListenerReturn OnKismetGameStateMatinee(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { // Your code here return ELR_NoInterrupt; } Source code references SeqAct_PlayGameStateMatinee.uc:53-73","title":"KismetGameStateMatinee"},{"location":"tactical/KismetGameStateMatinee/#kismetgamestatematinee","text":"Tracking Issue: #837 Tags: events Allow mods to insert their logic next to matinees triggered by mission kismet, by using ELD_OnVisualizationBlockStarted / ELD_OnVisualizationBlockCompleted or PreBuildVisualizationFn / PostBuildVisualizationFn . The triggering SeqAct_PlayGameStateMatinee can be fetched using the following code: XComGameStateContext_Kismet(GameState.GetContext()).FindSequenceOp() The SeqAct isn't passed as the event source as there is no definitive answer (at the time of implementation of this event) to whether passing kismet objects in events is safe in terms of the replay functionality or not.","title":"KismetGameStateMatinee"},{"location":"tactical/KismetGameStateMatinee/#kismetgamestatematinee-event","text":"Param Value EventID KismetGameStateMatinee EventData none EventSource none NewGameState yes","title":"KismetGameStateMatinee event"},{"location":"tactical/KismetGameStateMatinee/#listener-template","text":"static function EventListenerReturn OnKismetGameStateMatinee(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/KismetGameStateMatinee/#source-code-references","text":"SeqAct_PlayGameStateMatinee.uc:53-73","title":"Source code references"},{"location":"tactical/LootTableAPI/","text":"LootTableAPI Tracking Issue: #8 Unprivates LootTables and adds convenience functions for common OPTC loot table operations. Refresher on loot tables Consider the simplified struct definitions taken from X2TacticalGameRulesetDataStructures : struct native LootTableEntry { var int Chance; var int RollGroup; var int MinCount, MaxCount; // Modifier on the chance, multiplicatively applied for each existing Item of type TemplateName acquired: // TotalChance = Chance * ChanceModPerExistingItem ^ NumExistingItems var float ChanceModPerExistingItem; // NOTE: these two are mutually exclusive, so only one should ever be filled in for a given entry var name TemplateName; var name TableRef; }; struct native LootTable { var name TableName; var array<LootTableEntry> Loots; }; When a unit template says \"hey, I drop this kind of loot\", it references a given LootTable by name. For the common random loot, a random unit is designated as a loot carrier at the start of the mission and its loot is rolled. The game then looks at the Loots entries and for every distinct RollGroup the game rolls a number in the half-open interval [0; 100[ (largest possible number is 99) to choose the item from that RollGroup . The game does this by iterating through the LootTableEntry entries with the current RollGroup and subtracting its Chance (after applying ChanceModPerExistingItem ) from the current chance. If this causes the current chance to go below 0 , this entry has been chosen and the game moves on to the next RollGroup . This has a number of non-intuitive consequences: Within the same RollGroup s, the chances are not independent; the game may choose 0 or 1 entries from that group. If the sum of chances in a RollGroup is x < 100 , there is a 100 - x percent chance that no entry is chosen and this RollGroup doesn't roll anything. If the sum of chances is x = 100 , then every entry will have a percent chance to be chosen identical to the Chance of the entry. If the sum of chances is x > 100 , then the latter entries will actually have a lower chance. Consider entries in the same roll group with chances 90 , 20 , 10 : The first entry will be chosen 9/10 times, the second 1/10 times, and the third never! We will discuss later what this means for mods. When an entry has been chosen, the game generates between MinCount and MaxCount of the item listed in TemplateName , if it is non-empty -- otherwise, the game invokes the aforedescribed algorithm recursively with the table referenced by name in TableRef . New APIs First and foremost, you need a loot table manager to work with. If you are in a place before templates are validated (template creation, OnPostTemplatesCreated ), the loot table manager doesn't exist yet and you need to operate on the ClassDefaultObject ; otherwise just request the loot table manager with the singleton accessor: // OPTC or template creation LootManager = X2LootTableManager(class'XComEngine'.static.FindClassDefaultObject(\"XComGame.X2LootTableManager\")); // Otherwise LootManager = class'X2LootTableManager'.static.GetLootTableManager(); The OPTC context is going to be the most common one, so the below documentation assumes that it's going to be used. LootTables This feature unprivates the otherwise config -only LootTables array. You can pretty much change anything there. If your code runs after OnPostTemplatesCreated returns, ensure to call InitLootTables if you add/remove/move around tables as a whole (the game maintains a name->index lookup for efficiency). RecalculateLootTableChanceStatic public static function RecalculateLootTableChanceStatic(name TableName, bool bEquallyDistributed = false); A non-static variant for the runtime context also exists: RecalculateLootTableChance Changes the chances for every entry in the table referred to by TableName so that the chances of every RollGroup add up to 100 . If bEquallyDistributed is true , all chances within a roll group will be equal, otherwise the proportions between the chances are maintained. This is a useful function for when you just want to add some items to existing roll groups of existing tables. Your items will naturally be placed at the end of the array, so according to consequence 4, your items might never be rolled. Calling this function makes sure your items will have a proportional chance to be rolled. Warning: Some of the latter functions recalculate chances for a given roll group implicitly unless opted out of. Warning: Some RollGroups have chance sums much lower than 100 so that only sometimes an item from that group drops. Carelessly calling RecalculateLootTableChance or forgetting to opt out of recalculating may cause showers of rare loot! AddEntryStatic/RemoveEntryStatic public static function AddEntryStatic(name TableName, LootTableEntry TableEntry, optional bool bRecalculateChances = true); public static function RemoveEntryStatic(name TableName, LootTableEntry TableEntry, optional bool bRecalculateChances = true); Non-static variants for the runtime context also exist: AddEntry , Remove Adds the entry to the given loot table, or removes it. Unless bRecalculateChances is set to false , also recalculates the chances for the entry's RollGroup so that they sum up to 100. AddLootTableStatic/RemoveLootTableStatic Actually, I have no idea why they exist and they probably don't do what you want them to. Don't use them. If you do, also call InitLootTables on the ClassDefaultObject . Example: // Adds M2 and M3 to ADVENT mid- and end-game loot, respectively static event OnPostTemplatesCreated() { local LootTableEntry M2Entry, M3Entry; M2Entry.Chance = 20; M2Entry.MinCount = 1; M2Entry.MaxCount = 1; M2Entry.TemplateName = 'AdventGremlinM2'; // RollGroup 1 is 100% a random Weapon Upgrade. This turns it into 20% Gremlin, 80% upgrade. M2Entry.RollGroup = 1; M3Entry = M2Entry; M3Entry.TemplateName = 'AdventGremlinM3'; class'X2LootTableManager'.static.AddEntryStatic('ADVENTMidTimedLoot', M2Entry, true); class'X2LootTableManager'.static.AddEntryStatic('ADVENTLateTimedLoot', M3Entry, true); } More example: Musashis RPG Overhaul uses this feature. Feel free to peruse its source code! Source code references X2LootTable.uc:25-161","title":"LootTableAPI"},{"location":"tactical/LootTableAPI/#loottableapi","text":"Tracking Issue: #8 Unprivates LootTables and adds convenience functions for common OPTC loot table operations.","title":"LootTableAPI"},{"location":"tactical/LootTableAPI/#refresher-on-loot-tables","text":"Consider the simplified struct definitions taken from X2TacticalGameRulesetDataStructures : struct native LootTableEntry { var int Chance; var int RollGroup; var int MinCount, MaxCount; // Modifier on the chance, multiplicatively applied for each existing Item of type TemplateName acquired: // TotalChance = Chance * ChanceModPerExistingItem ^ NumExistingItems var float ChanceModPerExistingItem; // NOTE: these two are mutually exclusive, so only one should ever be filled in for a given entry var name TemplateName; var name TableRef; }; struct native LootTable { var name TableName; var array<LootTableEntry> Loots; }; When a unit template says \"hey, I drop this kind of loot\", it references a given LootTable by name. For the common random loot, a random unit is designated as a loot carrier at the start of the mission and its loot is rolled. The game then looks at the Loots entries and for every distinct RollGroup the game rolls a number in the half-open interval [0; 100[ (largest possible number is 99) to choose the item from that RollGroup . The game does this by iterating through the LootTableEntry entries with the current RollGroup and subtracting its Chance (after applying ChanceModPerExistingItem ) from the current chance. If this causes the current chance to go below 0 , this entry has been chosen and the game moves on to the next RollGroup . This has a number of non-intuitive consequences: Within the same RollGroup s, the chances are not independent; the game may choose 0 or 1 entries from that group. If the sum of chances in a RollGroup is x < 100 , there is a 100 - x percent chance that no entry is chosen and this RollGroup doesn't roll anything. If the sum of chances is x = 100 , then every entry will have a percent chance to be chosen identical to the Chance of the entry. If the sum of chances is x > 100 , then the latter entries will actually have a lower chance. Consider entries in the same roll group with chances 90 , 20 , 10 : The first entry will be chosen 9/10 times, the second 1/10 times, and the third never! We will discuss later what this means for mods. When an entry has been chosen, the game generates between MinCount and MaxCount of the item listed in TemplateName , if it is non-empty -- otherwise, the game invokes the aforedescribed algorithm recursively with the table referenced by name in TableRef .","title":"Refresher on loot tables"},{"location":"tactical/LootTableAPI/#new-apis","text":"First and foremost, you need a loot table manager to work with. If you are in a place before templates are validated (template creation, OnPostTemplatesCreated ), the loot table manager doesn't exist yet and you need to operate on the ClassDefaultObject ; otherwise just request the loot table manager with the singleton accessor: // OPTC or template creation LootManager = X2LootTableManager(class'XComEngine'.static.FindClassDefaultObject(\"XComGame.X2LootTableManager\")); // Otherwise LootManager = class'X2LootTableManager'.static.GetLootTableManager(); The OPTC context is going to be the most common one, so the below documentation assumes that it's going to be used.","title":"New APIs"},{"location":"tactical/LootTableAPI/#loottables","text":"This feature unprivates the otherwise config -only LootTables array. You can pretty much change anything there. If your code runs after OnPostTemplatesCreated returns, ensure to call InitLootTables if you add/remove/move around tables as a whole (the game maintains a name->index lookup for efficiency).","title":"LootTables"},{"location":"tactical/LootTableAPI/#recalculateloottablechancestatic","text":"public static function RecalculateLootTableChanceStatic(name TableName, bool bEquallyDistributed = false); A non-static variant for the runtime context also exists: RecalculateLootTableChance Changes the chances for every entry in the table referred to by TableName so that the chances of every RollGroup add up to 100 . If bEquallyDistributed is true , all chances within a roll group will be equal, otherwise the proportions between the chances are maintained. This is a useful function for when you just want to add some items to existing roll groups of existing tables. Your items will naturally be placed at the end of the array, so according to consequence 4, your items might never be rolled. Calling this function makes sure your items will have a proportional chance to be rolled. Warning: Some of the latter functions recalculate chances for a given roll group implicitly unless opted out of. Warning: Some RollGroups have chance sums much lower than 100 so that only sometimes an item from that group drops. Carelessly calling RecalculateLootTableChance or forgetting to opt out of recalculating may cause showers of rare loot!","title":"RecalculateLootTableChanceStatic"},{"location":"tactical/LootTableAPI/#addentrystaticremoveentrystatic","text":"public static function AddEntryStatic(name TableName, LootTableEntry TableEntry, optional bool bRecalculateChances = true); public static function RemoveEntryStatic(name TableName, LootTableEntry TableEntry, optional bool bRecalculateChances = true); Non-static variants for the runtime context also exist: AddEntry , Remove Adds the entry to the given loot table, or removes it. Unless bRecalculateChances is set to false , also recalculates the chances for the entry's RollGroup so that they sum up to 100.","title":"AddEntryStatic/RemoveEntryStatic"},{"location":"tactical/LootTableAPI/#addloottablestaticremoveloottablestatic","text":"Actually, I have no idea why they exist and they probably don't do what you want them to. Don't use them. If you do, also call InitLootTables on the ClassDefaultObject .","title":"AddLootTableStatic/RemoveLootTableStatic"},{"location":"tactical/LootTableAPI/#example","text":"// Adds M2 and M3 to ADVENT mid- and end-game loot, respectively static event OnPostTemplatesCreated() { local LootTableEntry M2Entry, M3Entry; M2Entry.Chance = 20; M2Entry.MinCount = 1; M2Entry.MaxCount = 1; M2Entry.TemplateName = 'AdventGremlinM2'; // RollGroup 1 is 100% a random Weapon Upgrade. This turns it into 20% Gremlin, 80% upgrade. M2Entry.RollGroup = 1; M3Entry = M2Entry; M3Entry.TemplateName = 'AdventGremlinM3'; class'X2LootTableManager'.static.AddEntryStatic('ADVENTMidTimedLoot', M2Entry, true); class'X2LootTableManager'.static.AddEntryStatic('ADVENTLateTimedLoot', M3Entry, true); }","title":"Example:"},{"location":"tactical/LootTableAPI/#more-example","text":"Musashis RPG Overhaul uses this feature. Feel free to peruse its source code!","title":"More example:"},{"location":"tactical/LootTableAPI/#source-code-references","text":"X2LootTable.uc:25-161","title":"Source code references"},{"location":"tactical/MoreWillRollStats/","text":"MoreWillRollStats Tracking Issue: #936 This feature provides mods additional options when creating will loss events through XComGameStateContext_WillRoll . Adds new elements to enum WillEventRoll_StatType and adds implementation of the new elements to CalculateWillRoll . Elements of WillEventRoll_StatType are used when creating WillEventRollData in configuration files. Example from XComGameCore.ini : [XComGame.X2EventListener_DefaultWillEvents] SawEnemyUnitWillRollData=(WillLossChance=0.5, \\\\ FlatWillLossChance=true, \\\\ WillLossStat=WillEventRollStat_MaxWill, \\\\ WillLossStatMultiplier=0.05, \\\\ MinimumWillLoss=1, \\\\ MaxWillPercentageLostPerMission=0.33) Current Additions WillEventRollStat_Flat Calculated Will Loss: 1.0f This element existed, but was not implemented in the base game code. Similar to WillEventRollStat_None , but allows will loss to be modified by X2SitRepEffect_ModifyWillPenalties effects. For example usage of X2SitRepEffect_ModifyWillPenalties see X2SitRep_DefaultSitRepEffects:CreateDarkEventDarkTowerEffectTemplate . WillEventRollStat_CHPercentageHealthLost Calculated Will Loss: (Unit's Max HP - Unit's Current HP) / Unit's Max HP Corrected version of WillEventRollStat_PercentageHealthLost that actually gives the health lost (as opposed to health remaining). If a soldier with 5 max HP takes 2 damage to ablative HP, the calculation for will loss would be (5 - 5) / 5 = 0 . If they then took another 3 damage, the will loss would be (5 - 2) / 5 = 0.6 , as they have lost 60% of their total HP at this point. WillEventRollStat_CHTurnCountDecimal Calculated Will Loss: 1 + (Player's Turn Count / 10) This allows for a gradual increase in the amount of will lost as the mission goes on. At turn 1 the calculated will loss is 1.1 , and at turn 10 it will have nearly doubled to 2.0 . Source code references XComGameStateContext_WillRoll.uc:310-340","title":"MoreWillRollStats"},{"location":"tactical/MoreWillRollStats/#morewillrollstats","text":"Tracking Issue: #936 This feature provides mods additional options when creating will loss events through XComGameStateContext_WillRoll . Adds new elements to enum WillEventRoll_StatType and adds implementation of the new elements to CalculateWillRoll . Elements of WillEventRoll_StatType are used when creating WillEventRollData in configuration files. Example from XComGameCore.ini : [XComGame.X2EventListener_DefaultWillEvents] SawEnemyUnitWillRollData=(WillLossChance=0.5, \\\\ FlatWillLossChance=true, \\\\ WillLossStat=WillEventRollStat_MaxWill, \\\\ WillLossStatMultiplier=0.05, \\\\ MinimumWillLoss=1, \\\\ MaxWillPercentageLostPerMission=0.33)","title":"MoreWillRollStats"},{"location":"tactical/MoreWillRollStats/#current-additions","text":"","title":"Current Additions"},{"location":"tactical/MoreWillRollStats/#willeventrollstat_flat","text":"Calculated Will Loss: 1.0f This element existed, but was not implemented in the base game code. Similar to WillEventRollStat_None , but allows will loss to be modified by X2SitRepEffect_ModifyWillPenalties effects. For example usage of X2SitRepEffect_ModifyWillPenalties see X2SitRep_DefaultSitRepEffects:CreateDarkEventDarkTowerEffectTemplate .","title":"WillEventRollStat_Flat"},{"location":"tactical/MoreWillRollStats/#willeventrollstat_chpercentagehealthlost","text":"Calculated Will Loss: (Unit's Max HP - Unit's Current HP) / Unit's Max HP Corrected version of WillEventRollStat_PercentageHealthLost that actually gives the health lost (as opposed to health remaining). If a soldier with 5 max HP takes 2 damage to ablative HP, the calculation for will loss would be (5 - 5) / 5 = 0 . If they then took another 3 damage, the will loss would be (5 - 2) / 5 = 0.6 , as they have lost 60% of their total HP at this point.","title":"WillEventRollStat_CHPercentageHealthLost"},{"location":"tactical/MoreWillRollStats/#willeventrollstat_chturncountdecimal","text":"Calculated Will Loss: 1 + (Player's Turn Count / 10) This allows for a gradual increase in the amount of will lost as the mission goes on. At turn 1 the calculated will loss is 1.1 , and at turn 10 it will have nearly doubled to 2.0 .","title":"WillEventRollStat_CHTurnCountDecimal"},{"location":"tactical/MoreWillRollStats/#source-code-references","text":"XComGameStateContext_WillRoll.uc:310-340","title":"Source code references"},{"location":"tactical/OnDistributeTacticalGameEndXp/","text":"OnDistributeTacticalGameEndXp Tracking Issue: #562 Tags: events Allows mods to add their own mission XP distribution mechanics at the end of a mission. This hook is mainly to aid mods in providing other sources of XP than just kills. Mission XP (XP that's gained by just going on a mission) is a good example. OnDistributeTacticalGameEndXp event Param Value EventID OnDistributeTacticalGameEndXp EventData XComGameState_HeadquartersXCom EventSource XComGameState_XpManager NewGameState yes Listener template static function EventListenerReturn OnOnDistributeTacticalGameEndXp(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_XpManager XpMgr; XpMgr = XComGameState_XpManager(EventSource); // Your code here return ELR_NoInterrupt; } Source code references XComGameState_XpManager.uc:111-122","title":"OnDistributeTacticalGameEndXp"},{"location":"tactical/OnDistributeTacticalGameEndXp/#ondistributetacticalgameendxp","text":"Tracking Issue: #562 Tags: events Allows mods to add their own mission XP distribution mechanics at the end of a mission. This hook is mainly to aid mods in providing other sources of XP than just kills. Mission XP (XP that's gained by just going on a mission) is a good example.","title":"OnDistributeTacticalGameEndXp"},{"location":"tactical/OnDistributeTacticalGameEndXp/#ondistributetacticalgameendxp-event","text":"Param Value EventID OnDistributeTacticalGameEndXp EventData XComGameState_HeadquartersXCom EventSource XComGameState_XpManager NewGameState yes","title":"OnDistributeTacticalGameEndXp event"},{"location":"tactical/OnDistributeTacticalGameEndXp/#listener-template","text":"static function EventListenerReturn OnOnDistributeTacticalGameEndXp(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_XpManager XpMgr; XpMgr = XComGameState_XpManager(EventSource); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OnDistributeTacticalGameEndXp/#source-code-references","text":"XComGameState_XpManager.uc:111-122","title":"Source code references"},{"location":"tactical/OverKillDamage/","text":"OverKillDamage Tracking Issue: #805 The UnitState's damage results array only holds the actual damage taken by the unit, so the result can't be higher than the unit's HP. This adds the OverkillDamage Unit value, which is shows how higher the kill damage value was from the standard Unit HP. One of its use cases is to modify the effects of the abilities that trigger on death, like the trigger chance on Advent Priest's Sustain. The OverKillDamage calculated by XCGS_Unit is negative, but the unit value is set to be positive to make using it more intuitive. The value uses eCleanup_BeginTactical . Source code references XComGameState_Unit.uc:15897-15902","title":"OverKillDamage"},{"location":"tactical/OverKillDamage/#overkilldamage","text":"Tracking Issue: #805 The UnitState's damage results array only holds the actual damage taken by the unit, so the result can't be higher than the unit's HP. This adds the OverkillDamage Unit value, which is shows how higher the kill damage value was from the standard Unit HP. One of its use cases is to modify the effects of the abilities that trigger on death, like the trigger chance on Advent Priest's Sustain. The OverKillDamage calculated by XCGS_Unit is negative, but the unit value is set to be positive to make using it more intuitive. The value uses eCleanup_BeginTactical .","title":"OverKillDamage"},{"location":"tactical/OverKillDamage/#source-code-references","text":"XComGameState_Unit.uc:15897-15902","title":"Source code references"},{"location":"tactical/OverrideAbilityIconColor/","text":"OverrideAbilityIconColor Tracking Issue: #400 Tags: events DEPRECATED - The OverrideAbilityIconColor event allows mods to override icon color for objective abilities or abilities that have AbilityIconColor property set in their templates. This event has been deprecated and should no longer be used. It is kept for backwards compatibility. Use OverrideAbilityIconColorImproved instead. OverrideAbilityIconColor event Param Value EventID OverrideAbilityIconColor EventData XComLWTuple EventSource XComGameState_Ability NewGameState none Tuple contents Index Name Type Direction 0 IsObjective bool in 1 BackgroundColor string inout Listener template static function EventListenerReturn OnOverrideAbilityIconColor(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Ability AbilityState; local XComLWTuple Tuple; local bool IsObjective; local string BackgroundColor; AbilityState = XComGameState_Ability(EventSource); Tuple = XComLWTuple(EventData); IsObjective = Tuple.Data[0].b; BackgroundColor = Tuple.Data[1].s; // Your code here Tuple.Data[1].s = BackgroundColor; return ELR_NoInterrupt; } Source code references UITacticalHUD_Ability.uc:198-211","title":"OverrideAbilityIconColor"},{"location":"tactical/OverrideAbilityIconColor/#overrideabilityiconcolor","text":"Tracking Issue: #400 Tags: events DEPRECATED - The OverrideAbilityIconColor event allows mods to override icon color for objective abilities or abilities that have AbilityIconColor property set in their templates. This event has been deprecated and should no longer be used. It is kept for backwards compatibility. Use OverrideAbilityIconColorImproved instead.","title":"OverrideAbilityIconColor"},{"location":"tactical/OverrideAbilityIconColor/#overrideabilityiconcolor-event","text":"Param Value EventID OverrideAbilityIconColor EventData XComLWTuple EventSource XComGameState_Ability NewGameState none","title":"OverrideAbilityIconColor event"},{"location":"tactical/OverrideAbilityIconColor/#tuple-contents","text":"Index Name Type Direction 0 IsObjective bool in 1 BackgroundColor string inout","title":"Tuple contents"},{"location":"tactical/OverrideAbilityIconColor/#listener-template","text":"static function EventListenerReturn OnOverrideAbilityIconColor(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Ability AbilityState; local XComLWTuple Tuple; local bool IsObjective; local string BackgroundColor; AbilityState = XComGameState_Ability(EventSource); Tuple = XComLWTuple(EventData); IsObjective = Tuple.Data[0].b; BackgroundColor = Tuple.Data[1].s; // Your code here Tuple.Data[1].s = BackgroundColor; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideAbilityIconColor/#source-code-references","text":"UITacticalHUD_Ability.uc:198-211","title":"Source code references"},{"location":"tactical/OverrideAbilityIconColorImproved/","text":"OverrideAbilityIconColorImproved Tracking Issue: #749 Tags: compatibility , events The OverrideAbilityIconColorImproved event allows mods to override background and foreground colors of ability icons. The \"background\" color is the color of the icon itself, and normally varies depending on the AbilitySourceName property of the X2AbilityTemplate . The \"foreground\" color is normally always black. Default colors used by the game can be found in the UIUtilities_Colors class. Performance note: this event gets triggered a lot , so try to avoid complex computations in listeners to reduce the performance hit. OverrideAbilityIconColorImproved event Param Value EventID OverrideAbilityIconColorImproved EventData XComLWTuple EventSource XComGameState_Ability NewGameState none Tuple contents Index Name Type Direction 0 IsObjective bool in 1 BackgroundColor string inout 2 ForegroundColor string inout Listener template static function EventListenerReturn OnOverrideAbilityIconColorImproved(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Ability AbilityState; local XComLWTuple Tuple; local bool IsObjective; local string BackgroundColor; local string ForegroundColor; AbilityState = XComGameState_Ability(EventSource); Tuple = XComLWTuple(EventData); IsObjective = Tuple.Data[0].b; BackgroundColor = Tuple.Data[1].s; ForegroundColor = Tuple.Data[2].s; // Your code here Tuple.Data[1].s = BackgroundColor; Tuple.Data[2].s = ForegroundColor; return ELR_NoInterrupt; } Compatibility This event takes precedence over the deprecated event OverrideAbilityIconColor , so any listener that changes ability icon colors will always overwrite any changes made by listeners of the deprecated event. Source code references UITacticalHUD_Ability.uc:231-252","title":"OverrideAbilityIconColorImproved"},{"location":"tactical/OverrideAbilityIconColorImproved/#overrideabilityiconcolorimproved","text":"Tracking Issue: #749 Tags: compatibility , events The OverrideAbilityIconColorImproved event allows mods to override background and foreground colors of ability icons. The \"background\" color is the color of the icon itself, and normally varies depending on the AbilitySourceName property of the X2AbilityTemplate . The \"foreground\" color is normally always black. Default colors used by the game can be found in the UIUtilities_Colors class. Performance note: this event gets triggered a lot , so try to avoid complex computations in listeners to reduce the performance hit.","title":"OverrideAbilityIconColorImproved"},{"location":"tactical/OverrideAbilityIconColorImproved/#overrideabilityiconcolorimproved-event","text":"Param Value EventID OverrideAbilityIconColorImproved EventData XComLWTuple EventSource XComGameState_Ability NewGameState none","title":"OverrideAbilityIconColorImproved event"},{"location":"tactical/OverrideAbilityIconColorImproved/#tuple-contents","text":"Index Name Type Direction 0 IsObjective bool in 1 BackgroundColor string inout 2 ForegroundColor string inout","title":"Tuple contents"},{"location":"tactical/OverrideAbilityIconColorImproved/#listener-template","text":"static function EventListenerReturn OnOverrideAbilityIconColorImproved(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Ability AbilityState; local XComLWTuple Tuple; local bool IsObjective; local string BackgroundColor; local string ForegroundColor; AbilityState = XComGameState_Ability(EventSource); Tuple = XComLWTuple(EventData); IsObjective = Tuple.Data[0].b; BackgroundColor = Tuple.Data[1].s; ForegroundColor = Tuple.Data[2].s; // Your code here Tuple.Data[1].s = BackgroundColor; Tuple.Data[2].s = ForegroundColor; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideAbilityIconColorImproved/#compatibility","text":"This event takes precedence over the deprecated event OverrideAbilityIconColor , so any listener that changes ability icon colors will always overwrite any changes made by listeners of the deprecated event.","title":"Compatibility"},{"location":"tactical/OverrideAbilityIconColorImproved/#source-code-references","text":"UITacticalHUD_Ability.uc:231-252","title":"Source code references"},{"location":"tactical/OverrideCameraRotationAngle/","text":"OverrideCameraRotationAngle Tracking Issue: #854 Tags: compatibility The 'OverrideCameraRotationAngle' event allows mods to override the angle the camera rotates when using the controller or the Q and E buttons. The event takes the following form, with mods changing the first value of the tuple if they want to change the angle: EventID: OverrideCameraRotationAngle EventData: [ inout float RotationAngle, in int ActionMask ] EventSource: none NewGameState: none Compatibility Several mods, typically ones that modify the behavior of the camera, override XComTacticalInput , thus breaking this highlander change. Since those camera mods mostly seem to override the camera rotation behavior, that's usually not a problem. Just be aware that overriding XComTacticalInput without including this highlander event may break other mods that rely on it. Source code references XComTacticalInput.uc:890-910","title":"OverrideCameraRotationAngle"},{"location":"tactical/OverrideCameraRotationAngle/#overridecamerarotationangle","text":"Tracking Issue: #854 Tags: compatibility The 'OverrideCameraRotationAngle' event allows mods to override the angle the camera rotates when using the controller or the Q and E buttons. The event takes the following form, with mods changing the first value of the tuple if they want to change the angle: EventID: OverrideCameraRotationAngle EventData: [ inout float RotationAngle, in int ActionMask ] EventSource: none NewGameState: none","title":"OverrideCameraRotationAngle"},{"location":"tactical/OverrideCameraRotationAngle/#compatibility","text":"Several mods, typically ones that modify the behavior of the camera, override XComTacticalInput , thus breaking this highlander change. Since those camera mods mostly seem to override the camera rotation behavior, that's usually not a problem. Just be aware that overriding XComTacticalInput without including this highlander event may break other mods that rely on it.","title":"Compatibility"},{"location":"tactical/OverrideCameraRotationAngle/#source-code-references","text":"XComTacticalInput.uc:890-910","title":"Source code references"},{"location":"tactical/OverrideClipSize/","text":"OverrideClipSize Tracking Issue: #393 Tags: events The OverrideClipSize event allows mods to override Clip Size of a weapon after it has been modified by weapon upgrades and/or loaded ammo. This can help make a passive ability that modifies Clip Size of the soldier's weapon, or to explicitly disallow a specific weapon benefitting from effects that modify Clip Size by resetting the clip size value to the clip size value stored in the weapon template. OverrideClipSize event Param Value EventID OverrideClipSize EventData XComLWTuple EventSource XComGameState_Item NewGameState none Tuple contents Index Name Type Direction 0 iClipSize int inout Listener template static function EventListenerReturn OnOverrideClipSize(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Item ItemState; local XComLWTuple Tuple; local int iClipSize; ItemState = XComGameState_Item(EventSource); Tuple = XComLWTuple(EventData); iClipSize = Tuple.Data[0].i; // Your code here Tuple.Data[0].i = iClipSize; return ELR_NoInterrupt; } Source code references XComGameState_Item.uc:972-985","title":"OverrideClipSize"},{"location":"tactical/OverrideClipSize/#overrideclipsize","text":"Tracking Issue: #393 Tags: events The OverrideClipSize event allows mods to override Clip Size of a weapon after it has been modified by weapon upgrades and/or loaded ammo. This can help make a passive ability that modifies Clip Size of the soldier's weapon, or to explicitly disallow a specific weapon benefitting from effects that modify Clip Size by resetting the clip size value to the clip size value stored in the weapon template.","title":"OverrideClipSize"},{"location":"tactical/OverrideClipSize/#overrideclipsize-event","text":"Param Value EventID OverrideClipSize EventData XComLWTuple EventSource XComGameState_Item NewGameState none","title":"OverrideClipSize event"},{"location":"tactical/OverrideClipSize/#tuple-contents","text":"Index Name Type Direction 0 iClipSize int inout","title":"Tuple contents"},{"location":"tactical/OverrideClipSize/#listener-template","text":"static function EventListenerReturn OnOverrideClipSize(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Item ItemState; local XComLWTuple Tuple; local int iClipSize; ItemState = XComGameState_Item(EventSource); Tuple = XComLWTuple(EventData); iClipSize = Tuple.Data[0].i; // Your code here Tuple.Data[0].i = iClipSize; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideClipSize/#source-code-references","text":"XComGameState_Item.uc:972-985","title":"Source code references"},{"location":"tactical/OverrideDamageRemovesReserveActionPoints/","text":"OverrideDamageRemovesReserveActionPoints Tracking Issue: #903 Tags: events The OverrideDamageRemovesReserveActionPoints event allows mods to override the base game logic that determines that a Unit must lose their Reserve Action Points when they take damage. This event triggers after the information about this damage instance has been added to the UnitState.DamageResults array, so you can use that last entry to get any additional info about who damaged whom with what. OverrideDamageRemovesReserveActionPoints event Param Value EventID OverrideDamageRemovesReserveActionPoints EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes Tuple contents Index Name Type Direction 0 bDamageRemovesReserveActionPoints bool inout Listener template static function EventListenerReturn OnOverrideDamageRemovesReserveActionPoints(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool bDamageRemovesReserveActionPoints; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bDamageRemovesReserveActionPoints = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bDamageRemovesReserveActionPoints; return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:6715-6729","title":"OverrideDamageRemovesReserveActionPoints"},{"location":"tactical/OverrideDamageRemovesReserveActionPoints/#overridedamageremovesreserveactionpoints","text":"Tracking Issue: #903 Tags: events The OverrideDamageRemovesReserveActionPoints event allows mods to override the base game logic that determines that a Unit must lose their Reserve Action Points when they take damage. This event triggers after the information about this damage instance has been added to the UnitState.DamageResults array, so you can use that last entry to get any additional info about who damaged whom with what.","title":"OverrideDamageRemovesReserveActionPoints"},{"location":"tactical/OverrideDamageRemovesReserveActionPoints/#overridedamageremovesreserveactionpoints-event","text":"Param Value EventID OverrideDamageRemovesReserveActionPoints EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes","title":"OverrideDamageRemovesReserveActionPoints event"},{"location":"tactical/OverrideDamageRemovesReserveActionPoints/#tuple-contents","text":"Index Name Type Direction 0 bDamageRemovesReserveActionPoints bool inout","title":"Tuple contents"},{"location":"tactical/OverrideDamageRemovesReserveActionPoints/#listener-template","text":"static function EventListenerReturn OnOverrideDamageRemovesReserveActionPoints(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool bDamageRemovesReserveActionPoints; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bDamageRemovesReserveActionPoints = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bDamageRemovesReserveActionPoints; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideDamageRemovesReserveActionPoints/#source-code-references","text":"XComGameState_Unit.uc:6715-6729","title":"Source code references"},{"location":"tactical/OverrideDisableReinforcementsFlare/","text":"OverrideDisableReinforcementsFlare Tracking Issue: #448 Tags: events The OverrideDisableReinforcementsFlare event allows mods to disable the visuals for the particle effects (red flare or purple psionic gate in base game) that indicate the location of incoming enemy reinforcements, as well as other visualization associated with it, such as camera panning. Returns true if the reinforcements flare should be disabled. OverrideDisableReinforcementsFlare event Param Value EventID OverrideDisableReinforcementsFlare EventData XComLWTuple EventSource XComGameState_AIReinforcementSpawner NewGameState none Tuple contents Index Name Type Direction 0 bDisableFlare bool inout Listener template static function EventListenerReturn OnOverrideDisableReinforcementsFlare(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_AIReinforcementSpawner AISpawnerState; local XComLWTuple Tuple; local bool bDisableFlare; AISpawnerState = XComGameState_AIReinforcementSpawner(EventSource); Tuple = XComLWTuple(EventData); bDisableFlare = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bDisableFlare; return ELR_NoInterrupt; } Source code references XComGameState_AIReinforcementSpawner.uc:677-690","title":"OverrideDisableReinforcementsFlare"},{"location":"tactical/OverrideDisableReinforcementsFlare/#overridedisablereinforcementsflare","text":"Tracking Issue: #448 Tags: events The OverrideDisableReinforcementsFlare event allows mods to disable the visuals for the particle effects (red flare or purple psionic gate in base game) that indicate the location of incoming enemy reinforcements, as well as other visualization associated with it, such as camera panning. Returns true if the reinforcements flare should be disabled.","title":"OverrideDisableReinforcementsFlare"},{"location":"tactical/OverrideDisableReinforcementsFlare/#overridedisablereinforcementsflare-event","text":"Param Value EventID OverrideDisableReinforcementsFlare EventData XComLWTuple EventSource XComGameState_AIReinforcementSpawner NewGameState none","title":"OverrideDisableReinforcementsFlare event"},{"location":"tactical/OverrideDisableReinforcementsFlare/#tuple-contents","text":"Index Name Type Direction 0 bDisableFlare bool inout","title":"Tuple contents"},{"location":"tactical/OverrideDisableReinforcementsFlare/#listener-template","text":"static function EventListenerReturn OnOverrideDisableReinforcementsFlare(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_AIReinforcementSpawner AISpawnerState; local XComLWTuple Tuple; local bool bDisableFlare; AISpawnerState = XComGameState_AIReinforcementSpawner(EventSource); Tuple = XComLWTuple(EventData); bDisableFlare = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bDisableFlare; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideDisableReinforcementsFlare/#source-code-references","text":"XComGameState_AIReinforcementSpawner.uc:677-690","title":"Source code references"},{"location":"tactical/OverrideEffectIconColor/","text":"OverrideEffectIconColor Tracking Issue: #1509 Tags: events The OverrideEffectIconColor event allows mods to override the background and foreground colors of icons from X2Effect_Persistent set as ePerkBuff_Passive . The \"background\" color is hexadecimal string for the color of the icon itself, and normally varies depending on the AbilitySourceName property set on the X2Effect_Persistent The \"foreground\" color is normally always black. Default colors used by the game can be found in the UIUtilities_Colors class. Listeners should use the Effect's AbilitySourceName provided in the EventData as a filter to ensure maximum compatibility. Performance note: this event gets triggered a lot , so try to avoid complex computations in listeners to reduce the performance hit. OverrideEffectIconColor event Param Value EventID OverrideEffectIconColor EventData XComLWTuple EventSource none NewGameState none Tuple contents Index Name Type Direction 0 AbilitySourceName name in 1 BackgroundColor string out 2 ForegroundColor string out Listener template static function EventListenerReturn OnOverrideEffectIconColor(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local name AbilitySourceName; local string BackgroundColor; local string ForegroundColor; Tuple = XComLWTuple(EventData); AbilitySourceName = Tuple.Data[0].n; // Your code here Tuple.Data[1].s = BackgroundColor; Tuple.Data[2].s = ForegroundColor; return ELR_NoInterrupt; } Source code references UITacticalHUD_Perk.uc:65-84","title":"OverrideEffectIconColor"},{"location":"tactical/OverrideEffectIconColor/#overrideeffecticoncolor","text":"Tracking Issue: #1509 Tags: events The OverrideEffectIconColor event allows mods to override the background and foreground colors of icons from X2Effect_Persistent set as ePerkBuff_Passive . The \"background\" color is hexadecimal string for the color of the icon itself, and normally varies depending on the AbilitySourceName property set on the X2Effect_Persistent The \"foreground\" color is normally always black. Default colors used by the game can be found in the UIUtilities_Colors class. Listeners should use the Effect's AbilitySourceName provided in the EventData as a filter to ensure maximum compatibility. Performance note: this event gets triggered a lot , so try to avoid complex computations in listeners to reduce the performance hit.","title":"OverrideEffectIconColor"},{"location":"tactical/OverrideEffectIconColor/#overrideeffecticoncolor-event","text":"Param Value EventID OverrideEffectIconColor EventData XComLWTuple EventSource none NewGameState none","title":"OverrideEffectIconColor event"},{"location":"tactical/OverrideEffectIconColor/#tuple-contents","text":"Index Name Type Direction 0 AbilitySourceName name in 1 BackgroundColor string out 2 ForegroundColor string out","title":"Tuple contents"},{"location":"tactical/OverrideEffectIconColor/#listener-template","text":"static function EventListenerReturn OnOverrideEffectIconColor(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local name AbilitySourceName; local string BackgroundColor; local string ForegroundColor; Tuple = XComLWTuple(EventData); AbilitySourceName = Tuple.Data[0].n; // Your code here Tuple.Data[1].s = BackgroundColor; Tuple.Data[2].s = ForegroundColor; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideEffectIconColor/#source-code-references","text":"UITacticalHUD_Perk.uc:65-84","title":"Source code references"},{"location":"tactical/OverrideEncounterZoneAnchorPoint/","text":"OverrideEncounterZoneAnchorPoint Tracking Issue: #500 Tags: events The OverrideEncounterZoneAnchorPoint event allows mods to override the anchor point for determining encounter zones for patrolling pods. X, Y and Z components of the tuple should be treated as components of the Anchor Point's vector coordinates. OverrideEncounterZoneAnchorPoint event Param Value EventID OverrideEncounterZoneAnchorPoint EventData XComLWTuple EventSource XComGameState_AIGroup NewGameState none Tuple contents Index Name Type Direction 0 X float inout 1 Y float inout 2 Z float inout Listener template static function EventListenerReturn OnOverrideEncounterZoneAnchorPoint(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_AIGroup AIGroup; local XComLWTuple Tuple; local float X; local float Y; local float Z; AIGroup = XComGameState_AIGroup(EventSource); Tuple = XComLWTuple(EventData); X = Tuple.Data[0].f; Y = Tuple.Data[1].f; Z = Tuple.Data[2].f; // Your code here Tuple.Data[0].f = X; Tuple.Data[1].f = Y; Tuple.Data[2].f = Z; return ELR_NoInterrupt; } This allows mods to override the LoP anchor point for the encounter zone. By default, the encounter zone adjusts to the current location of the XCOM squad. As an example, a mod could use the XCOM's spawn location instead so that the encounter zones remain the same regardless of where the XCOM squad is currently. Source code references XComGameState_AIGroup.uc:454-466 XComGameState_AIGroup.uc:391-398","title":"OverrideEncounterZoneAnchorPoint"},{"location":"tactical/OverrideEncounterZoneAnchorPoint/#overrideencounterzoneanchorpoint","text":"Tracking Issue: #500 Tags: events The OverrideEncounterZoneAnchorPoint event allows mods to override the anchor point for determining encounter zones for patrolling pods. X, Y and Z components of the tuple should be treated as components of the Anchor Point's vector coordinates.","title":"OverrideEncounterZoneAnchorPoint"},{"location":"tactical/OverrideEncounterZoneAnchorPoint/#overrideencounterzoneanchorpoint-event","text":"Param Value EventID OverrideEncounterZoneAnchorPoint EventData XComLWTuple EventSource XComGameState_AIGroup NewGameState none","title":"OverrideEncounterZoneAnchorPoint event"},{"location":"tactical/OverrideEncounterZoneAnchorPoint/#tuple-contents","text":"Index Name Type Direction 0 X float inout 1 Y float inout 2 Z float inout","title":"Tuple contents"},{"location":"tactical/OverrideEncounterZoneAnchorPoint/#listener-template","text":"static function EventListenerReturn OnOverrideEncounterZoneAnchorPoint(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_AIGroup AIGroup; local XComLWTuple Tuple; local float X; local float Y; local float Z; AIGroup = XComGameState_AIGroup(EventSource); Tuple = XComLWTuple(EventData); X = Tuple.Data[0].f; Y = Tuple.Data[1].f; Z = Tuple.Data[2].f; // Your code here Tuple.Data[0].f = X; Tuple.Data[1].f = Y; Tuple.Data[2].f = Z; return ELR_NoInterrupt; } This allows mods to override the LoP anchor point for the encounter zone. By default, the encounter zone adjusts to the current location of the XCOM squad. As an example, a mod could use the XCOM's spawn location instead so that the encounter zones remain the same regardless of where the XCOM squad is currently.","title":"Listener template"},{"location":"tactical/OverrideEncounterZoneAnchorPoint/#source-code-references","text":"XComGameState_AIGroup.uc:454-466 XComGameState_AIGroup.uc:391-398","title":"Source code references"},{"location":"tactical/OverrideEnemyFactionsAlertsOutsideVision/","text":"OverrideEnemyFactionsAlertsOutsideVision Tracking Issue: #1036 Tags: events Fires an event that allows listeners to override whether a given alert cause can be triggered by AI units outside of XCOM's vision. For example, you could use this event to allow enemy pods to activate one another outside of XCOM vision for a given set of alert causes. Return true in AllowThisCause if the alert cause can be triggered in such situations. Leave AllowThisCause untouched to retain the default behavior. OverrideEnemyFactionsAlertsOutsideVision event Param Value EventID OverrideEnemyFactionsAlertsOutsideVision EventData XComLWTuple EventSource none NewGameState none Tuple contents Index Name Type Direction 0 AlertCause enum (EAlertCause) in 1 AllowThisCause bool inout Listener template static function EventListenerReturn OnOverrideEnemyFactionsAlertsOutsideVision(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local EAlertCause AlertCause; local bool AllowThisCause; Tuple = XComLWTuple(EventData); AlertCause = EAlertCause(Tuple.Data[0].i); AllowThisCause = Tuple.Data[1].b; // Your code here Tuple.Data[1].b = AllowThisCause; return ELR_NoInterrupt; } Source code references XComGameState_AIUnitData.uc:1040-1053","title":"OverrideEnemyFactionsAlertsOutsideVision"},{"location":"tactical/OverrideEnemyFactionsAlertsOutsideVision/#overrideenemyfactionsalertsoutsidevision","text":"Tracking Issue: #1036 Tags: events Fires an event that allows listeners to override whether a given alert cause can be triggered by AI units outside of XCOM's vision. For example, you could use this event to allow enemy pods to activate one another outside of XCOM vision for a given set of alert causes. Return true in AllowThisCause if the alert cause can be triggered in such situations. Leave AllowThisCause untouched to retain the default behavior.","title":"OverrideEnemyFactionsAlertsOutsideVision"},{"location":"tactical/OverrideEnemyFactionsAlertsOutsideVision/#overrideenemyfactionsalertsoutsidevision-event","text":"Param Value EventID OverrideEnemyFactionsAlertsOutsideVision EventData XComLWTuple EventSource none NewGameState none","title":"OverrideEnemyFactionsAlertsOutsideVision event"},{"location":"tactical/OverrideEnemyFactionsAlertsOutsideVision/#tuple-contents","text":"Index Name Type Direction 0 AlertCause enum (EAlertCause) in 1 AllowThisCause bool inout","title":"Tuple contents"},{"location":"tactical/OverrideEnemyFactionsAlertsOutsideVision/#listener-template","text":"static function EventListenerReturn OnOverrideEnemyFactionsAlertsOutsideVision(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local EAlertCause AlertCause; local bool AllowThisCause; Tuple = XComLWTuple(EventData); AlertCause = EAlertCause(Tuple.Data[0].i); AllowThisCause = Tuple.Data[1].b; // Your code here Tuple.Data[1].b = AllowThisCause; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideEnemyFactionsAlertsOutsideVision/#source-code-references","text":"XComGameState_AIUnitData.uc:1040-1053","title":"Source code references"},{"location":"tactical/OverrideHasInfiniteAmmo/","text":"OverrideHasInfiniteAmmo Tracking Issue: #842 Tags: events Allows listeners to override the result of HasInfiniteAmmo OverrideHasInfiniteAmmo event Param Value EventID OverrideHasInfiniteAmmo EventData XComLWTuple EventSource XComGameState_Item NewGameState none Tuple contents Index Name Type Direction 0 bHasInfiniteAmmo bool out Listener template static function EventListenerReturn OnOverrideHasInfiniteAmmo(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Item ItemState; local XComLWTuple Tuple; local bool bHasInfiniteAmmo; ItemState = XComGameState_Item(EventSource); Tuple = XComLWTuple(EventData); // Your code here Tuple.Data[0].b = bHasInfiniteAmmo; return ELR_NoInterrupt; } Source code references XComGameState_Item.uc:1015-1023","title":"OverrideHasInfiniteAmmo"},{"location":"tactical/OverrideHasInfiniteAmmo/#overridehasinfiniteammo","text":"Tracking Issue: #842 Tags: events Allows listeners to override the result of HasInfiniteAmmo","title":"OverrideHasInfiniteAmmo"},{"location":"tactical/OverrideHasInfiniteAmmo/#overridehasinfiniteammo-event","text":"Param Value EventID OverrideHasInfiniteAmmo EventData XComLWTuple EventSource XComGameState_Item NewGameState none","title":"OverrideHasInfiniteAmmo event"},{"location":"tactical/OverrideHasInfiniteAmmo/#tuple-contents","text":"Index Name Type Direction 0 bHasInfiniteAmmo bool out","title":"Tuple contents"},{"location":"tactical/OverrideHasInfiniteAmmo/#listener-template","text":"static function EventListenerReturn OnOverrideHasInfiniteAmmo(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Item ItemState; local XComLWTuple Tuple; local bool bHasInfiniteAmmo; ItemState = XComGameState_Item(EventSource); Tuple = XComLWTuple(EventData); // Your code here Tuple.Data[0].b = bHasInfiniteAmmo; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideHasInfiniteAmmo/#source-code-references","text":"XComGameState_Item.uc:1015-1023","title":"Source code references"},{"location":"tactical/OverrideHitEffects/","text":"OverrideHitEffects Tracking Issue: #825 Tags: events Allows listeners to change behavior of XComUnitPawn::PlayHitEffects() . Listeners can set OverrideHitEffect to true , and then the default behavior will be omitted entirely, and no hit effect will be played. Alternatively, listeners can modify the parameters passed with the Tuple to modify the default behavior. For example, this listener can be used to prevent Templar purple hit effects from playing for any attack that has the hit result eHit_Parry, eHit_Reflect or eHit_Deflect. OverrideHitEffects event Param Value EventID OverrideHitEffects EventData XComLWTuple EventSource XComUnitPawn NewGameState none Tuple contents Index Name Type Direction 0 OverrideHitEffect bool inout 1 Damage float inout 2 InstigatedBy Actor in 3 HitLocation vector inout 4 DamageTypeName name inout 5 Momentum vector inout 6 bIsUnitRuptured bool inout 7 HitResult enum (EAbilityHitResult) inout Listener template static function EventListenerReturn OnOverrideHitEffects(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComUnitPawn Pawn; local XComLWTuple Tuple; local bool OverrideHitEffect; local float Damage; local Actor InstigatedBy; local vector HitLocation; local name DamageTypeName; local vector Momentum; local bool bIsUnitRuptured; local EAbilityHitResult HitResult; Pawn = XComUnitPawn(EventSource); Tuple = XComLWTuple(EventData); OverrideHitEffect = Tuple.Data[0].b; Damage = Tuple.Data[1].f; InstigatedBy = Actor(Tuple.Data[2].o); HitLocation = Tuple.Data[3].v; DamageTypeName = Tuple.Data[4].n; Momentum = Tuple.Data[5].v; bIsUnitRuptured = Tuple.Data[6].b; HitResult = EAbilityHitResult(Tuple.Data[7].i); // Your code here Tuple.Data[0].b = OverrideHitEffect; Tuple.Data[1].f = Damage; Tuple.Data[3].v = HitLocation; Tuple.Data[4].n = DamageTypeName; Tuple.Data[5].v = Momentum; Tuple.Data[6].b = bIsUnitRuptured; Tuple.Data[7].i = HitResult; return ELR_NoInterrupt; } Source code references XComUnitPawn.uc:380-407","title":"OverrideHitEffects"},{"location":"tactical/OverrideHitEffects/#overridehiteffects","text":"Tracking Issue: #825 Tags: events Allows listeners to change behavior of XComUnitPawn::PlayHitEffects() . Listeners can set OverrideHitEffect to true , and then the default behavior will be omitted entirely, and no hit effect will be played. Alternatively, listeners can modify the parameters passed with the Tuple to modify the default behavior. For example, this listener can be used to prevent Templar purple hit effects from playing for any attack that has the hit result eHit_Parry, eHit_Reflect or eHit_Deflect.","title":"OverrideHitEffects"},{"location":"tactical/OverrideHitEffects/#overridehiteffects-event","text":"Param Value EventID OverrideHitEffects EventData XComLWTuple EventSource XComUnitPawn NewGameState none","title":"OverrideHitEffects event"},{"location":"tactical/OverrideHitEffects/#tuple-contents","text":"Index Name Type Direction 0 OverrideHitEffect bool inout 1 Damage float inout 2 InstigatedBy Actor in 3 HitLocation vector inout 4 DamageTypeName name inout 5 Momentum vector inout 6 bIsUnitRuptured bool inout 7 HitResult enum (EAbilityHitResult) inout","title":"Tuple contents"},{"location":"tactical/OverrideHitEffects/#listener-template","text":"static function EventListenerReturn OnOverrideHitEffects(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComUnitPawn Pawn; local XComLWTuple Tuple; local bool OverrideHitEffect; local float Damage; local Actor InstigatedBy; local vector HitLocation; local name DamageTypeName; local vector Momentum; local bool bIsUnitRuptured; local EAbilityHitResult HitResult; Pawn = XComUnitPawn(EventSource); Tuple = XComLWTuple(EventData); OverrideHitEffect = Tuple.Data[0].b; Damage = Tuple.Data[1].f; InstigatedBy = Actor(Tuple.Data[2].o); HitLocation = Tuple.Data[3].v; DamageTypeName = Tuple.Data[4].n; Momentum = Tuple.Data[5].v; bIsUnitRuptured = Tuple.Data[6].b; HitResult = EAbilityHitResult(Tuple.Data[7].i); // Your code here Tuple.Data[0].b = OverrideHitEffect; Tuple.Data[1].f = Damage; Tuple.Data[3].v = HitLocation; Tuple.Data[4].n = DamageTypeName; Tuple.Data[5].v = Momentum; Tuple.Data[6].b = bIsUnitRuptured; Tuple.Data[7].i = HitResult; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideHitEffects/#source-code-references","text":"XComUnitPawn.uc:380-407","title":"Source code references"},{"location":"tactical/OverrideKillXp/","text":"OverrideKillXp Tracking Issue: #562 Tags: events Allows listeners to override the XP values granted by a kill, including the normal kill contribution, any bonus XP from resistance orders and the like, the XP granted for assists, and any Wet Work bonus. Mods can even set these values to zero to prevent XP gain. This event is called no more than once for each kill. OverrideKillXp event Param Value EventID OverrideKillXp EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes Tuple contents Index Name Type Direction 0 KillXp float inout 1 BonusKillXp float inout 2 KillAssistXp float inout 3 WetWorkXp int inout 4 Killer XComGameState_Unit in Listener template static function EventListenerReturn OnOverrideKillXp(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit KilledUnit; local XComLWTuple Tuple; local float KillXp; local float BonusKillXp; local float KillAssistXp; local int WetWorkXp; local XComGameState_Unit Killer; KilledUnit = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); KillXp = Tuple.Data[0].f; BonusKillXp = Tuple.Data[1].f; KillAssistXp = Tuple.Data[2].f; WetWorkXp = Tuple.Data[3].i; Killer = XComGameState_Unit(Tuple.Data[4].o); // Your code here Tuple.Data[0].f = KillXp; Tuple.Data[1].f = BonusKillXp; Tuple.Data[2].f = KillAssistXp; Tuple.Data[3].i = WetWorkXp; return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:7085-7104 XComGameState_Unit.uc:6894","title":"OverrideKillXp"},{"location":"tactical/OverrideKillXp/#overridekillxp","text":"Tracking Issue: #562 Tags: events Allows listeners to override the XP values granted by a kill, including the normal kill contribution, any bonus XP from resistance orders and the like, the XP granted for assists, and any Wet Work bonus. Mods can even set these values to zero to prevent XP gain. This event is called no more than once for each kill.","title":"OverrideKillXp"},{"location":"tactical/OverrideKillXp/#overridekillxp-event","text":"Param Value EventID OverrideKillXp EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes","title":"OverrideKillXp event"},{"location":"tactical/OverrideKillXp/#tuple-contents","text":"Index Name Type Direction 0 KillXp float inout 1 BonusKillXp float inout 2 KillAssistXp float inout 3 WetWorkXp int inout 4 Killer XComGameState_Unit in","title":"Tuple contents"},{"location":"tactical/OverrideKillXp/#listener-template","text":"static function EventListenerReturn OnOverrideKillXp(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit KilledUnit; local XComLWTuple Tuple; local float KillXp; local float BonusKillXp; local float KillAssistXp; local int WetWorkXp; local XComGameState_Unit Killer; KilledUnit = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); KillXp = Tuple.Data[0].f; BonusKillXp = Tuple.Data[1].f; KillAssistXp = Tuple.Data[2].f; WetWorkXp = Tuple.Data[3].i; Killer = XComGameState_Unit(Tuple.Data[4].o); // Your code here Tuple.Data[0].f = KillXp; Tuple.Data[1].f = BonusKillXp; Tuple.Data[2].f = KillAssistXp; Tuple.Data[3].i = WetWorkXp; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideKillXp/#source-code-references","text":"XComGameState_Unit.uc:7085-7104 XComGameState_Unit.uc:6894","title":"Source code references"},{"location":"tactical/OverrideLostSpawnIncreaseFromUse/","text":"OverrideLostSpawnIncreaseFromUse Tracking Issue: #892 Normally, each ability template has its own LostSpawnIncreasePerUse value. When the ability is activated, this value is added to the \"bucket\" responsible for spawning additional Lost waves. When the \"bucket\" is filled, a wave of Lost spawns. This LostSpawnIncreasePerUse value is constant for each ability template; it does not depend on which weapon is used for the ability or any other context. The XComGameState_Unit::OnAbilityActivated triggers a OverrideLostSpawnIncreaseFromUse event, allowing mods to override the amount of Lost-attracting noise generated by abilities. EventID: OverrideLostSpawnIncreaseFromUse EventData: XComLWTuple { Data: [ inout int LostSpawnModifier, in XComGameState_Ability ActivatedAbilityState, ] } EventSource: self (XComGameState_Unit) GameState: yes Listeners for this event must use ELD_Immediate deferral. Example of an event listener function: static function EventListenerReturn ListenerEventFunction(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { local XComLWTuple OverrideTuple; local XComGameState_Ability AbilityState; local XComGameState_Item SourceWeapon, SourceAmmo; OverrideTuple = XComLWTuple(EventData); AbilityState = XComGameState_Ability(OverrideTuple.Data[1].o); if (AbilityState.GetMyTemplateName() == 'ThrowGrenade' || AbilityState.GetMyTemplateName() == 'LaunchGrenade') { SourceWeapon = AbilityState.GetSourceWeapon(); SourceAmmo = AbilityState.GetSourceAmmo(); if (SourceWeapon != none && SourceWeapon.GetMyTemplateName() == 'ProximityMine' || SourceAmmo != none && SourceAmmo.GetMyTemplateName() == 'ProximityMine') { // Override the amount of Lost-attracting noise generated by Proximity Mine if it is thrown or launched. OverrideTuple.Data[0].i = 0; } } return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:9906-9949","title":"OverrideLostSpawnIncreaseFromUse"},{"location":"tactical/OverrideLostSpawnIncreaseFromUse/#overridelostspawnincreasefromuse","text":"Tracking Issue: #892 Normally, each ability template has its own LostSpawnIncreasePerUse value. When the ability is activated, this value is added to the \"bucket\" responsible for spawning additional Lost waves. When the \"bucket\" is filled, a wave of Lost spawns. This LostSpawnIncreasePerUse value is constant for each ability template; it does not depend on which weapon is used for the ability or any other context. The XComGameState_Unit::OnAbilityActivated triggers a OverrideLostSpawnIncreaseFromUse event, allowing mods to override the amount of Lost-attracting noise generated by abilities. EventID: OverrideLostSpawnIncreaseFromUse EventData: XComLWTuple { Data: [ inout int LostSpawnModifier, in XComGameState_Ability ActivatedAbilityState, ] } EventSource: self (XComGameState_Unit) GameState: yes Listeners for this event must use ELD_Immediate deferral. Example of an event listener function: static function EventListenerReturn ListenerEventFunction(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { local XComLWTuple OverrideTuple; local XComGameState_Ability AbilityState; local XComGameState_Item SourceWeapon, SourceAmmo; OverrideTuple = XComLWTuple(EventData); AbilityState = XComGameState_Ability(OverrideTuple.Data[1].o); if (AbilityState.GetMyTemplateName() == 'ThrowGrenade' || AbilityState.GetMyTemplateName() == 'LaunchGrenade') { SourceWeapon = AbilityState.GetSourceWeapon(); SourceAmmo = AbilityState.GetSourceAmmo(); if (SourceWeapon != none && SourceWeapon.GetMyTemplateName() == 'ProximityMine' || SourceAmmo != none && SourceAmmo.GetMyTemplateName() == 'ProximityMine') { // Override the amount of Lost-attracting noise generated by Proximity Mine if it is thrown or launched. OverrideTuple.Data[0].i = 0; } } return ELR_NoInterrupt; }","title":"OverrideLostSpawnIncreaseFromUse"},{"location":"tactical/OverrideLostSpawnIncreaseFromUse/#source-code-references","text":"XComGameState_Unit.uc:9906-9949","title":"Source code references"},{"location":"tactical/OverrideMetaHitEffect/","text":"OverrideMetaHitEffect Tracking Issue: #1116 Tags: events Allows listeners to change the behavior of XComUnitPawn::PlayMetaHitEffect() . Meta Hit Effects are intended to communicate the overall effect of the attack, and include things like blood gushing out of the unit. Listeners can set OverrideMetaHitEffect to true , and then the default behavior will be omitted entirely, and no meta hit effect will be played. Alternatively, listeners can modify the parameters passed with the Tuple to modify the default behavior. OverrideMetaHitEffect event Param Value EventID OverrideMetaHitEffect EventData XComLWTuple EventSource XComUnitPawn NewGameState none Tuple contents Index Name Type Direction 0 OverrideMetaHitEffect bool inout 1 HitLocation vector inout 2 DamageTypeName name inout 3 Momentum vector inout 4 bIsUnitRuptured bool inout 5 HitResult enum (EAbilityHitResult) inout Listener template static function EventListenerReturn OnOverrideMetaHitEffect(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComUnitPawn Pawn; local XComLWTuple Tuple; local bool OverrideMetaHitEffect; local vector HitLocation; local name DamageTypeName; local vector Momentum; local bool bIsUnitRuptured; local EAbilityHitResult HitResult; Pawn = XComUnitPawn(EventSource); Tuple = XComLWTuple(EventData); OverrideMetaHitEffect = Tuple.Data[0].b; HitLocation = Tuple.Data[1].v; DamageTypeName = Tuple.Data[2].n; Momentum = Tuple.Data[3].v; bIsUnitRuptured = Tuple.Data[4].b; HitResult = EAbilityHitResult(Tuple.Data[5].i); // Your code here Tuple.Data[0].b = OverrideMetaHitEffect; Tuple.Data[1].v = HitLocation; Tuple.Data[2].n = DamageTypeName; Tuple.Data[3].v = Momentum; Tuple.Data[4].b = bIsUnitRuptured; Tuple.Data[5].i = HitResult; return ELR_NoInterrupt; } Source code references XComUnitPawn.uc:534-558","title":"OverrideMetaHitEffect"},{"location":"tactical/OverrideMetaHitEffect/#overridemetahiteffect","text":"Tracking Issue: #1116 Tags: events Allows listeners to change the behavior of XComUnitPawn::PlayMetaHitEffect() . Meta Hit Effects are intended to communicate the overall effect of the attack, and include things like blood gushing out of the unit. Listeners can set OverrideMetaHitEffect to true , and then the default behavior will be omitted entirely, and no meta hit effect will be played. Alternatively, listeners can modify the parameters passed with the Tuple to modify the default behavior.","title":"OverrideMetaHitEffect"},{"location":"tactical/OverrideMetaHitEffect/#overridemetahiteffect-event","text":"Param Value EventID OverrideMetaHitEffect EventData XComLWTuple EventSource XComUnitPawn NewGameState none","title":"OverrideMetaHitEffect event"},{"location":"tactical/OverrideMetaHitEffect/#tuple-contents","text":"Index Name Type Direction 0 OverrideMetaHitEffect bool inout 1 HitLocation vector inout 2 DamageTypeName name inout 3 Momentum vector inout 4 bIsUnitRuptured bool inout 5 HitResult enum (EAbilityHitResult) inout","title":"Tuple contents"},{"location":"tactical/OverrideMetaHitEffect/#listener-template","text":"static function EventListenerReturn OnOverrideMetaHitEffect(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComUnitPawn Pawn; local XComLWTuple Tuple; local bool OverrideMetaHitEffect; local vector HitLocation; local name DamageTypeName; local vector Momentum; local bool bIsUnitRuptured; local EAbilityHitResult HitResult; Pawn = XComUnitPawn(EventSource); Tuple = XComLWTuple(EventData); OverrideMetaHitEffect = Tuple.Data[0].b; HitLocation = Tuple.Data[1].v; DamageTypeName = Tuple.Data[2].n; Momentum = Tuple.Data[3].v; bIsUnitRuptured = Tuple.Data[4].b; HitResult = EAbilityHitResult(Tuple.Data[5].i); // Your code here Tuple.Data[0].b = OverrideMetaHitEffect; Tuple.Data[1].v = HitLocation; Tuple.Data[2].n = DamageTypeName; Tuple.Data[3].v = Momentum; Tuple.Data[4].b = bIsUnitRuptured; Tuple.Data[5].i = HitResult; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideMetaHitEffect/#source-code-references","text":"XComUnitPawn.uc:534-558","title":"Source code references"},{"location":"tactical/OverridePatrolBehavior/","text":"OverridePatrolBehavior Tracking Issue: #507 Tags: events The OverridePatrolBehavior event allows mods to override pods' patrol behavior. The bOverridePatrolBehavior component of the tuple should be set to true if the mod is overriding the patrol behavior and wants to bypass the default base game patrol logic. OverridePatrolBehavior event Param Value EventID OverridePatrolBehavior EventData XComLWTuple EventSource XComGameState_AIGroup NewGameState none Tuple contents Index Name Type Direction 0 bOverridePatrolBehavior bool out Listener template static function EventListenerReturn OnOverridePatrolBehavior(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_AIGroup AIGroup; local XComLWTuple Tuple; local bool bOverridePatrolBehavior; AIGroup = XComGameState_AIGroup(EventSource); Tuple = XComLWTuple(EventData); // Your code here Tuple.Data[0].b = bOverridePatrolBehavior; return ELR_NoInterrupt; } Source code references XComGameState_AIGroup.uc:490-501","title":"OverridePatrolBehavior"},{"location":"tactical/OverridePatrolBehavior/#overridepatrolbehavior","text":"Tracking Issue: #507 Tags: events The OverridePatrolBehavior event allows mods to override pods' patrol behavior. The bOverridePatrolBehavior component of the tuple should be set to true if the mod is overriding the patrol behavior and wants to bypass the default base game patrol logic.","title":"OverridePatrolBehavior"},{"location":"tactical/OverridePatrolBehavior/#overridepatrolbehavior-event","text":"Param Value EventID OverridePatrolBehavior EventData XComLWTuple EventSource XComGameState_AIGroup NewGameState none","title":"OverridePatrolBehavior event"},{"location":"tactical/OverridePatrolBehavior/#tuple-contents","text":"Index Name Type Direction 0 bOverridePatrolBehavior bool out","title":"Tuple contents"},{"location":"tactical/OverridePatrolBehavior/#listener-template","text":"static function EventListenerReturn OnOverridePatrolBehavior(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_AIGroup AIGroup; local XComLWTuple Tuple; local bool bOverridePatrolBehavior; AIGroup = XComGameState_AIGroup(EventSource); Tuple = XComLWTuple(EventData); // Your code here Tuple.Data[0].b = bOverridePatrolBehavior; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverridePatrolBehavior/#source-code-references","text":"XComGameState_AIGroup.uc:490-501","title":"Source code references"},{"location":"tactical/OverridePatrolDestination/","text":"OverridePatrolDestination Tracking Issue: #718 Tags: events Allow mods to override patrol locations from other alert data causes Listeners can set AllowThisCause to true to allow this AlertCause OverridePatrolDestination event Param Value EventID OverridePatrolDestination EventData XComLWTuple EventSource none NewGameState none Tuple contents Index Name Type Direction 0 AlertCause int in 1 AllowThisCause bool inout Listener template static function EventListenerReturn OnOverridePatrolDestination(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local int AlertCause; local bool AllowThisCause; Tuple = XComLWTuple(EventData); AlertCause = Tuple.Data[0].i; AllowThisCause = Tuple.Data[1].b; // Your code here Tuple.Data[1].b = AllowThisCause; return ELR_NoInterrupt; } Source code references XGAIPatrolGroup.uc:152-160","title":"OverridePatrolDestination"},{"location":"tactical/OverridePatrolDestination/#overridepatroldestination","text":"Tracking Issue: #718 Tags: events Allow mods to override patrol locations from other alert data causes Listeners can set AllowThisCause to true to allow this AlertCause","title":"OverridePatrolDestination"},{"location":"tactical/OverridePatrolDestination/#overridepatroldestination-event","text":"Param Value EventID OverridePatrolDestination EventData XComLWTuple EventSource none NewGameState none","title":"OverridePatrolDestination event"},{"location":"tactical/OverridePatrolDestination/#tuple-contents","text":"Index Name Type Direction 0 AlertCause int in 1 AllowThisCause bool inout","title":"Tuple contents"},{"location":"tactical/OverridePatrolDestination/#listener-template","text":"static function EventListenerReturn OnOverridePatrolDestination(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local int AlertCause; local bool AllowThisCause; Tuple = XComLWTuple(EventData); AlertCause = Tuple.Data[0].i; AllowThisCause = Tuple.Data[1].b; // Your code here Tuple.Data[1].b = AllowThisCause; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverridePatrolDestination/#source-code-references","text":"XGAIPatrolGroup.uc:152-160","title":"Source code references"},{"location":"tactical/OverrideProjectileInstance/","text":"OverrideProjectileInstance Tracking Issue: #829 Tags: events Allows listeners to override the parameters of SpawnAndConfigureNewProjectile. The feature also introduces support for subclasses of X2UnifiedProjectile as custom projectile archetypes. If bPreventProjectileSpawning is set to true the projectile instance will NOT be spawned. If your subclass of X2UnifiedProjectile overrides any of the functions that handle Particle System Components, it's important to preserve changes implemented by Issue #720: ProjectilePerformanceDrain OverrideProjectileInstance event Param Value EventID OverrideProjectileInstance EventData XComLWTuple EventSource XComGameStateContext_Ability NewGameState none Tuple contents Index Name Type Direction 0 bPreventProjectileSpawning bool out 1 ProjectileTemplate Actor inout 2 InVolleyNotify AnimNotify_FireWeaponVolley inout 3 InSourceWeapon XComWeapon inout 4 CurrentFireAction X2Action_Fire inout 5 Unit XGUnitNativeBase in Listener template static function EventListenerReturn OnOverrideProjectileInstance(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameStateContext_Ability AbilityContext; local XComLWTuple Tuple; local bool bPreventProjectileSpawning; local Actor ProjectileTemplate; local AnimNotify_FireWeaponVolley InVolleyNotify; local XComWeapon InSourceWeapon; local X2Action_Fire CurrentFireAction; local XGUnitNativeBase Unit; AbilityContext = XComGameStateContext_Ability(EventSource); Tuple = XComLWTuple(EventData); ProjectileTemplate = Actor(Tuple.Data[1].o); InVolleyNotify = AnimNotify_FireWeaponVolley(Tuple.Data[2].o); InSourceWeapon = XComWeapon(Tuple.Data[3].o); CurrentFireAction = X2Action_Fire(Tuple.Data[4].o); Unit = XGUnitNativeBase(Tuple.Data[5].o); // Your code here Tuple.Data[0].b = bPreventProjectileSpawning; Tuple.Data[1].o = ProjectileTemplate; Tuple.Data[2].o = InVolleyNotify; Tuple.Data[3].o = InSourceWeapon; Tuple.Data[4].o = CurrentFireAction; return ELR_NoInterrupt; } Source code references XGUnitNativeBase.uc:1617-1637","title":"OverrideProjectileInstance"},{"location":"tactical/OverrideProjectileInstance/#overrideprojectileinstance","text":"Tracking Issue: #829 Tags: events Allows listeners to override the parameters of SpawnAndConfigureNewProjectile. The feature also introduces support for subclasses of X2UnifiedProjectile as custom projectile archetypes. If bPreventProjectileSpawning is set to true the projectile instance will NOT be spawned. If your subclass of X2UnifiedProjectile overrides any of the functions that handle Particle System Components, it's important to preserve changes implemented by Issue #720: ProjectilePerformanceDrain","title":"OverrideProjectileInstance"},{"location":"tactical/OverrideProjectileInstance/#overrideprojectileinstance-event","text":"Param Value EventID OverrideProjectileInstance EventData XComLWTuple EventSource XComGameStateContext_Ability NewGameState none","title":"OverrideProjectileInstance event"},{"location":"tactical/OverrideProjectileInstance/#tuple-contents","text":"Index Name Type Direction 0 bPreventProjectileSpawning bool out 1 ProjectileTemplate Actor inout 2 InVolleyNotify AnimNotify_FireWeaponVolley inout 3 InSourceWeapon XComWeapon inout 4 CurrentFireAction X2Action_Fire inout 5 Unit XGUnitNativeBase in","title":"Tuple contents"},{"location":"tactical/OverrideProjectileInstance/#listener-template","text":"static function EventListenerReturn OnOverrideProjectileInstance(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameStateContext_Ability AbilityContext; local XComLWTuple Tuple; local bool bPreventProjectileSpawning; local Actor ProjectileTemplate; local AnimNotify_FireWeaponVolley InVolleyNotify; local XComWeapon InSourceWeapon; local X2Action_Fire CurrentFireAction; local XGUnitNativeBase Unit; AbilityContext = XComGameStateContext_Ability(EventSource); Tuple = XComLWTuple(EventData); ProjectileTemplate = Actor(Tuple.Data[1].o); InVolleyNotify = AnimNotify_FireWeaponVolley(Tuple.Data[2].o); InSourceWeapon = XComWeapon(Tuple.Data[3].o); CurrentFireAction = X2Action_Fire(Tuple.Data[4].o); Unit = XGUnitNativeBase(Tuple.Data[5].o); // Your code here Tuple.Data[0].b = bPreventProjectileSpawning; Tuple.Data[1].o = ProjectileTemplate; Tuple.Data[2].o = InVolleyNotify; Tuple.Data[3].o = InSourceWeapon; Tuple.Data[4].o = CurrentFireAction; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideProjectileInstance/#source-code-references","text":"XGUnitNativeBase.uc:1617-1637","title":"Source code references"},{"location":"tactical/OverrideReactionFireSlomo/","text":"OverrideReactionFireSlomo Tracking Issue: #996 Tags: events Normally cinematic slo-mo is automatically added to abilities that use X2AbilityToHitCalc_StandardAim (or its subclass) with bReactionFire = true , which will also modify the ability's hit chance. The OverrideReactionFireSlomo event allows mods to add cinematic slo-mo to non-reaction abilities, and remove cinematic slo-mo from reaction abilities. FiringAbilityContext can be used to access ability's Template Name: FiringAbilityContext.InputContext.AbilityTemplateName . OverrideReactionFireSlomo event Param Value EventID OverrideReactionFireSlomo EventData XComLWTuple EventSource X2ReactionFireSequencer NewGameState none Tuple contents Index Name Type Direction 0 bIsReactionFire bool inout 1 FiringAbilityContext XComGameStateContext_Ability in Listener template static function EventListenerReturn OnOverrideReactionFireSlomo(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local X2ReactionFireSequencer ReactionFireSequencer; local XComLWTuple Tuple; local bool bIsReactionFire; local XComGameStateContext_Ability FiringAbilityContext; ReactionFireSequencer = X2ReactionFireSequencer(EventSource); Tuple = XComLWTuple(EventData); bIsReactionFire = Tuple.Data[0].b; FiringAbilityContext = XComGameStateContext_Ability(Tuple.Data[1].o); // Your code here Tuple.Data[0].b = bIsReactionFire; return ELR_NoInterrupt; } Source code references X2ReactionFireSequencer.uc:51-66","title":"OverrideReactionFireSlomo"},{"location":"tactical/OverrideReactionFireSlomo/#overridereactionfireslomo","text":"Tracking Issue: #996 Tags: events Normally cinematic slo-mo is automatically added to abilities that use X2AbilityToHitCalc_StandardAim (or its subclass) with bReactionFire = true , which will also modify the ability's hit chance. The OverrideReactionFireSlomo event allows mods to add cinematic slo-mo to non-reaction abilities, and remove cinematic slo-mo from reaction abilities. FiringAbilityContext can be used to access ability's Template Name: FiringAbilityContext.InputContext.AbilityTemplateName .","title":"OverrideReactionFireSlomo"},{"location":"tactical/OverrideReactionFireSlomo/#overridereactionfireslomo-event","text":"Param Value EventID OverrideReactionFireSlomo EventData XComLWTuple EventSource X2ReactionFireSequencer NewGameState none","title":"OverrideReactionFireSlomo event"},{"location":"tactical/OverrideReactionFireSlomo/#tuple-contents","text":"Index Name Type Direction 0 bIsReactionFire bool inout 1 FiringAbilityContext XComGameStateContext_Ability in","title":"Tuple contents"},{"location":"tactical/OverrideReactionFireSlomo/#listener-template","text":"static function EventListenerReturn OnOverrideReactionFireSlomo(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local X2ReactionFireSequencer ReactionFireSequencer; local XComLWTuple Tuple; local bool bIsReactionFire; local XComGameStateContext_Ability FiringAbilityContext; ReactionFireSequencer = X2ReactionFireSequencer(EventSource); Tuple = XComLWTuple(EventData); bIsReactionFire = Tuple.Data[0].b; FiringAbilityContext = XComGameStateContext_Ability(Tuple.Data[1].o); // Your code here Tuple.Data[0].b = bIsReactionFire; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideReactionFireSlomo/#source-code-references","text":"X2ReactionFireSequencer.uc:51-66","title":"Source code references"},{"location":"tactical/OverrideUnitFocusUI/","text":"OverrideUnitFocusUI Tracking Issue: #257 Tags: compatibility , events This focus change allows mods to change the focus UI that the vanilla game uses to display Templar Focus. This effectively creates different types of Focus, even though the game does not know about this. For example, you can create a custom soldier class with its own type of focus, tracked with a UnitValue . This imposes a few limitations on the system: A given unit only ever has a single \"type\" of focus. The rules for different focus types are expected to be so different from one another to make any conflicts a painful experience for modders and players. In particular, it means that this function should NOT be used to make any changes to the Templar Focus, as tempting as it may be. This also includes an Effect of the name TemplarFocus or an Effect Class of the type XComGameState_Effect_TemplarFocus . In order to add your custom focus types, there are two changes in XComGame you can use: A new event hook for UIUnitFlag and UITacticalHUD_SoldierInfo : Documentation for that particular hook is directly below. A change in X2AbilityCost_Focus : You may subclass that particular class and override all functions declared there ( CanAfford , ApplyCost , PreviewFocusCost ). This can be used to preview a cost for custom skills that consume focus. Again, make sure to not mix and match custom subclasses with the base class for any abilities. OverrideUnitFocusUI event Param Value EventID OverrideUnitFocusUI EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 bVisible bool inout 1 currentFocus int inout 2 maxFoxus int inout 3 color string inout 4 iconPath string inout 5 tooltipText string inout 6 focusLabel string inout Listener template static function EventListenerReturn OnOverrideUnitFocusUI(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit SourceUnit; local XComLWTuple Tuple; local bool bVisible; local int currentFocus; local int maxFoxus; local string color; local string iconPath; local string tooltipText; local string focusLabel; SourceUnit = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bVisible = Tuple.Data[0].b; currentFocus = Tuple.Data[1].i; maxFoxus = Tuple.Data[2].i; color = Tuple.Data[3].s; iconPath = Tuple.Data[4].s; tooltipText = Tuple.Data[5].s; focusLabel = Tuple.Data[6].s; // Your code here Tuple.Data[0].b = bVisible; Tuple.Data[1].i = currentFocus; Tuple.Data[2].i = maxFoxus; Tuple.Data[3].s = color; Tuple.Data[4].s = iconPath; Tuple.Data[5].s = tooltipText; Tuple.Data[6].s = focusLabel; return ELR_NoInterrupt; } Note that if bVisible == false , the rest will be ignored and will not have valid data in it. Compatibility If you override UIUnitFlag , your code may undo the HL's changes that support this feature in the UI. See the tracking issue for code samples. Source code references CHHelpers.uc:518-562","title":"OverrideUnitFocusUI"},{"location":"tactical/OverrideUnitFocusUI/#overrideunitfocusui","text":"Tracking Issue: #257 Tags: compatibility , events This focus change allows mods to change the focus UI that the vanilla game uses to display Templar Focus. This effectively creates different types of Focus, even though the game does not know about this. For example, you can create a custom soldier class with its own type of focus, tracked with a UnitValue . This imposes a few limitations on the system: A given unit only ever has a single \"type\" of focus. The rules for different focus types are expected to be so different from one another to make any conflicts a painful experience for modders and players. In particular, it means that this function should NOT be used to make any changes to the Templar Focus, as tempting as it may be. This also includes an Effect of the name TemplarFocus or an Effect Class of the type XComGameState_Effect_TemplarFocus . In order to add your custom focus types, there are two changes in XComGame you can use: A new event hook for UIUnitFlag and UITacticalHUD_SoldierInfo : Documentation for that particular hook is directly below. A change in X2AbilityCost_Focus : You may subclass that particular class and override all functions declared there ( CanAfford , ApplyCost , PreviewFocusCost ). This can be used to preview a cost for custom skills that consume focus. Again, make sure to not mix and match custom subclasses with the base class for any abilities.","title":"OverrideUnitFocusUI"},{"location":"tactical/OverrideUnitFocusUI/#overrideunitfocusui-event","text":"Param Value EventID OverrideUnitFocusUI EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"OverrideUnitFocusUI event"},{"location":"tactical/OverrideUnitFocusUI/#tuple-contents","text":"Index Name Type Direction 0 bVisible bool inout 1 currentFocus int inout 2 maxFoxus int inout 3 color string inout 4 iconPath string inout 5 tooltipText string inout 6 focusLabel string inout","title":"Tuple contents"},{"location":"tactical/OverrideUnitFocusUI/#listener-template","text":"static function EventListenerReturn OnOverrideUnitFocusUI(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit SourceUnit; local XComLWTuple Tuple; local bool bVisible; local int currentFocus; local int maxFoxus; local string color; local string iconPath; local string tooltipText; local string focusLabel; SourceUnit = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bVisible = Tuple.Data[0].b; currentFocus = Tuple.Data[1].i; maxFoxus = Tuple.Data[2].i; color = Tuple.Data[3].s; iconPath = Tuple.Data[4].s; tooltipText = Tuple.Data[5].s; focusLabel = Tuple.Data[6].s; // Your code here Tuple.Data[0].b = bVisible; Tuple.Data[1].i = currentFocus; Tuple.Data[2].i = maxFoxus; Tuple.Data[3].s = color; Tuple.Data[4].s = iconPath; Tuple.Data[5].s = tooltipText; Tuple.Data[6].s = focusLabel; return ELR_NoInterrupt; } Note that if bVisible == false , the rest will be ignored and will not have valid data in it.","title":"Listener template"},{"location":"tactical/OverrideUnitFocusUI/#compatibility","text":"If you override UIUnitFlag , your code may undo the HL's changes that support this feature in the UI. See the tracking issue for code samples.","title":"Compatibility"},{"location":"tactical/OverrideUnitFocusUI/#source-code-references","text":"CHHelpers.uc:518-562","title":"Source code references"},{"location":"tactical/PersonalitySpeech/","text":"PersonalitySpeech Tracking Issue: #317 Tags: customization The soldier speech system allows soldiers to use different voicelines in some situations based on their attitude. For example, an \"Intense\" soldier will voice react differently to killing an enemy than a \"Twitchy\" one. This behavior was hardcoded in the base game. Highlander replaces the original implementation with the PersonalitySpeech config array that takes values from XComGame.ini config file. This potentailly allows mods to replace the original personality speech patterns, as well as add new patterns for new attitudes, if a mod manages to add any. Example entry for the \"By The Book\" attitude: [XComGame.CHHelpers] +PersonalitySpeech=( Personality=\"Personality_ByTheBook\", \\\\ CharSpeeches = ( \\\\ (CharSpeech=\"Moving\", PersonalityVariant=(\"Moving_BY_THE_BOOK\")), \\\\ (CharSpeech=\"TargetKilled\", PersonalityVariant=(\"TargetKilled_BY_THE_BOOK\")), \\\\ (CharSpeech=\"Panic\", PersonalityVariant=(\"Panic_BY_THE_BOOK\")), \\\\ (CharSpeech=\"SoldierVIP\", PersonalityVariant=(\"SoldierVIP_BY_THE_BOOK\")), \\\\ (CharSpeech=\"UsefulVIP\", PersonalityVariant=(\"UsefulVIP_BY_THE_BOOK\")), \\\\ (CharSpeech=\"GenericVIP\", PersonalityVariant=(\"GenericVIP_BY_THE_BOOK\")), \\\\ (CharSpeech=\"HostileVIP\", PersonalityVariant=(\"HostileVIP_BY_THE_BOOK\")), \\\\ (CharSpeech=\"LootCaptured\", PersonalityVariant=(\"LootCaptured_BY_THE_BOOK\")), \\\\ (CharSpeech=\"HackWorkstation\", PersonalityVariant=(\"HackWorkstation_BY_THE_BOOK\")), \\\\ (CharSpeech=\"LootSpotted\", PersonalityVariant=(\"LootSpotted_BY_THE_BOOK\")), \\\\ (CharSpeech=\"TargetEliminated\", PersonalityVariant=(\"TargetEliminated_BY_THE_BOOK\")), \\\\ (CharSpeech=\"PickingUpBody\", PersonalityVariant=(\"PickingUpBody_BY_THE_BOOK\")) \\\\ )) Note: only one PersonalitySpeech entry per attitude will be taken into account, any others will be ignored. If your mod wants to replace the original speech personality config with your own, you should copy the original entry to their own config exactly as it appears in the Highlander, and replace the + at the start of the entry with a - , which will remove the entry when your mod is loaded. Then you can specify your own config entry for that attitude below. Source code references XGUnit.uc:1546-1579 XComGame.ini:57 CHHelpers.uc:139","title":"PersonalitySpeech"},{"location":"tactical/PersonalitySpeech/#personalityspeech","text":"Tracking Issue: #317 Tags: customization The soldier speech system allows soldiers to use different voicelines in some situations based on their attitude. For example, an \"Intense\" soldier will voice react differently to killing an enemy than a \"Twitchy\" one. This behavior was hardcoded in the base game. Highlander replaces the original implementation with the PersonalitySpeech config array that takes values from XComGame.ini config file. This potentailly allows mods to replace the original personality speech patterns, as well as add new patterns for new attitudes, if a mod manages to add any. Example entry for the \"By The Book\" attitude: [XComGame.CHHelpers] +PersonalitySpeech=( Personality=\"Personality_ByTheBook\", \\\\ CharSpeeches = ( \\\\ (CharSpeech=\"Moving\", PersonalityVariant=(\"Moving_BY_THE_BOOK\")), \\\\ (CharSpeech=\"TargetKilled\", PersonalityVariant=(\"TargetKilled_BY_THE_BOOK\")), \\\\ (CharSpeech=\"Panic\", PersonalityVariant=(\"Panic_BY_THE_BOOK\")), \\\\ (CharSpeech=\"SoldierVIP\", PersonalityVariant=(\"SoldierVIP_BY_THE_BOOK\")), \\\\ (CharSpeech=\"UsefulVIP\", PersonalityVariant=(\"UsefulVIP_BY_THE_BOOK\")), \\\\ (CharSpeech=\"GenericVIP\", PersonalityVariant=(\"GenericVIP_BY_THE_BOOK\")), \\\\ (CharSpeech=\"HostileVIP\", PersonalityVariant=(\"HostileVIP_BY_THE_BOOK\")), \\\\ (CharSpeech=\"LootCaptured\", PersonalityVariant=(\"LootCaptured_BY_THE_BOOK\")), \\\\ (CharSpeech=\"HackWorkstation\", PersonalityVariant=(\"HackWorkstation_BY_THE_BOOK\")), \\\\ (CharSpeech=\"LootSpotted\", PersonalityVariant=(\"LootSpotted_BY_THE_BOOK\")), \\\\ (CharSpeech=\"TargetEliminated\", PersonalityVariant=(\"TargetEliminated_BY_THE_BOOK\")), \\\\ (CharSpeech=\"PickingUpBody\", PersonalityVariant=(\"PickingUpBody_BY_THE_BOOK\")) \\\\ )) Note: only one PersonalitySpeech entry per attitude will be taken into account, any others will be ignored. If your mod wants to replace the original speech personality config with your own, you should copy the original entry to their own config exactly as it appears in the Highlander, and replace the + at the start of the entry with a - , which will remove the entry when your mod is loaded. Then you can specify your own config entry for that attitude below.","title":"PersonalitySpeech"},{"location":"tactical/PersonalitySpeech/#source-code-references","text":"XGUnit.uc:1546-1579 XComGame.ini:57 CHHelpers.uc:139","title":"Source code references"},{"location":"tactical/PlaceEvacZoneAbilityName/","text":"PlaceEvacZoneAbilityName Tracking Issue: #855 Config variable (of type name) that allows mods to override the name of the ability used for placing/throwing evac zones in tactical missions. This is because the base game hard codes the ability name used for the controller's R3 button, which is bad if a mod (like LWOTC) replaces PlaceEvacZone with a different ability. Note that this variable only affects the input system. If you want to replace the ability itself, you will still need to do the hard work of creating the new ability, giving it to soldiers, handling evac zone destruction, etc. Source code references CHHelpers.uc:190-200","title":"PlaceEvacZoneAbilityName"},{"location":"tactical/PlaceEvacZoneAbilityName/#placeevaczoneabilityname","text":"Tracking Issue: #855 Config variable (of type name) that allows mods to override the name of the ability used for placing/throwing evac zones in tactical missions. This is because the base game hard codes the ability name used for the controller's R3 button, which is bad if a mod (like LWOTC) replaces PlaceEvacZone with a different ability. Note that this variable only affects the input system. If you want to replace the ability itself, you will still need to do the hard work of creating the new ability, giving it to soldiers, handling evac zone destruction, etc.","title":"PlaceEvacZoneAbilityName"},{"location":"tactical/PlaceEvacZoneAbilityName/#source-code-references","text":"CHHelpers.uc:190-200","title":"Source code references"},{"location":"tactical/PlayKnockback/","text":"PlayKnockback Tracking Issue: #1463 This feature allows animations to be played for alive units being knocked down. Modders wanting to use this feature only need to create new animation sets and add them to pawns. Animation selection is done in X2Action_Knockback::ComputeAnimationToPlay , which looks for the following animations: HL_MeleeKnockback : default animation used when an unit being knocked back doesn't move any tiles, or if the ability being used is a melee ability and bOverrideMeleeDeath is false, and the weapon being used has bOverrideMeleeDeath set as false HL_Knockback , HL_KnockbackRight , HL_KnockbackLeft : animation used depending on how the victim is facing the source of the attack. In most cases, units are facing each other, so HL_Knockback will be used much frequently than these two others. HL_\"$OverrideAnimEffectString$\"Knockback , HL_\"$OverrideAnimEffectString$\"KnockbackRight , HL_\"$OverrideAnimEffectString$\"KnockbackLeft : special animation determined by the highest ranking X2Effect_Persistent the victim unit is affected by. For example, if the victim is mind controlled, it would look for HL_MindControlKnockback . If the pawn doesn't have such special animation in their animsets, it will default to HL_Knockback . CustomKnockbackAnimationName : override animation name: if this variable has been set in X2Action_Knockback , it will select this animation name over anything else. As for how to set this variable, see this example on how it's done in X2Action_Death . After animation is selected, it will ragdoll the pawn and play the corresponding animation on it. If selected animation doesn't exist in the pawns animsets, it will only ragdoll the unit. Source code references XComUnitPawn.uc:867-878 X2Action_Knockback.uc:99 X2Action_Knockback.uc:323","title":"PlayKnockback"},{"location":"tactical/PlayKnockback/#playknockback","text":"Tracking Issue: #1463 This feature allows animations to be played for alive units being knocked down. Modders wanting to use this feature only need to create new animation sets and add them to pawns. Animation selection is done in X2Action_Knockback::ComputeAnimationToPlay , which looks for the following animations: HL_MeleeKnockback : default animation used when an unit being knocked back doesn't move any tiles, or if the ability being used is a melee ability and bOverrideMeleeDeath is false, and the weapon being used has bOverrideMeleeDeath set as false HL_Knockback , HL_KnockbackRight , HL_KnockbackLeft : animation used depending on how the victim is facing the source of the attack. In most cases, units are facing each other, so HL_Knockback will be used much frequently than these two others. HL_\"$OverrideAnimEffectString$\"Knockback , HL_\"$OverrideAnimEffectString$\"KnockbackRight , HL_\"$OverrideAnimEffectString$\"KnockbackLeft : special animation determined by the highest ranking X2Effect_Persistent the victim unit is affected by. For example, if the victim is mind controlled, it would look for HL_MindControlKnockback . If the pawn doesn't have such special animation in their animsets, it will default to HL_Knockback . CustomKnockbackAnimationName : override animation name: if this variable has been set in X2Action_Knockback , it will select this animation name over anything else. As for how to set this variable, see this example on how it's done in X2Action_Death . After animation is selected, it will ragdoll the pawn and play the corresponding animation on it. If selected animation doesn't exist in the pawns animsets, it will only ragdoll the unit.","title":"PlayKnockback"},{"location":"tactical/PlayKnockback/#source-code-references","text":"XComUnitPawn.uc:867-878 X2Action_Knockback.uc:99 X2Action_Knockback.uc:323","title":"Source code references"},{"location":"tactical/PostAliensSpawned/","text":"PostAliensSpawned Tracking Issue: #457 This event triggers right after the alien pods are added into the tactical mission's Start State, before their visualizers are spawned/visualized. Overall it can be treated as an earlier alternative to 'OnTacticalBeginPlay' event. It can be used to make arbitrary changes to units that were just added to the Start State, including Soldier VIPs that are spawned for Gather Survivors missions. For example, this is how to set up an Event Listener to modify these Soldier VIPs: // This EventFn requires an ELD_Immediate deferral. static protected function EventListenerReturn PostAliensSpawned_Listener(Object EventData, Object EventSource, XComGameState StartState, Name EventID, Object CallbackData) { local XComTacticalMissionManager MissionManager; local XComGameState_Unit UnitState; local XComGameState_AIGroup GroupState; MissionManager = `TACTICALMISSIONMGR; if (MissionManager.ActiveMission.sType == \"GatherSurvivors\") { // Cycle through Group States, which are basically Game States for pods. foreach GameState.IterateByClassType(class'XComGameState_AIGroup', GroupState) { // Check the pod for correct markings. if (GroupState.EncounterID == 'ResistanceTeamMember_VIP' && GroupState.PrePlacedEncounterTag == 'ResistanceTeamMember_01') { // Assume the pod contains only one unit and grab the Unit State for it. UnitState = XComGameState_Unit(GameState.GetGameStateForObjectID(GroupState.m_arrMembers[0].ObjectID)); if (UnitState != none) { // Make arbitrary changes to the Unit here. } } // Do the same for GroupState.PrePlacedEncounterTag == 'ResistanceTeamMember_02' here. } } return ELR_NoInterrupt; } EventID: PostAliensSpawned NewGameState: StartState Source code references X2TacticalGameRuleset.uc:2480-2520","title":"PostAliensSpawned"},{"location":"tactical/PostAliensSpawned/#postaliensspawned","text":"Tracking Issue: #457 This event triggers right after the alien pods are added into the tactical mission's Start State, before their visualizers are spawned/visualized. Overall it can be treated as an earlier alternative to 'OnTacticalBeginPlay' event. It can be used to make arbitrary changes to units that were just added to the Start State, including Soldier VIPs that are spawned for Gather Survivors missions. For example, this is how to set up an Event Listener to modify these Soldier VIPs: // This EventFn requires an ELD_Immediate deferral. static protected function EventListenerReturn PostAliensSpawned_Listener(Object EventData, Object EventSource, XComGameState StartState, Name EventID, Object CallbackData) { local XComTacticalMissionManager MissionManager; local XComGameState_Unit UnitState; local XComGameState_AIGroup GroupState; MissionManager = `TACTICALMISSIONMGR; if (MissionManager.ActiveMission.sType == \"GatherSurvivors\") { // Cycle through Group States, which are basically Game States for pods. foreach GameState.IterateByClassType(class'XComGameState_AIGroup', GroupState) { // Check the pod for correct markings. if (GroupState.EncounterID == 'ResistanceTeamMember_VIP' && GroupState.PrePlacedEncounterTag == 'ResistanceTeamMember_01') { // Assume the pod contains only one unit and grab the Unit State for it. UnitState = XComGameState_Unit(GameState.GetGameStateForObjectID(GroupState.m_arrMembers[0].ObjectID)); if (UnitState != none) { // Make arbitrary changes to the Unit here. } } // Do the same for GroupState.PrePlacedEncounterTag == 'ResistanceTeamMember_02' here. } } return ELR_NoInterrupt; } EventID: PostAliensSpawned NewGameState: StartState","title":"PostAliensSpawned"},{"location":"tactical/PostAliensSpawned/#source-code-references","text":"X2TacticalGameRuleset.uc:2480-2520","title":"Source code references"},{"location":"tactical/PostMissionIntroKismet/","text":"PostMissionIntroKismet Tracking Issue: #1406 Tags: events This event triggers after mission intro kismet has been completed. For example, a mission such as Supply Extraction spawns their objective crates when 'SeqEvent_OnTacticalMissionStartBlocking' has been triggered, which happens after 'OnBeginTacticalPlay' event has already been triggered. As such, you don't have a handle for anything the mission kismet causes before your first XCOM turn. This event can be considered a later alternative to 'OnBeginTacticalPlay' event. PostMissionIntroKismet event Param Value EventID PostMissionIntroKismet EventData none EventSource none NewGameState none Listener template static function EventListenerReturn OnPostMissionIntroKismet(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { // Your code here return ELR_NoInterrupt; } Source code references X2TacticalGameRuleset.uc:3920-3933 X2TacticalGameRuleset.uc:4290","title":"PostMissionIntroKismet"},{"location":"tactical/PostMissionIntroKismet/#postmissionintrokismet","text":"Tracking Issue: #1406 Tags: events This event triggers after mission intro kismet has been completed. For example, a mission such as Supply Extraction spawns their objective crates when 'SeqEvent_OnTacticalMissionStartBlocking' has been triggered, which happens after 'OnBeginTacticalPlay' event has already been triggered. As such, you don't have a handle for anything the mission kismet causes before your first XCOM turn. This event can be considered a later alternative to 'OnBeginTacticalPlay' event.","title":"PostMissionIntroKismet"},{"location":"tactical/PostMissionIntroKismet/#postmissionintrokismet-event","text":"Param Value EventID PostMissionIntroKismet EventData none EventSource none NewGameState none","title":"PostMissionIntroKismet event"},{"location":"tactical/PostMissionIntroKismet/#listener-template","text":"static function EventListenerReturn OnPostMissionIntroKismet(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/PostMissionIntroKismet/#source-code-references","text":"X2TacticalGameRuleset.uc:3920-3933 X2TacticalGameRuleset.uc:4290","title":"Source code references"},{"location":"tactical/PostModifyNewAbilityContext/","text":"PostModifyNewAbilityContext Tracking Issue: #890 The XComGameStateContext_Ability::ActivateAbility_Internal triggers a PostModifyNewAbilityContext event, allowing mods to make changes to Ability Context. The event triggers after the ability has gathered targets using its TargetStyles, after ToHitCalc calculations, and after the ability has ran its ModifyNewContextFn delegate, if it has one. Modifying Ability Context is a powerful tool, as it allows to arbitrarily change ability's Hit Result, change its intended targets and hit location. If you yourself are adding an ability that could benefit from context modification, you should probably just use the ModifyNewContextFn delegate. This event is mostly intended for modifying Ability Context of base game abilities, or abilities added by other mods, so you don't have to risk an incompatibility by adding your own ModifyNewContextFn delegate to somebody else's ability. Listeners for this event must use ELD_Immediate deferral. EventID: PostModifyNewAbilityContext EventData: XComGameStateContext_Ability NewContext EventSource: XComGameState_Ability AbilityState NewGameState: no Source code references XComGameStateContext_Ability.uc:1518-1532","title":"PostModifyNewAbilityContext"},{"location":"tactical/PostModifyNewAbilityContext/#postmodifynewabilitycontext","text":"Tracking Issue: #890 The XComGameStateContext_Ability::ActivateAbility_Internal triggers a PostModifyNewAbilityContext event, allowing mods to make changes to Ability Context. The event triggers after the ability has gathered targets using its TargetStyles, after ToHitCalc calculations, and after the ability has ran its ModifyNewContextFn delegate, if it has one. Modifying Ability Context is a powerful tool, as it allows to arbitrarily change ability's Hit Result, change its intended targets and hit location. If you yourself are adding an ability that could benefit from context modification, you should probably just use the ModifyNewContextFn delegate. This event is mostly intended for modifying Ability Context of base game abilities, or abilities added by other mods, so you don't have to risk an incompatibility by adding your own ModifyNewContextFn delegate to somebody else's ability. Listeners for this event must use ELD_Immediate deferral. EventID: PostModifyNewAbilityContext EventData: XComGameStateContext_Ability NewContext EventSource: XComGameState_Ability AbilityState NewGameState: no","title":"PostModifyNewAbilityContext"},{"location":"tactical/PostModifyNewAbilityContext/#source-code-references","text":"XComGameStateContext_Ability.uc:1518-1532","title":"Source code references"},{"location":"tactical/PrioritizeRightClickMelee/","text":"PrioritizeRightClickMelee Tracking Issue: #1138 This feature allows mods to override the logic for selecting the ability that should be used when the player triggers a right-click melee action on a target. How to use Implement the following code in your mod's class that extends X2DownloadableContentInfo : static event OnPostTemplatesCreated() { local CHHelpers CHHelpersObj; CHHelpersObj = class'CHHelpers'.static.GetCDO(); if (CHHelpersObj != none) { CHHelpersObj.AddPrioritizeRightClickMeleeCallback(PrioritizeRightClickMelee); } } // To avoid crashes associated with garbage collection failure when transitioning between Tactical and Strategy, // this function must be bound to the ClassDefaultObject of your class. Having this function in a class that // `extends X2DownloadableContentInfo` is the easiest way to ensure that. static private function EHLDelegateReturn PrioritizeRightClickMelee(XComGameState_Unit UnitState, out XComGameState_Ability PrioritizedMeleeAbility, optional XComGameState_BaseObject TargetObject) { # Delegate Priority You can optionally specify callback Priority. The default Priority is 50. ```unrealscript CHHelpersObj.AddPrioritizeRightClickMeleeCallback(PrioritizeRightClickMelee, 45); Delegates with higher Priority value are executed first. Delegates with the same Priority are executed in the order they were added to CHHelpers, which would normally be the same as DLCRunOrder . This function will return true if the delegate was successfully registered. Removing Delegates If necessary, use this function to remove a delegate. CHHelpersObj.RemovePrioritizeRightClickMeleeCallback(PrioritizeRightClickMelee); The function will return true if the Callback was successfully deleted, return false otherwise. Source code references X2AbilityTrigger_EndOfMove.uc:31-54 CHHelpers.uc:1014-1023 CHHelpers.uc:1061-1067","title":"PrioritizeRightClickMelee"},{"location":"tactical/PrioritizeRightClickMelee/#prioritizerightclickmelee","text":"Tracking Issue: #1138 This feature allows mods to override the logic for selecting the ability that should be used when the player triggers a right-click melee action on a target.","title":"PrioritizeRightClickMelee"},{"location":"tactical/PrioritizeRightClickMelee/#how-to-use","text":"Implement the following code in your mod's class that extends X2DownloadableContentInfo : static event OnPostTemplatesCreated() { local CHHelpers CHHelpersObj; CHHelpersObj = class'CHHelpers'.static.GetCDO(); if (CHHelpersObj != none) { CHHelpersObj.AddPrioritizeRightClickMeleeCallback(PrioritizeRightClickMelee); } } // To avoid crashes associated with garbage collection failure when transitioning between Tactical and Strategy, // this function must be bound to the ClassDefaultObject of your class. Having this function in a class that // `extends X2DownloadableContentInfo` is the easiest way to ensure that. static private function EHLDelegateReturn PrioritizeRightClickMelee(XComGameState_Unit UnitState, out XComGameState_Ability PrioritizedMeleeAbility, optional XComGameState_BaseObject TargetObject) { # Delegate Priority You can optionally specify callback Priority. The default Priority is 50. ```unrealscript CHHelpersObj.AddPrioritizeRightClickMeleeCallback(PrioritizeRightClickMelee, 45); Delegates with higher Priority value are executed first. Delegates with the same Priority are executed in the order they were added to CHHelpers, which would normally be the same as DLCRunOrder . This function will return true if the delegate was successfully registered.","title":"How to use"},{"location":"tactical/PrioritizeRightClickMelee/#removing-delegates","text":"If necessary, use this function to remove a delegate. CHHelpersObj.RemovePrioritizeRightClickMeleeCallback(PrioritizeRightClickMelee); The function will return true if the Callback was successfully deleted, return false otherwise.","title":"Removing Delegates"},{"location":"tactical/PrioritizeRightClickMelee/#source-code-references","text":"X2AbilityTrigger_EndOfMove.uc:31-54 CHHelpers.uc:1014-1023 CHHelpers.uc:1061-1067","title":"Source code references"},{"location":"tactical/ProjectilePerformanceDrain/","text":"ProjectilePerformanceDrain Tracking Issue: #720 The game uses a global pool WorldInfo.MyEmitterPool to store Particle System Components (PSCs), which helps optimize performance. When a PSC is no longer needed, it is returned to the pool so that it can be reused again later. To return a PSC back to the pool, the EmitterPool::OnParticleSystemFinished() function must be called, which usually happens seamlessly - the pool sets the ParticleSystemComponent::OnSystemFinished delegate to the aforementioned function when the PSC is initially borrowed from the pool (via EmitterPool::SpawnEmitter ). However, X2UnifiedProjectile overwrites the OnSystemFinished delegate with its own one after borrowing the PSC from the pool, which means the EmitterPool::OnParticleSystemFinished() is never called for these PSCs. As such, the pool is never made aware that those PSCs are ready for reuse and when a new PCS is requested, the pool has no choice but to simply create a new one, resulting in the pool getting bloated with all the PSCs ever spawned by X2UnifiedProjectile s. This bloat leads to two observable effects: endlessly increasing RAM usage and a significant performance degradation. The more projectiles are fired over the course of a mission, the worse these effects become. Frequent use of the Suppression ability or Idle Suppression mod kick the problem into overdrive. To address this bug, we manually call WorldInfo.MyEmitterPool.OnParticleSystemFinished() on PSCs in X2UnifiedProjectile when the projectile is done with them. Compability note : some particle systems cannot be returned directly after the projectile is done with the particle system - doing so destoys trails/smoke/effects that dissipate over time (e.g. rocket trails). To address this issue, we delay the return to pool (and the forced destruction of any remaining particles) by 1 minute. If this is not enough for your particle system, you can override the behaviour in XComGame.ini . Here's an example/template: [XComGame.CHHelpers] +ProjectileParticleSystemExpirationOverrides=(ParticleSystemPathName=\"SomePackage.P_SomeParticleSystem\", ExpiryTime=120) Property Value ParticleSystemPathName The full path to your ParticleSystem (what you configure with emitters in the editor) ExpiryTime Time in seconds to pass between the projectile being done with the system and its return to the pool Keep in mind that the above time (either the 1 min default or the override) is the max allowed delay - if a particle system finishes (and reports so by calling PSC.OnSystemFinished ), the delay will be aborted and the PSC will be instantly returned to the pool. As such, there is no need/reason to manually set lower expiration times than the default - just make sure that your particle system is properly configured in the editor. Mods that create Particle System Components using the Emitter Pool must carefully handle them the same way: if the PSC's OnSystemFinished delegate is replaced, then EmitterPool::OnParticleSystemFinished() must be called for this PSC manually when the PSC is no longer needed, otherwise the same \"memory leak\" will occur. This applies to all PSCs using the Emitter Pool, not just those in X2UnifiedProjectile . Source code references X2UnifiedProjectile.uc:406-457 XComGame.ini:250 CHHelpers.uc:236 X2TacticalGameRuleset.uc:3092 X2TacticalGameRuleset.uc:3752 X2UnifiedProjectile.uc:1168 X2UnifiedProjectile.uc:2230 X2UnifiedProjectile.uc:2285 X2UnifiedProjectile.uc:2346","title":"ProjectilePerformanceDrain"},{"location":"tactical/ProjectilePerformanceDrain/#projectileperformancedrain","text":"Tracking Issue: #720 The game uses a global pool WorldInfo.MyEmitterPool to store Particle System Components (PSCs), which helps optimize performance. When a PSC is no longer needed, it is returned to the pool so that it can be reused again later. To return a PSC back to the pool, the EmitterPool::OnParticleSystemFinished() function must be called, which usually happens seamlessly - the pool sets the ParticleSystemComponent::OnSystemFinished delegate to the aforementioned function when the PSC is initially borrowed from the pool (via EmitterPool::SpawnEmitter ). However, X2UnifiedProjectile overwrites the OnSystemFinished delegate with its own one after borrowing the PSC from the pool, which means the EmitterPool::OnParticleSystemFinished() is never called for these PSCs. As such, the pool is never made aware that those PSCs are ready for reuse and when a new PCS is requested, the pool has no choice but to simply create a new one, resulting in the pool getting bloated with all the PSCs ever spawned by X2UnifiedProjectile s. This bloat leads to two observable effects: endlessly increasing RAM usage and a significant performance degradation. The more projectiles are fired over the course of a mission, the worse these effects become. Frequent use of the Suppression ability or Idle Suppression mod kick the problem into overdrive. To address this bug, we manually call WorldInfo.MyEmitterPool.OnParticleSystemFinished() on PSCs in X2UnifiedProjectile when the projectile is done with them. Compability note : some particle systems cannot be returned directly after the projectile is done with the particle system - doing so destoys trails/smoke/effects that dissipate over time (e.g. rocket trails). To address this issue, we delay the return to pool (and the forced destruction of any remaining particles) by 1 minute. If this is not enough for your particle system, you can override the behaviour in XComGame.ini . Here's an example/template: [XComGame.CHHelpers] +ProjectileParticleSystemExpirationOverrides=(ParticleSystemPathName=\"SomePackage.P_SomeParticleSystem\", ExpiryTime=120) Property Value ParticleSystemPathName The full path to your ParticleSystem (what you configure with emitters in the editor) ExpiryTime Time in seconds to pass between the projectile being done with the system and its return to the pool Keep in mind that the above time (either the 1 min default or the override) is the max allowed delay - if a particle system finishes (and reports so by calling PSC.OnSystemFinished ), the delay will be aborted and the PSC will be instantly returned to the pool. As such, there is no need/reason to manually set lower expiration times than the default - just make sure that your particle system is properly configured in the editor. Mods that create Particle System Components using the Emitter Pool must carefully handle them the same way: if the PSC's OnSystemFinished delegate is replaced, then EmitterPool::OnParticleSystemFinished() must be called for this PSC manually when the PSC is no longer needed, otherwise the same \"memory leak\" will occur. This applies to all PSCs using the Emitter Pool, not just those in X2UnifiedProjectile .","title":"ProjectilePerformanceDrain"},{"location":"tactical/ProjectilePerformanceDrain/#source-code-references","text":"X2UnifiedProjectile.uc:406-457 XComGame.ini:250 CHHelpers.uc:236 X2TacticalGameRuleset.uc:3092 X2TacticalGameRuleset.uc:3752 X2UnifiedProjectile.uc:1168 X2UnifiedProjectile.uc:2230 X2UnifiedProjectile.uc:2285 X2UnifiedProjectile.uc:2346","title":"Source code references"},{"location":"tactical/RequiresTargetingActivation/","text":"RequiresTargetingActivation Tracking Issue: #476 When playing with a controller (gamepad), some abilities allow the player to press (A) again to aim the ability, which allows them to rotate the camera with the buttons that would normally cycle the ability selection. In base game this behaviour was hardcoded to work only for a few specific Targeting Methods. Highlander replaces the original implementation with a the RequiresTargetingActivation config array that takes values from XComGame.ini config file. This potentailly allows mods to use this behavior for custom Targeting Methods that do not extend any of the Targeting Methods that are already configured to use this behavior. [XComGame.CHHelpers] +RequiresTargetingActivation=X2TargetingMethod_Grenade +RequiresTargetingActivation=X2TargetingMethod_Cone Source code references UITacticalHUD_AbilityContainer.uc:171-186 XComGame.ini:48","title":"RequiresTargetingActivation"},{"location":"tactical/RequiresTargetingActivation/#requirestargetingactivation","text":"Tracking Issue: #476 When playing with a controller (gamepad), some abilities allow the player to press (A) again to aim the ability, which allows them to rotate the camera with the buttons that would normally cycle the ability selection. In base game this behaviour was hardcoded to work only for a few specific Targeting Methods. Highlander replaces the original implementation with a the RequiresTargetingActivation config array that takes values from XComGame.ini config file. This potentailly allows mods to use this behavior for custom Targeting Methods that do not extend any of the Targeting Methods that are already configured to use this behavior. [XComGame.CHHelpers] +RequiresTargetingActivation=X2TargetingMethod_Grenade +RequiresTargetingActivation=X2TargetingMethod_Cone","title":"RequiresTargetingActivation"},{"location":"tactical/RequiresTargetingActivation/#source-code-references","text":"UITacticalHUD_AbilityContainer.uc:171-186 XComGame.ini:48","title":"Source code references"},{"location":"tactical/ShouldCivilianRun/","text":"ShouldCivilianRun Tracking Issue: #666 Tags: events Triggers a 'ShouldCivilianRun' event that allows listeners to determine whether neutrals should run in reaction to another unit moving by them. Returns true if the given neutral unit should run, false otherwise. ShouldCivilianRun event Param Value EventID ShouldCivilianRun EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 MovedUnit XComGameState_Unit in 1 AIAttacksCivilians bool in 2 ShouldRun bool inout Listener template static function EventListenerReturn OnShouldCivilianRun(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit Civilian; local XComLWTuple Tuple; local XComGameState_Unit MovedUnit; local bool AIAttacksCivilians; local bool ShouldRun; Civilian = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); MovedUnit = XComGameState_Unit(Tuple.Data[0].o); AIAttacksCivilians = Tuple.Data[1].b; ShouldRun = Tuple.Data[2].b; // Your code here Tuple.Data[2].b = ShouldRun; return ELR_NoInterrupt; } Source code references X2TacticalGameRuleset.uc:1710-1720","title":"ShouldCivilianRun"},{"location":"tactical/ShouldCivilianRun/#shouldcivilianrun","text":"Tracking Issue: #666 Tags: events Triggers a 'ShouldCivilianRun' event that allows listeners to determine whether neutrals should run in reaction to another unit moving by them. Returns true if the given neutral unit should run, false otherwise.","title":"ShouldCivilianRun"},{"location":"tactical/ShouldCivilianRun/#shouldcivilianrun-event","text":"Param Value EventID ShouldCivilianRun EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"ShouldCivilianRun event"},{"location":"tactical/ShouldCivilianRun/#tuple-contents","text":"Index Name Type Direction 0 MovedUnit XComGameState_Unit in 1 AIAttacksCivilians bool in 2 ShouldRun bool inout","title":"Tuple contents"},{"location":"tactical/ShouldCivilianRun/#listener-template","text":"static function EventListenerReturn OnShouldCivilianRun(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit Civilian; local XComLWTuple Tuple; local XComGameState_Unit MovedUnit; local bool AIAttacksCivilians; local bool ShouldRun; Civilian = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); MovedUnit = XComGameState_Unit(Tuple.Data[0].o); AIAttacksCivilians = Tuple.Data[1].b; ShouldRun = Tuple.Data[2].b; // Your code here Tuple.Data[2].b = ShouldRun; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/ShouldCivilianRun/#source-code-references","text":"X2TacticalGameRuleset.uc:1710-1720","title":"Source code references"},{"location":"tactical/ShouldUnitPatrolUnderway/","text":"ShouldUnitPatrolUnderway Tracking Issue: #1354 Tags: events This event allows mods to override the base game behavior that causes enemy pods to stop patrolling if they are spotted by a concealed XCOM unit. Originally implemented by LW2. Default behavior is if a pod has been spotted by a concealed XCOM unit, they will stop patrolling. ShouldUnitPatrolUnderway event Param Value EventID ShouldUnitPatrolUnderway EventData XComLWTuple EventSource XGAIPlayer NewGameState none Tuple contents Index Name Type Direction 0 ShouldOverrideUnrevealedAI bool inout 1 UnitState XComGameState_Unit in Listener template static function EventListenerReturn OnShouldUnitPatrolUnderway(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XGAIPlayer PlayerState; local XComLWTuple Tuple; local bool ShouldOverrideUnrevealedAI; local XComGameState_Unit UnitState; PlayerState = XGAIPlayer(EventSource); Tuple = XComLWTuple(EventData); ShouldOverrideUnrevealedAI = Tuple.Data[0].b; UnitState = XComGameState_Unit(Tuple.Data[1].o); // Your code here Tuple.Data[0].b = ShouldOverrideUnrevealedAI; return ELR_NoInterrupt; } Source code references XGAIPlayer.uc:776-787","title":"ShouldUnitPatrolUnderway"},{"location":"tactical/ShouldUnitPatrolUnderway/#shouldunitpatrolunderway","text":"Tracking Issue: #1354 Tags: events This event allows mods to override the base game behavior that causes enemy pods to stop patrolling if they are spotted by a concealed XCOM unit. Originally implemented by LW2. Default behavior is if a pod has been spotted by a concealed XCOM unit, they will stop patrolling.","title":"ShouldUnitPatrolUnderway"},{"location":"tactical/ShouldUnitPatrolUnderway/#shouldunitpatrolunderway-event","text":"Param Value EventID ShouldUnitPatrolUnderway EventData XComLWTuple EventSource XGAIPlayer NewGameState none","title":"ShouldUnitPatrolUnderway event"},{"location":"tactical/ShouldUnitPatrolUnderway/#tuple-contents","text":"Index Name Type Direction 0 ShouldOverrideUnrevealedAI bool inout 1 UnitState XComGameState_Unit in","title":"Tuple contents"},{"location":"tactical/ShouldUnitPatrolUnderway/#listener-template","text":"static function EventListenerReturn OnShouldUnitPatrolUnderway(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XGAIPlayer PlayerState; local XComLWTuple Tuple; local bool ShouldOverrideUnrevealedAI; local XComGameState_Unit UnitState; PlayerState = XGAIPlayer(EventSource); Tuple = XComLWTuple(EventData); ShouldOverrideUnrevealedAI = Tuple.Data[0].b; UnitState = XComGameState_Unit(Tuple.Data[1].o); // Your code here Tuple.Data[0].b = ShouldOverrideUnrevealedAI; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/ShouldUnitPatrolUnderway/#source-code-references","text":"XGAIPlayer.uc:776-787","title":"Source code references"},{"location":"tactical/UseMinDamageForUnitFlagPreview/","text":"UseMinDamageForUnitFlagPreview Tracking Issue: #579 Tags: ui Allows using ability's minimum damage rather than max damage for the unit flag damage preview. Source code references UIUnitFlagManager.uc:652-653 XComGame.ini:281","title":"UseMinDamageForUnitFlagPreview"},{"location":"tactical/UseMinDamageForUnitFlagPreview/#usemindamageforunitflagpreview","text":"Tracking Issue: #579 Tags: ui Allows using ability's minimum damage rather than max damage for the unit flag damage preview.","title":"UseMinDamageForUnitFlagPreview"},{"location":"tactical/UseMinDamageForUnitFlagPreview/#source-code-references","text":"UIUnitFlagManager.uc:652-653 XComGame.ini:281","title":"Source code references"},{"location":"tactical/eCleanup_BeginTacticalChain/","text":"eCleanup_BeginTacticalChain Tracking Issue: #559 eCleanup_BeginTactical cleans up unit values after every transfer from strategy and every direct tactical transfer. In some cases, the latter behavior is undesirable. For example, free reloads should not reset in each part of a multi-part mission. eCleanup_BeginTacticalChain handles these cases. It only cleans up unit values after transferring from strategy. Source code references X2TacticalGameRulesetDataStructures.uc:582-585","title":"eCleanup_BeginTacticalChain"},{"location":"tactical/eCleanup_BeginTacticalChain/#ecleanup_begintacticalchain","text":"Tracking Issue: #559 eCleanup_BeginTactical cleans up unit values after every transfer from strategy and every direct tactical transfer. In some cases, the latter behavior is undesirable. For example, free reloads should not reset in each part of a multi-part mission. eCleanup_BeginTacticalChain handles these cases. It only cleans up unit values after transferring from strategy.","title":"eCleanup_BeginTacticalChain"},{"location":"tactical/eCleanup_BeginTacticalChain/#source-code-references","text":"X2TacticalGameRulesetDataStructures.uc:582-585","title":"Source code references"}]}